

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Dongys">
  <meta name="keywords" content="">
  
  <title>Kafka源码解析-索引文件及内存映射 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"dong-ys.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Dongys's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://picture.zwc365.com/getbing.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Kafka源码解析-索引文件及内存映射">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-09-02 10:44" pubdate>
        2022年9月2日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      73
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Kafka源码解析-索引文件及内存映射</h1>
            
            <div class="markdown-body">
              <h1 id="Kafka源码解析-索引文件及内存映射"><a href="#Kafka源码解析-索引文件及内存映射" class="headerlink" title="Kafka源码解析-索引文件及内存映射"></a>Kafka源码解析-索引文件及内存映射</h1><h2 id="索引类图及源文件组织架构"><a href="#索引类图及源文件组织架构" class="headerlink" title="索引类图及源文件组织架构"></a>索引类图及源文件组织架构</h2><p>在 Kafka 源码中，跟索引相关的源码文件有 5 个，它们都位于 core 包的&#x2F;src&#x2F;main&#x2F;scala&#x2F;kafka&#x2F;log 路径下：</p>
<ul>
<li><p>AbstractIndex.scala：它定义了最顶层的抽象类，这个类封装了所有索引类型的公共操作</p>
</li>
<li><p>LazyIndex.scala：它定义了 AbstractIndex 上的一个包装类，实现索引项延迟加载，这个类主要是为了提高性能。</p>
</li>
<li><p>OffsetIndex.scala：定义位移索引，保存&lt; 位移值，文件磁盘物理位置 &gt;键值对。</p>
</li>
<li><p>TimeIndex.scala：定义时间戳索引，保存&lt; 时间戳，位移值 &gt;键值对。</p>
</li>
<li><p>TransactionIndex.scala：定义事务索引，为已中止事务（Aborted Transcation）保存重要的元数据信息。只有启用 Kafka 事务后，这个索引才有可能出现。</p>
</li>
</ul>
<p>这些类的关系如下图所示：</p>
<img src="/2022/09/02/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/image-20220902105725347.png" srcset="/img/loading.gif" lazyload class="" title="image-20220902105725347">

<p>其中，OffsetIndex、TimeIndex 和 TransactionIndex 都继承了 AbstractIndex 类，而上层的 LazyIndex 仅仅是包装了一个 AbstractIndex 的实现类，用于延迟加载。</p>
<h2 id="索引文件结构"><a href="#索引文件结构" class="headerlink" title="索引文件结构"></a>索引文件结构</h2><h3 id="AbstractIndex-代码结构"><a href="#AbstractIndex-代码结构" class="headerlink" title="AbstractIndex 代码结构"></a>AbstractIndex 代码结构</h3><p>先看一下 AbstractIndex 的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractIndex</span>(<span class="hljs-params">@volatile private var _file: <span class="hljs-type">File</span>, val baseOffset: <span class="hljs-type">Long</span>, val maxIndexSize: <span class="hljs-type">Int</span> = -1,val writable: <span class="hljs-type">Boolean</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Closeable</span></span><br></code></pre></td></tr></table></figure>

<p>AbstractIndex 定义了 4 个属性字段。由于是一个抽象基类，它的所有子类自动地继承了这 4 个字段。</p>
<ul>
<li>索引文件（file）：每个索引对象在磁盘上都对应了一个索引文件。这个字段是var修饰，说明是可变的，自1.1.0版本后Kafka 允许迁移底层的日志路径</li>
<li>起始位移值（baseOffset）：索引对象对应日志段对象的起始位移值。举个例子，如果你查看 Kafka 日志路径的话，就会发现，日志文件和索引文件都是成组出现的。比如说，如果日志文件是 00000000000000000123.log，正常情况下，一定还有一组索引文件 00000000000000000123.index、00000000000000000123.timeindex 等。这里的123就是这组文件的起始位移值，也就是baseOffset 值。</li>
<li>索引文件最大字节数（maxIndexSize）：它控制索引文件的最大长度。Kafka 源码传入该参数的值是 Broker 端参数 segment.index.bytes 的值，即 10MB。这就是在默认情况下，所有 Kafka 索引文件大小都是 10MB 的原因。</li>
<li>索引文件打开方式（Writable）：True表示以读写方式打开，False表示以只读方式打开。</li>
</ul>
<p>AbstractIndex 是抽象的索引对象类。可以说，它是承载索引项的容器，而每个继承它的子类负责定义具体的索引项结构。比如，OffsetIndex 的索引项是 &lt; 位移值，物理磁盘位置&gt; 对，TimeIndex 的索引项是 &lt; 时间戳，位移值 &gt; 对。基于这样的设计理念，AbstractIndex 类中定义了一个抽象方法 entrySize 来表示不同索引项的大小，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">entrySize</span></span>: <span class="hljs-type">Int</span><br></code></pre></td></tr></table></figure>

<p>子类实现该方法时需要给定自己索引项的大小，对于 OffsetIndex 而言，该值就是 8；对于 TimeIndex 而言，该值是 12</p>
<h3 id="OffsetIndex结构"><a href="#OffsetIndex结构" class="headerlink" title="OffsetIndex结构"></a>OffsetIndex结构</h3><p>对于偏移量索引文件，保存的是 <strong>&lt;相对偏移量，物理地址&gt;</strong> 的对应关系，文件中的相对偏移量是单调递增的。</p>
<p>查询<strong>指定偏移量</strong>对应的消息时，使用<strong>改进的二分查找算法</strong>来快速定位偏移量的位置，如果指定的偏移量不在索引文件中，则会返回文件中小于指定偏移量的最大偏移量及对应的物理地址，该逻辑通过OffsetIndex.lookup()方法实现。</p>
<p>偏移量索引文件的索引项结构如下图所示，每个索引项记录了相对偏移量relativeOffset和对应消息的第一个字节在日志段文件中的物理地址position，共占用8个字节。</p>
<img src="/2022/09/02/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/modb_20211012_1a8862f2-2b3f-11ec-94a3-fa163eb4f6be.png" srcset="/img/loading.gif" lazyload class="" title="img">

<p>为什么使用相对偏移量？这样可以节约存储空间。每条消息的<strong>绝对偏移量</strong>占用8个字节，而<strong>相对偏移量</strong>只占用4个字节（relativeOffset&#x3D;offset-baseOffset）。在日志段文件滚动的条件中，有一个是：追加消息的最大偏移量和当前日志段的baseOffset的差值大于Int.MaxValue，因为如果大于这个值，4个字节就无法存储相对偏移量了。</p>
<p><strong>偏移量索引文件的查找原理：</strong></p>
<p>假设要查找偏移量为230的消息，查找过程如下：</p>
<img src="/2022/09/02/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/modb_20211012_1aa37880-2b3f-11ec-94a3-fa163eb4f6be.png" srcset="/img/loading.gif" lazyload class="" title="img">

<ul>
<li>首先找到baseOffset&#x3D;217的日志段文件（这里使用了跳跃表的结构来加速查找）</li>
<li>计算相对偏移量relativeOffset&#x3D;230-217&#x3D;13</li>
<li>在索引文件中查找不大于13的最大相对偏移量对应的索引项，即[12,456]</li>
<li>根据12对应的物理地址456，在日志文件.log中定位到准确位置</li>
<li>从日志文件物理位置456继续向后查找找到相对偏移量为13，即绝对偏移量为230，物理地址为468的消息</li>
</ul>
<h3 id="TimeIndex结构"><a href="#TimeIndex结构" class="headerlink" title="TimeIndex结构"></a>TimeIndex结构</h3><p>对于时间戳索引文件，保存的是 <strong>&lt;时间戳，相对偏移量&gt;</strong> 的对应关系，文件中的时间戳和相对偏移量都是单调递增的。</p>
<p>查询<strong>指定时间戳</strong>对应的消息时， 需要配合偏移量索引文件进行查找。首先通过改进的二分查找在时间戳索引文件中找到不大于目标时间戳的索引项，然后根据索引项的相对偏移量在偏移量索引文件中查找，查找方式就是上面指定偏移量的方式。 </p>
<p>时间戳索引文件的索引项结构如下图所示，每个索引项记录了时间戳timestamp和相对偏移量relativeOffset的对应关系，共占用12个字节。</p>
<img src="/2022/09/02/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/modb_20211012_1afe0a02-2b3f-11ec-94a3-fa163eb4f6be-20220902112958181.png" srcset="/img/loading.gif" lazyload class="" title="img">

<p><strong>时间戳索引文件的查找原理：</strong></p>
<p>假设要查找时间戳为1540的消息，查找过程如下（这里时间戳只是一个示意值）：</p>
<img src="/2022/09/02/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/modb_20211012_1b2d6a0e-2b3f-11ec-94a3-fa163eb4f6be.png" srcset="/img/loading.gif" lazyload class="" title="img">

<ul>
<li>将要查找的时间戳1540和每个日志段的最大时间戳逐一对比，直到找到最大时间戳不小于1540的日志段。（日志段的最大时间戳：获取时间戳索引文件最后一个索引项的时间戳，如果大于0，取该值；否则取日志段的最近修改时间）</li>
<li>找到对应的日志段后，在时间戳索引文件中使用二分查找找到不大于目标时间戳1540的最大索引项，即图中的[1530,12]，获取对应的相对偏移量12</li>
<li>在该日志段的偏移量索引文件中找到相对偏移量不大于12的索引项，即图中的[12，456]</li>
<li>在日志文件中从物理位置456开始查找时间戳不小于1540的消息</li>
</ul>
<h2 id="索引文件具体操作源码"><a href="#索引文件具体操作源码" class="headerlink" title="索引文件具体操作源码"></a>索引文件具体操作源码</h2><h3 id="位移值相互转换"><a href="#位移值相互转换" class="headerlink" title="位移值相互转换"></a>位移值相互转换</h3><p>在 OffsetIndex 和 TimeIndex 的抽象父类 AbstractIndex 中定义了 relativeOffset方法，通过绝对位移值计算相对位移值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relativeOffset</span></span>(offset: <span class="hljs-type">Long</span>): <span class="hljs-type">Int</span> = &#123;<br>  <span class="hljs-keyword">val</span> relativeOffset = toRelative(offset)<br>  <span class="hljs-keyword">if</span> (relativeOffset.isEmpty)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IndexOffsetOverflowException</span>(<span class="hljs-string">s&quot;Integer overflow for offset: <span class="hljs-subst">$offset</span> (<span class="hljs-subst">$&#123;file.getAbsoluteFile&#125;</span>)&quot;</span>)<br>  relativeOffset.get<br>&#125;<br></code></pre></td></tr></table></figure>

<p>relativeOffset 方法调用了父类的 toRelative 方法执行真正的转换</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toRelative</span></span>(offset: <span class="hljs-type">Long</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = &#123;<br>  <span class="hljs-keyword">val</span> relativeOffset = offset - baseOffset<br>  <span class="hljs-keyword">if</span> (relativeOffset &lt; <span class="hljs-number">0</span> || relativeOffset &gt; <span class="hljs-type">Int</span>.<span class="hljs-type">MaxValue</span>)<br>    <span class="hljs-type">None</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-type">Some</span>(relativeOffset.toInt)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>逻辑很简单：</p>
<ul>
<li>第一步是计算给定的 offset 值与 baseOffset 的差值</li>
<li>第二步是校验该差值不能是负数或不能超过整型表示范围</li>
<li>如果校验通过，就直接返回该差值作为相对位移值，否则就返回 None 表示转换失败。</li>
</ul>
<p>当读取 OffsetIndex 或 TimeIndex 时，源码还需要将相对位移值还原成之前的完整位移。这个是在 parseEntry 方法中实现的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// OffsetIndex</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parseEntry</span></span>(buffer: <span class="hljs-type">ByteBuffer</span>, n: <span class="hljs-type">Int</span>): <span class="hljs-type">OffsetPosition</span> = &#123;<br>  <span class="hljs-type">OffsetPosition</span>(baseOffset + relativeOffset(buffer, n), physical(buffer, n))<br>&#125;<br><br><span class="hljs-comment">// TimeIndex</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parseEntry</span></span>(buffer: <span class="hljs-type">ByteBuffer</span>, n: <span class="hljs-type">Int</span>): <span class="hljs-type">TimestampOffset</span> = &#123;<br>  <span class="hljs-type">TimestampOffset</span>(timestamp(buffer, n), baseOffset + relativeOffset(buffer, n))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以 OffsetIndex 为例，这个方法返回一个 OffsetPosition 类型。该类有两个方法，分别返回索引项的 Key 和 Value。</p>
<p><strong>这里的 parseEntry 方法，就是要构造 OffsetPosition 所需的 Key 和 Value</strong>。Key 是索引项中的完整位移值，<strong>代码使用 baseOffset + relativeOffset(buffer, n) 的方式将相对位移值还原成完整位移值</strong>；Value 是这个位移值上消息在日志段文件中的物理位置，代码调用 physical 方法计算这个物理位置并把它作为 Value。</p>
<p>由于索引文件的总字节数就是索引项字节数乘以索引项数，因此，代码结合 entrySize 和buffer.getInt 方法能够轻松地计算出第 n 个索引项所处的物理文件位置。这就是 physical 方法做的事情：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">physical</span></span>(buffer: <span class="hljs-type">ByteBuffer</span>, n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = buffer.getInt(n * entrySize + <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<h3 id="写入索引项"><a href="#写入索引项" class="headerlink" title="写入索引项"></a>写入索引项</h3><p><strong>OffsetIndex：append</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span></span>(offset: <span class="hljs-type">Long</span>, position: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>  inLock(lock) &#123;<br>    <span class="hljs-comment">// 第1步:判断索引文件未写满</span><br>    require(!isFull, <span class="hljs-string">&quot;Attempt to append to a full index (size = &quot;</span> + _entries + <span class="hljs-string">&quot;).&quot;</span>)<br>    <span class="hljs-comment">// 第2步:必须满足以下条件之一才允许写入索引项:</span><br>    <span class="hljs-comment">// 条件1:当前索引文件为空</span><br>    <span class="hljs-comment">// 条件2:要写入的位移大于当前所有已写入的索引项的位移</span><br>    <span class="hljs-keyword">if</span> (_entries == <span class="hljs-number">0</span> || offset &gt; _lastOffset) &#123;<br>      trace(<span class="hljs-string">s&quot;Adding index entry <span class="hljs-subst">$offset</span> =&gt; <span class="hljs-subst">$position</span> to <span class="hljs-subst">$&#123;file.getAbsolutePath&#125;</span>&quot;</span>)<br>      <span class="hljs-comment">// 第3步A:向mmap中写入相对位移值</span><br>      mmap.putInt(relativeOffset(offset))<br>      <span class="hljs-comment">// 第3步B:向mmap中写入物理位置信息</span><br>      mmap.putInt(position)<br>      <span class="hljs-comment">// 第4步:更新其他元数据统计信息</span><br>      <span class="hljs-comment">// 更新索引项数量</span><br>      _entries += <span class="hljs-number">1</span><br>      <span class="hljs-comment">// 更新当前索引文件最大位移值</span><br>      _lastOffset = offset<br>      <span class="hljs-comment">// 第5步:执行校验。写入的索引项格式必须符合要求</span><br>      require(_entries * entrySize == mmap.position(), <span class="hljs-string">s&quot;<span class="hljs-subst">$entries</span> entries but file position in index is <span class="hljs-subst">$&#123;mmap.position()&#125;</span>.&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">InvalidOffsetException</span>(<span class="hljs-string">s&quot;Attempt to append an offset (<span class="hljs-subst">$offset</span>) to position <span class="hljs-subst">$entries</span> no larger than&quot;</span> +<br>        <span class="hljs-string">s&quot; the last offset appended (<span class="hljs-subst">$&#123;_lastOffset&#125;</span>) to <span class="hljs-subst">$&#123;file.getAbsolutePath&#125;</span>.&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>TimeIndex：mabeyAppend</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maybeAppend</span></span>(timestamp: <span class="hljs-type">Long</span>, offset: <span class="hljs-type">Long</span>, skipFullCheck: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>): <span class="hljs-type">Unit</span> = &#123;<br>  inLock(lock) &#123;<br>    <span class="hljs-comment">// 如果索引文件已经写满，抛出异常</span><br>    <span class="hljs-keyword">if</span> (!skipFullCheck)<br>      require(!isFull, <span class="hljs-string">&quot;Attempt to append to a full time index (size = &quot;</span> + _entries + <span class="hljs-string">&quot;).&quot;</span>)<br>    <span class="hljs-comment">// We do not throw exception when the offset equals to the offset of last entry. That means we are trying</span><br>    <span class="hljs-comment">// to insert the same time index entry as the last entry.</span><br>    <span class="hljs-comment">// If the timestamp index entry to be inserted is the same as the last entry, we simply ignore the insertion</span><br>    <span class="hljs-comment">// because that could happen in the following two scenarios:</span><br>    <span class="hljs-comment">// 1. A log segment is closed.</span><br>    <span class="hljs-comment">// 2. LogSegment.onBecomeInactiveSegment() is called when an active log segment is rolled.</span><br>    <span class="hljs-comment">// 确保索引单调增加性</span><br>    <span class="hljs-keyword">if</span> (_entries != <span class="hljs-number">0</span> &amp;&amp; offset &lt; lastEntry.offset)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">InvalidOffsetException</span>(<span class="hljs-string">s&quot;Attempt to append an offset (<span class="hljs-subst">$offset</span>) to slot <span class="hljs-subst">$&#123;_entries&#125;</span> no larger than&quot;</span> +<br>        <span class="hljs-string">s&quot; the last offset appended (<span class="hljs-subst">$&#123;lastEntry.offset&#125;</span>) to <span class="hljs-subst">$&#123;file.getAbsolutePath&#125;</span>.&quot;</span>)<br>    <span class="hljs-comment">// 确保时间戳的单调增加性</span><br>    <span class="hljs-keyword">if</span> (_entries != <span class="hljs-number">0</span> &amp;&amp; timestamp &lt; lastEntry.timestamp)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalStateException</span>(<span class="hljs-string">s&quot;Attempt to append a timestamp (<span class="hljs-subst">$timestamp</span>) to slot <span class="hljs-subst">$&#123;_entries&#125;</span> no larger&quot;</span> +<br>        <span class="hljs-string">s&quot; than the last timestamp appended (<span class="hljs-subst">$&#123;lastEntry.timestamp&#125;</span>) to <span class="hljs-subst">$&#123;file.getAbsolutePath&#125;</span>.&quot;</span>)<br>    <span class="hljs-comment">// We only append to the time index when the timestamp is greater than the last inserted timestamp.</span><br>    <span class="hljs-comment">// If all the messages are in message format v0, the timestamp will always be NoTimestamp. In that case, the time</span><br>    <span class="hljs-comment">// index will be empty.</span><br>    <span class="hljs-keyword">if</span> (timestamp &gt; lastEntry.timestamp) &#123;<br>      trace(<span class="hljs-string">s&quot;Adding index entry <span class="hljs-subst">$timestamp</span> =&gt; <span class="hljs-subst">$offset</span> to <span class="hljs-subst">$&#123;file.getAbsolutePath&#125;</span>.&quot;</span>)<br>      <span class="hljs-comment">// 向mmap写入时间戳</span><br>      mmap.putLong(timestamp)<br>      <span class="hljs-comment">// 向mmap写入相对位移值</span><br>      mmap.putInt(relativeOffset(offset))<br>      <span class="hljs-comment">// 更新索引项个数</span><br>      _entries += <span class="hljs-number">1</span><br>      <span class="hljs-comment">// 更新当前最新索引项</span><br>      _lastEntry = <span class="hljs-type">TimestampOffset</span>(timestamp, offset)<br>      require(_entries * entrySize == mmap.position(), <span class="hljs-string">s&quot;<span class="hljs-subst">$&#123;_entries&#125;</span> entries but file position in index is <span class="hljs-subst">$&#123;mmap.position()&#125;</span>.&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和 OffsetIndex 类似，向 TimeIndex 写入索引项的主体逻辑，是向 mmap 分别写入时间戳和相对位移值。只不过，<strong>除了校验位移值的单调增加性之外，TimeIndex 还会确保顺序写入的时间戳也是单调增加的</strong>。</p>
<h3 id="截断索引文件"><a href="#截断索引文件" class="headerlink" title="截断索引文件"></a>截断索引文件</h3><p><strong>截断操作是指，将索引文件内容直接裁剪掉一部分</strong>。比如，OffsetIndex 索引文件中当前保存了 100个索引项，我想只保留最开始的 40 个索引项。源码定义了 truncateToEntries 方法来实现这个需求：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">truncateToEntries</span></span>(entries: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = &#123;<br>  inLock(lock) &#123;<br>    _entries = entries<br>    mmap.position(_entries * entrySize)<br>    _lastOffset = lastEntry.offset<br>    debug(<span class="hljs-string">s&quot;Truncated index <span class="hljs-subst">$&#123;file.getAbsolutePath&#125;</span> to <span class="hljs-subst">$entries</span> entries;&quot;</span> +<br>          <span class="hljs-string">s&quot; position is now <span class="hljs-subst">$&#123;mmap.position()&#125;</span> and last offset is now <span class="hljs-subst">$&#123;_lastOffset&#125;</span>&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法接收 entries 参数，表示<strong>要截取到哪个槽</strong>，主要的逻辑实现是调用 mmap 的 position 方法。源码中的 _entries * entrySize 就是 mmap 要截取到的字节处。</p>
<h3 id="查找索引项"><a href="#查找索引项" class="headerlink" title="查找索引项"></a>查找索引项</h3><p>索引项的写入逻辑并不复杂，难点在于如何查找索引项。AbstractIndex 定义了抽象方法<strong>parseEntry</strong> 用于查找给定的索引项，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parseEntry</span></span>(buffer: <span class="hljs-type">ByteBuffer</span>, n: <span class="hljs-type">Int</span>): <span class="hljs-type">IndexEntry</span><br></code></pre></td></tr></table></figure>

<p>这里的 n 表示要查找给定 ByteBuffer 中保存的第 n 个索引项（在 Kafka 中也称第 n 个槽）。IndexEntry 是源码定义的一个接口，里面有两个方法：indexKey 和 indexValue，分别返回不同类型索引的 &lt;Key，Value&gt; 对。</p>
<p>OffsetIndex 实现 parseEntry 的逻辑如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">override</span> <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parseEntry</span></span>(buffer: <span class="hljs-type">ByteBuffer</span>, n: <span class="hljs-type">Int</span>): <span class="hljs-type">OffsetPosition</span> = &#123;<br>  <span class="hljs-type">OffsetPosition</span>(baseOffset + relativeOffset(buffer, n), physical(buffer, n))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>OffsetPosition 是实现 IndexEntry 的实现类，Key 就是之前说的位移值，而 Value 就是物理磁盘位置值。所以，这里你能看到代码调用了 relativeOffset(buffer, n) + baseOffset 计算出绝对位移值，之后调用 physical(buffer, n) 计算物理磁盘位置，最后将它们封装到一起作为一个独立的索引项返回。</p>
<p>有了 parseEntry 方法，我们就能够根据给定的 n 来查找索引项了。但是，这里还有个问题需要解决，那就是，我们如何确定要找的索引项在第 n 个槽中呢？其实本质上，这是一个算法问题，也就是如何从一组已排序的数中快速定位符合条件的那个数。</p>
<h2 id="改进版二分查找算法"><a href="#改进版二分查找算法" class="headerlink" title="改进版二分查找算法"></a>改进版二分查找算法</h2><p>从已排序数组中寻找某个数字最快速的算法就是二分查找了，它能做到 O(lgN) 的时间复杂度。Kafka 的索引组件就应用了二分查找算法。</p>
<p>大多数操作系统使用页缓存来实现内存映射，而目前几乎所有的操作系统都使用 LRU（Least Recently Used）或类似于 LRU 的机制来管理页缓存。Kafka 写入索引文件的方式是在文件末尾追加写入，而几乎所有的索引查询都集中在索引的尾部。这么来看的话，LRU 机制是非常适合 Kafka 的索引访问场景的。</p>
<p>但这里有个问题是，当 Kafka 在查询索引的时候，原版的二分查找算法并没有考虑到缓存的问题，因此很可能会导致一些不必要的缺页中断（Page Fault）。此时，Kafka 线程会被阻塞，等待对应的索引项从物理磁盘中读出并放入到页缓存中。</p>
<p>下面我举个例子来说明一下这个情况，在 Kafka 源码注释中也有详细解释如何解决 Page Fault 问题。假设 Kafka 的某个索引占用了操作系统页缓存 13 个页（Page），如果待查找的位移值位于最后一个页上，也就是 Page 12，那么标准的二分查找算法会依次读取页号 0、6、9、11 和 12，具体的推演流程如下所示：</p>
<img src="/2022/09/02/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/image-20220902140008810.png" srcset="/img/loading.gif" lazyload class="" title="image-20220902140008810">

<p>通常来说，一个页上保存了成百上千的索引项数据。随着索引文件不断被写入，Page #12不断地被填充新的索引项。如果此时索引查询方都来自 ISR 副本或 Lag 很小的消费者，那么这些查询大多集中在对 Page #12 的查询，因此，Page #0、6、9、11、12 一定经常性地被源码访问。也就是说，这些页一定保存在页缓存上。后面当新的索引项填满了 Page#12，页缓存就会申请一个新的 Page 来保存索引项，即 Page #13。</p>
<p>现在，最新索引项保存在 Page #13 中。如果要查找最新索引项，原版二分查找算法将会依次访问 Page #0、7、10、12 和 13。此时，问题来了：Page 7 和 10 已经很久没有被访问过了，它们大概率不在页缓存中，因此，一旦索引开始征用 Page #13，就会发生Page Fault，等待那些冷页数据从磁盘中加载到页缓存。根据国外用户的测试，这种加载过程可能长达 1 秒。</p>
<p>每当索引文件占用 Page 数发生变化时，就会强行变更二分查找的搜索路径，从而出现不在页缓存的冷数据必须要加载到页缓存的情形，而这种加载过程是非常耗时的。</p>
<p>基于这个问题，Kafka 社区提出了改进版的二分查找策略，也就是缓存友好的搜索算法。总体的思路是，代码将所有索引项分成两个部分：热区（Warm Area）和冷区（Cold Area），然后分别在这两个区域内执行二分查找算法。</p>
<p>这个改进版算法提供了一个重要的保证：<strong>它能保证那些经常需要被访问的 Page 组合是固定的</strong>。</p>
<p>想想刚才的例子，同样是查询最热的那部分数据，一旦索引占用了更多的 Page，要遍历的Page 组合就会发生变化。这是导致性能下降的主要原因。</p>
<p>这个改进版算法的最大好处在于，<strong>查询最热那部分数据所遍历的 Page 永远是固定的，因此大概率在页缓存中，从而避免无意义的 Page Fault</strong>。下面是 Kafka 改进后的的代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">indexSlotRangeFor</span></span>(idx: <span class="hljs-type">ByteBuffer</span>, target: <span class="hljs-type">Long</span>, searchEntity: <span class="hljs-type">IndexSearchType</span>): (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) = &#123;<br>  <span class="hljs-comment">// check if the index is empty</span><br>  <span class="hljs-comment">// 第1步:如果索引为空，直接返回&lt;-1,-1&gt;对</span><br>  <span class="hljs-keyword">if</span>(_entries == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binarySearch</span></span>(begin: <span class="hljs-type">Int</span>, end: <span class="hljs-type">Int</span>) : (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) = &#123;<br>    <span class="hljs-comment">// binary search for the entry</span><br>    <span class="hljs-keyword">var</span> lo = begin<br>    <span class="hljs-keyword">var</span> hi = end<br>    <span class="hljs-keyword">while</span>(lo &lt; hi) &#123;<br>      <span class="hljs-keyword">val</span> mid = (lo + hi + <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span><br>      <span class="hljs-keyword">val</span> found = parseEntry(idx, mid)<br>      <span class="hljs-keyword">val</span> compareResult = compareIndexEntry(found, target, searchEntity)<br>      <span class="hljs-keyword">if</span>(compareResult &gt; <span class="hljs-number">0</span>)<br>        hi = mid - <span class="hljs-number">1</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(compareResult &lt; <span class="hljs-number">0</span>)<br>        lo = mid<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> (mid, mid)<br>    &#125;<br>    (lo, <span class="hljs-keyword">if</span> (lo == _entries - <span class="hljs-number">1</span>) <span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> lo + <span class="hljs-number">1</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 第3步:确认热区首个索引项位于哪个槽。_warmEntries就是所谓的分割线</span><br>  <span class="hljs-keyword">val</span> firstHotEntry = <span class="hljs-type">Math</span>.max(<span class="hljs-number">0</span>, _entries - <span class="hljs-number">1</span> - _warmEntries)<br>  <span class="hljs-comment">// check if the target offset is in the warm section of the index</span><br>  <span class="hljs-comment">// 第4步:判断target位移值在热区还是冷区</span><br>  <span class="hljs-keyword">if</span>(compareIndexEntry(parseEntry(idx, firstHotEntry), target, searchEntity) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> binarySearch(firstHotEntry, _entries - <span class="hljs-number">1</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// check if the target offset is smaller than the least offset</span><br>  <span class="hljs-comment">// 第5步:确保target位移值不能小于当前最小位移值</span><br>  <span class="hljs-keyword">if</span>(compareIndexEntry(parseEntry(idx, <span class="hljs-number">0</span>), target, searchEntity) &gt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)<br><br>  <span class="hljs-comment">// 第6步:如果在冷区，搜索冷区</span><br>  binarySearch(<span class="hljs-number">0</span>, firstHotEntry)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="mmap内存映射"><a href="#mmap内存映射" class="headerlink" title="mmap内存映射"></a>mmap内存映射</h2><p>在分析内存映射之前，首先看一下普通网络IO操作是如何进行的，在 Kafka 中有两类场景：</p>
<ul>
<li>Producer 生产的数据发送到 Broker，网络数据持久化到磁盘，Kafka 通过mmap提升效率。</li>
<li>Broker 的数据发送到 Consumer，磁盘数据网络传输，Kafka 通过零拷贝的技术提升效率。</li>
</ul>
<p>这里主要讨论第一种场景，</p>
<p><strong>数据落盘通常都是非实时的，kafka 生产者数据持久化也是如此。Kafka 的数据并不是实时的写入硬盘，它充分利用了现代操作系统分页存储来利用内存提高I&#x2F;O效率。</strong></p>
<p><strong>对于 kafka 来说，Producer 生产的数据存到 Broker，这个过程读取到 socket buffer 的网络数据，其实可以直接在OS内核缓冲区，完成落盘。并没有必要将 socket buffer 的网络数据，读取到应用进程缓冲区；在这里应用进程缓冲区其实就是 broker，broker 收到生产者的数据，就是为了持久化。</strong></p>
<p>在此特殊场景下：接收来自socket buffer的网络数据，应用进程不需要中间处理、直接进行持久化时。——可以使用mmap内存文件映射。</p>
<p>下图是普通 I&#x2F;O 操作的流程，普通的IO操作的一个弊端，必然涉及到两次数据拷贝操作，对磁盘读写性能是有影响的。必须先把数据写入到用户进程私有空间里去，然后从这里再进入内核IO缓冲区，最后进入磁盘文件里去</p>
<img src="/2022/09/02/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/B75D7781A04D496BBF29C8FC92094794.png" srcset="/img/loading.gif" lazyload class="" title="image">

<p>采用内存映射后，将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也可以直接反映到用户空间。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。<strong>PageCache，实际上在这里就是对应于虚拟内存</strong>，示意图如下：</p>
<img src="/2022/09/02/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/image-20220902154900934.png" srcset="/img/loading.gif" lazyload class="" title="image-20220902154900934">

<p>上面的图里，似乎只有一次数据拷贝的过程，他就是从PageCache里拷贝到磁盘文件里而已！这个就是你使用mmap技术之后，相比于传统磁盘IO的一个性能优化。</p>
<p>通过使用内存映射可以减少一次数据拷贝，从而提高读写性能。</p>
<p>JavaNIO 提供了 <strong>MappedByteBuffer</strong> 来实现内存映射，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileReadWithMmap</span><span class="hljs-params">(File file)</span> &#123;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[BUFFER_SIZE];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) file.length();<br>    MappedByteBuffer buff;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file).getChannel()) &#123;<br>        <span class="hljs-comment">// 将文件所有字节映射到内存中。返回MappedByteBuffer</span><br>        buff = channel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, channel.size());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; offset &lt; len; offset += BUFFER_SIZE) &#123;<br>            <span class="hljs-keyword">if</span> (len - offset &gt; BUFFER_SIZE) &#123;<br>                buff.get(b);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                buff.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len - offset]);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;time is:&quot;</span> + (end - begin));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Kafka 的 mmap 起始就是 MappedByteBuffer，mmap初始化代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@volatile</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">var</span> mmap: <span class="hljs-type">MappedByteBuffer</span> = &#123;<br>  <span class="hljs-comment">// 第1步：创建索引文件</span><br>  <span class="hljs-keyword">val</span> newlyCreated = file.createNewFile()<br>  <span class="hljs-comment">// 第2步:以writable指定的方式(读写方式或只读方式)打开索引文件</span><br>  <span class="hljs-keyword">val</span> raf = <span class="hljs-keyword">if</span> (writable) <span class="hljs-keyword">new</span> <span class="hljs-type">RandomAccessFile</span>(file, <span class="hljs-string">&quot;rw&quot;</span>) <span class="hljs-keyword">else</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RandomAccessFile</span>(file, <span class="hljs-string">&quot;r&quot;</span>)<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">/* pre-allocate the file if necessary */</span><br>    <span class="hljs-keyword">if</span>(newlyCreated) &#123;<br>      <span class="hljs-comment">// 预设的索引文件大小不能太小</span><br>      <span class="hljs-keyword">if</span>(maxIndexSize &lt; entrySize)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid max index size: &quot;</span> + maxIndexSize)<br>      <span class="hljs-comment">// 第3步:设置索引文件长度，计算不超过maxIndexSize，且是entrySize整数倍的最大文件长度</span><br>      <span class="hljs-comment">// roundDownToExactMultiple(67, 8) == 64</span><br>      raf.setLength(roundDownToExactMultiple(maxIndexSize, entrySize))<br>    &#125;<br><br>    <span class="hljs-comment">/* memory-map the file */</span><br>    <span class="hljs-comment">// 第4步:更新索引长度字段</span><br>    _length = raf.length()<br>    <span class="hljs-comment">// 第5步:创建MappedByteBuffer对象</span><br>    <span class="hljs-keyword">val</span> idx = &#123;<br>      <span class="hljs-keyword">if</span> (writable)<br>        raf.getChannel.map(<span class="hljs-type">FileChannel</span>.<span class="hljs-type">MapMode</span>.<span class="hljs-type">READ_WRITE</span>, <span class="hljs-number">0</span>, _length)<br>      <span class="hljs-keyword">else</span><br>        raf.getChannel.map(<span class="hljs-type">FileChannel</span>.<span class="hljs-type">MapMode</span>.<span class="hljs-type">READ_ONLY</span>, <span class="hljs-number">0</span>, _length)<br>    &#125;<br>    <span class="hljs-comment">/* set the position in the index for the next entry */</span><br>    <span class="hljs-comment">// 第6步:如果是新创建的索引文件，将MappedByteBuffer对象的当前位置置成0</span><br>    <span class="hljs-comment">// 如果索引文件已存在，将MappedByteBuffer对象的当前位置设置成最后一个索引项所在的位置</span><br>    <span class="hljs-keyword">if</span>(newlyCreated)<br>      idx.position(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// if this is a pre-existing index, assume it is valid and set position to last entry</span><br>      idx.position(roundDownToExactMultiple(idx.limit(), entrySize))<br>    <span class="hljs-comment">// 第7步:返回创建的MappedByteBuffer对象</span><br>    idx<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-type">CoreUtils</span>.swallow(raf.close(), <span class="hljs-type">AbstractIndex</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><strong>偏移量索引文件保存的是 &lt;相对偏移量，物理位置&gt; 索引项</strong></li>
<li><strong>时间戳索引文件保存的是 &lt;时间戳，相对偏移量&gt; 索引项</strong></li>
<li><strong>查找指定偏移量的消息时，只通过偏移量索引文件和日志文件就可以找到</strong></li>
<li><strong>查找指定时间戳的消息时，时间戳索引文件必须搭配偏移量索引文件使用</strong></li>
<li><strong>采用改进的二分查找算法，讲索引项分为热区和冷区，减少出现缺页的情况</strong></li>
<li><strong>索引文件为了提高读写性能，采用了mmap内存映射</strong></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Kafka/">Kafka</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Kafka/">Kafka</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/31/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%97%A5%E5%BF%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/">
                        <span class="hidden-mobile">Kafka源码解析-日志对象的常见操作</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
