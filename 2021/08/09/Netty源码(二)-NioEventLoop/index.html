

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Dongys">
  <meta name="keywords" content="">
  
  <title>Netty源码(二)-NioEventLoop - Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"dong-ys.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Dongys's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://picture.zwc365.com/getbing.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Netty源码(二)-NioEventLoop">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-09 10:22" pubdate>
        2021年8月9日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      93
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Netty源码(二)-NioEventLoop</h1>
            
            <div class="markdown-body">
              <h1 id="Netty源码-NioEventLoop"><a href="#Netty源码-NioEventLoop" class="headerlink" title="Netty源码-NioEventLoop"></a>Netty源码-NioEventLoop</h1><h2 id="NioEventLoopGroup的创建"><a href="#NioEventLoopGroup的创建" class="headerlink" title="NioEventLoopGroup的创建"></a>NioEventLoopGroup的创建</h2><p><code>NioEventLoopGroup</code>在客户端&#x2F;服务端初始化时创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br></code></pre></td></tr></table></figure>

<p><img src="/Netty%E6%BA%90%E7%A0%81(%E4%BA%8C)-NioEventLoop/image-20210809105651905.png" srcset="/img/loading.gif" lazyload alt="image-20210809105651905"></p>
<p>顶层接口是<code>Executor</code>可知<code>EventLoopGroup</code>支持执行一个异步任务，<code>ScheduledExecutorService</code>看名字可知子类将支持任务的调度执行，接下来我们继续跟进<code>EventLoopGroup</code>的构造方法，通过调用链发现它最终将调用到<code>MultithreadEventLoopGroup</code>的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor,</span><br><span class="hljs-params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));<br>        &#125;<br>		<span class="hljs-comment">// 创建线程执行器ThreadPerTaskExecutor</span><br>        <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>            executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br>        &#125;<br>		<span class="hljs-comment">// 创建NioEventLoop数组</span><br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br>	<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 初始化NioEventLoop数组</span><br>                children[i] = newChild(executor, args);<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 异常处理，关闭所有线程</span><br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                        children[j].shutdownGracefully();<br>                    &#125;<br><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                        <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> children[j];<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;<br>                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;<br>                            <span class="hljs-comment">// Let the caller handle the interruption.</span><br>                            Thread.currentThread().interrupt();<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>		<span class="hljs-comment">// 初始化线程选择器</span><br>        chooser = chooserFactory.newChooser(children);<br>		<span class="hljs-comment">// 终结监听器</span><br>        <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureListener</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>                    terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;<br>            e.terminationFuture().addListener(terminationListener);<br>        &#125;<br><br>        Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);<br>        Collections.addAll(childrenSet, children);<br>        readonlyChildren = Collections.unmodifiableSet(childrenSet);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>此处传递进来的<code>executor</code>为<code>null</code>，所以<code>MultithreadEventExecutorGroup</code>构造方法主要完成如下功能</p>
<ul>
<li>创建线程执行器<code>ThreadPerTaskExecutor</code></li>
<li>创建<code>NioEventLoop</code>数组</li>
<li>初始化<code>NioEventLoop</code>数组</li>
<li>初始化线程选择器</li>
</ul>
<h3 id="创建线程执行器"><a href="#创建线程执行器" class="headerlink" title="创建线程执行器"></a>创建线程执行器</h3><p>线程执行器通过调用<code>ThreadPerTaskExecutor</code>构造函数进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br></code></pre></td></tr></table></figure>

<p>在调用构造函数时传递的参数<code>ThreadFactory</code>为<code>DefaultThreadFactory</code>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory threadFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPerTaskExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">if</span> (threadFactory == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;threadFactory&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        threadFactory.newThread(command).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>execute()</code>方法的作用是新建线程并执行任务，<code>Netty</code>中的默认<code>NIO</code>线程都是由<code>DefaultThreadFactory</code>创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (t.isDaemon() != daemon) &#123;<br>                t.setDaemon(daemon);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (t.getPriority() != priority) &#123;<br>                t.setPriority(priority);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            <span class="hljs-comment">// Doesn&#x27;t matter even if failed to set.</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建线程的线程名<code>prefix + nextId.incrementAndGet()</code>到底是什么？跟踪代码发现<code>prefix</code>的规则是<code>poolName</code>和<code>poolId</code>(自增)通过<code>-</code>连接起来的(此处的<code>poolName</code>为<code>nioEventLoopGroup</code>)。所以<code>Netty</code>新建<code>NIO</code>线程默认名称为<code>nioEventLoopGroup-nioEventLoopGroupId-自增ID</code>，如<code>nioEventLoopGroup-2-1</code></p>
<h3 id="创建NioEventLoop数组"><a href="#创建NioEventLoop数组" class="headerlink" title="创建NioEventLoop数组"></a>创建<code>NioEventLoop</code>数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br></code></pre></td></tr></table></figure>

<p>关于<code>nThreads</code>如果用户显示指定<code>nThreads</code>数量那就按照用户指定的设置，否则这个值将是<code>CPU</code>核数的两倍。由于我们在创建<code>NioEventLoopGroup</code>时未传递任何参数，所以此处的<code>nThreads</code>为2倍的<code>CPU</code>核数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<br>        <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor, Object... args)</span> &#123;<br>    <span class="hljs-built_in">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>children</code>是<code>EventExecutor</code>数组，但是这里数组中的每个元素其实都是<code>NioEventLoop</code>实例</p>
<h3 id="初始化NioEventLoop数组"><a href="#初始化NioEventLoop数组" class="headerlink" title="初始化NioEventLoop数组"></a>初始化<code>NioEventLoop</code>数组</h3><p><code>children</code>数组的初始化是在以下代码中完成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">children[i] = newChild(executor, args);<br></code></pre></td></tr></table></figure>

<p>我们跟进<code>newChild()</code>它最后调用的是<code>NioEventLoopGroup</code>的<code>newChild</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> EventLoop <span class="hljs-title function_">newChild</span><span class="hljs-params">(Executor executor, Object... args)</span> t hrows Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoop</span>(<span class="hljs-built_in">this</span>, executor, (SelectorProvider) args[<span class="hljs-number">0</span>], ((SelectStrategyFactory) args[<span class="hljs-number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="hljs-number">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>newChild</code>方法最后调用了<code>NioEventLoop</code>的构造方法，<code>NioEventLoop</code>的构造方法代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,<br>             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,<br>             EventLoopTaskQueueFactory queueFactory) &#123;<br>    <span class="hljs-built_in">super</span>(parent, executor, <span class="hljs-literal">false</span>, newTaskQueue(queueFactory), newTaskQueue(queueFactory),<br>            rejectedExecutionHandler);<br>    <span class="hljs-keyword">if</span> (selectorProvider == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;selectorProvider&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (strategy == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;selectStrategy&quot;</span>);<br>    &#125;<br>    provider = selectorProvider;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectorTuple</span> <span class="hljs-variable">selectorTuple</span> <span class="hljs-operator">=</span> openSelector();<br>    selector = selectorTuple.selector;<br>    unwrappedSelector = selectorTuple.unwrappedSelector;<br>    selectStrategy = strategy;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里打开了一个<code>Selector</code>，也就是说每一个<code>NioEventLoop</code>都与一个<code>Selector</code>绑定</p>
<h3 id="初始化线程选择器"><a href="#初始化线程选择器" class="headerlink" title="初始化线程选择器"></a>初始化线程选择器</h3><p>初始化线程选择器在如下代码中完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">chooser = chooserFactory.newChooser(children);<br></code></pre></td></tr></table></figure>

<p>继续跟进newChooser方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> EventExecutorChooser <span class="hljs-title function_">newChooser</span><span class="hljs-params">(EventExecutor[] executors)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isPowerOfTwo(executors.length)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span>(executors);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericEventExecutorChooser</span>(executors);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以发现<code>Netty</code>通过判断线程个数<code>nThreads</code>是否为2的幂次方来选择<code>chooser</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 利用2的N次方法的特点，使用&amp;比求余更快</span><br>        <span class="hljs-keyword">return</span> children[childIndex.getAndIncrement() &amp; children.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用求余方式</span><br>        <span class="hljs-keyword">return</span> children[Math.abs(childIndex.getAndIncrement() % children.length)];<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>至此完成了<code>NioEventLoopGroup</code>的创建，并在<code>NioEventLoopGroup</code>创建过程中完成<code>NioEventLoop</code>初始化工作</p>
<h2 id="NioEventLoop剖析"><a href="#NioEventLoop剖析" class="headerlink" title="NioEventLoop剖析"></a>NioEventLoop剖析</h2><h3 id="NioEventLoop组成"><a href="#NioEventLoop组成" class="headerlink" title="NioEventLoop组成"></a>NioEventLoop组成</h3><p><code>NioEventLoop</code>的重要组成部分有三个：<code>Selector</code>、<code>Thread</code>、<code>TaskQueue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioEventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SingleThreadEventLoop</span> &#123;<br>    ...<br>    <span class="hljs-comment">// selector中的selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">private</span> SelectedSelectionKeySet selectedKeys;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleThreadEventExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractScheduledEventExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderedEventExecutor</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">// 线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread thread;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>Selector是在NioEventLoop的构造方法中被创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;<br>    <br>        ...<br>           <br>        <span class="hljs-comment">// 初始化selector，初始化过程在openSelector中</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SelectorTuple</span> <span class="hljs-variable">selectorTuple</span> <span class="hljs-operator">=</span> openSelector();<br>        <span class="hljs-built_in">this</span>.selector = selectorTuple.selector;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title function_">openSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处等同于 Selector.open()方法</span><br>        <span class="hljs-comment">// 创建了unwrappedSelector对象</span><br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p>
<p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">unwrappedSelector = provider.openSelector();<br></code></pre></td></tr></table></figure>

<p>获得了Selector对象<code>unwrappedSelector</code></p>
<p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectorTuple</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">final</span> Selector selector;<br><br>    SelectorTuple(Selector unwrappedSelector) &#123;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-built_in">this</span>.selector = unwrappedSelector;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 一般调用的是这个构造方法</span><br><span class="hljs-comment">    */</span><br>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-built_in">this</span>.selector = selector;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p>
<h3 id="两个Selector的区别"><a href="#两个Selector的区别" class="headerlink" title="两个Selector的区别"></a>两个Selector的区别</h3><p><code>NioEventLoop</code>中有<code>selector</code>和<code>unwrappedSelector</code>两个<code>Selector</code>，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p>
<ul>
<li><code>selector</code>中的<code>SelectedKeys</code>是<strong>基于数组</strong>的</li>
<li><code>unwrappedSelector</code>中的是<strong>基于HashSet</strong>的</li>
</ul>
<p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title function_">openSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br><br>    ...<br>    <br>    <span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectedSelectionKeySet</span> <span class="hljs-variable">selectedKeySet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySet</span>();<br><br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">maybeException</span> <span class="hljs-operator">=</span> AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span><br>                <span class="hljs-type">Field</span> <span class="hljs-variable">selectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>                <span class="hljs-type">Field</span> <span class="hljs-variable">publicSelectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br><br>                ...<br>	<br>                <span class="hljs-comment">// 暴力反射，修改私有属性</span><br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br>                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br><br>                <span class="hljs-comment">// 替换为基于数组的selectedKeys实现</span><br>                selectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    selectedKeys = selectedKeySet;<br>    <br>    <span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySetSelector</span>(unwrappedSelector, selectedKeySet));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="NioEventLoop启动"><a href="#NioEventLoop启动" class="headerlink" title="NioEventLoop启动"></a>NioEventLoop启动</h2><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;task&quot;</span>);<br>    &#125;<br>	<span class="hljs-comment">// 判断当前线程是否为NIO线程</span><br>    <span class="hljs-comment">// 判断方法为 return thread == this.thread;</span><br>    <span class="hljs-comment">// this.thread即为NIO线程，首次执行任务时，其为null</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">inEventLoop</span> <span class="hljs-operator">=</span> inEventLoop();<br>    <span class="hljs-comment">// 向任务队列taskQueue中添加任务</span><br>    addTask(task);<br>    <span class="hljs-comment">// 当前线程不是NIO线程，则进入if语句</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-comment">// 启动NIO线程的核心方法</span><br>        startThread();<br>        <span class="hljs-keyword">if</span> (isShutdown()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">reject</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (removeTask(task)) &#123;<br>                    reject = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException e) &#123;<br>                <br>            &#125;<br>            <span class="hljs-keyword">if</span> (reject) &#123;<br>                reject();<br>            &#125;<br>        &#125;<br>    &#125;<br>	<span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进入<code>startThread</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查看NIO线程状态是否为未启动</span><br>    <span class="hljs-comment">// 该if代码块只会执行一次</span><br>    <span class="hljs-comment">// state一开始的值就是ST_NOT_STARTED</span><br>    <span class="hljs-comment">// private volatile int state = ST_NOT_STARTED;</span><br>    <span class="hljs-keyword">if</span> (state == ST_NOT_STARTED) &#123;<br>        <span class="hljs-comment">// 通过CAS将状态更新为启动（ST_STARTED）</span><br>        <span class="hljs-keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行启动线程</span><br>                doStartThread();<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, ST_STARTED, ST_NOT_STARTED);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStartThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">assert</span> thread == <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 创建NIO线程并执行任务</span><br>    executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// thread即为NIO线程</span><br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行内部run方法</span><br>                SingleThreadEventExecutor.<span class="hljs-built_in">this</span>.run();<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <br>            <br>            ...<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p>
<p>该run方法是<strong>NioEvnetLoop的run方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    select(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br>                    <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                        selector.wakeup();<br>                    &#125;<br>                <span class="hljs-keyword">default</span>:<br>            &#125;<br>			...<br>            processSelectedKeys();<br>            runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>NioEventLoop</code>执行过程大致可以分为如下三个步骤</strong></p>
<ol>
<li><p>轮询检测IO事件</p>
</li>
<li><p>处理产生IO事件</p>
</li>
<li><p>处理异步任务队列</p>
</li>
</ol>
<h3 id="轮询检测IO事件"><a href="#轮询检测IO事件" class="headerlink" title="轮询检测IO事件"></a>轮询检测IO事件</h3><p>轮询检测<code>IO</code>事件在以下代码中完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">select(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br><span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>    selector.wakeup();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>wakenUp</code>表示是否应该唤醒正在阻塞的<code>select</code>操作，可以看到<code>Netty</code>在进行一次新轮询之前都会将<code>wakeUp</code>设置成<code>false</code>标志新的一轮轮询的开始。接下来我们来看一下具体的<code>select</code>操作，它可以分为以下三个部分</p>
<ol>
<li><strong>定时任务截止时间快到了，中断本次轮询</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">selectCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">currentTimeNanos</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-type">long</span> <span class="hljs-variable">selectDeadLineNanos</span> <span class="hljs-operator">=</span> currentTimeNanos + delayNanos(currentTimeNanos);<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">timeoutMillis</span> <span class="hljs-operator">=</span> (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>) / <span class="hljs-number">1000000L</span>;<br>    <span class="hljs-keyword">if</span> (timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (selectCnt == <span class="hljs-number">0</span>) &#123;<br>            selector.selectNow();<br>            selectCnt = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以看到<code>NioEventLoop</code>中<code>Reactor</code>线程的<code>select</code>操作也是一个<code>for</code>循环，在<code>for</code>循环第一步中如果发现当前的定时任务队列中有任务的截止事件快到了<code>&lt;=0.5ms</code>就跳出循环。此外跳出之前如果发现目前为止还没有进行过<code>select</code>操作那么就会调用一次<code>selectNow()</code>，该方法会立即返回不会阻塞。<code>Netty</code>里面定时任务队列是按照延迟时间从小到大进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title function_">delayNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> currentTimeNanos)</span> &#123;<br>    ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();<br>    <span class="hljs-keyword">if</span> (scheduledTask == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> SCHEDULE_PURGE_INTERVAL;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> scheduledTask.delayNanos(currentTimeNanos);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>delayNanos</code>方法取出的是第一个定时任务的延迟时间，如果没有任务默认值为1秒</p>
<ol start="2">
<li><strong>轮询过程中发现有任务加入或被唤醒，中断本次轮询</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 1.定时任务截至事时间快到了，中断本次轮询</span><br>    ...<br><br>    <span class="hljs-comment">// 2.轮询过程中发现有任务加入，中断本次轮询</span><br>    <span class="hljs-keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>        selector.selectNow();<br>        selectCnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>判断任务队列是否为空或者是否被唤醒，若不为空或被唤醒就执行一次非阻塞<code>select</code>操作，跳出循环立即返回</p>
<ol start="3">
<li><strong>阻塞式select操作</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 1.定时任务截至事时间快到了，中断本次轮询</span><br>    ...<br>    <span class="hljs-comment">// 2.轮询过程中发现有任务加入，中断本次轮询</span><br>    ...<br>    <span class="hljs-comment">// 3.阻塞式select操作</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">selectedKeys</span> <span class="hljs-operator">=</span> selector.select(timeoutMillis);<br>    selectCnt ++;<br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行到这一步说明<code>Netty</code>任务队列里面队列为空，并且所有定时任务延迟时间还未到<code>大于0.5ms</code>，于是在这里进行一次阻塞式<code>select</code>操作，截止到第一个定时任务的截止时间。如果第一个定时任务的延迟非常长(比如一个小时)那么线程有可能一直阻塞在<code>select</code>操作，但是只要在这段时间内有新任务加入该阻塞就会被释放</p>
<p>外部线程调用<code>execute</code>方法添加任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123; <br>    ...<br>    <span class="hljs-comment">// inEventLoop为false</span><br>    <span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用<code>wakeup</code>方法唤醒<code>selector</code>阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">boolean</span> inEventLoop)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>        selector.wakeup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到在外部线程添加任务的时候，会调用<code>wakeup</code>方法来唤醒<code>selector.select(timeoutMillis)</code></p>
<p>阻塞<code>select</code>操作结束之后<code>Netty</code>又做了一系列的状态判断来决定是否中断本次轮询，中断本次轮询的条件有</p>
<ul>
<li>轮询到IO事件</li>
<li>oldWakenUp参数为true</li>
<li>任务队列里面有任务hasTasks</li>
<li>第一个定时任务即将要被执行</li>
<li>用户主动唤醒 &#x3D;&gt; wakenUp.get()</li>
</ul>
<h4 id="避免JDK空轮询BUG"><a href="#避免JDK空轮询BUG" class="headerlink" title="避免JDK空轮询BUG"></a>避免JDK空轮询BUG</h4><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p>
<p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        ...<br>        <span class="hljs-comment">// 可能发生空轮询，无法阻塞NIO线程</span><br>        strategy = select(curDeadlineNanos);  <br>        ...     <br>    <br>     	<span class="hljs-keyword">if</span>(...) &#123;<br>			...<br>     	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;<br>            <span class="hljs-comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span><br>            <span class="hljs-comment">// 并将selectCnt重置为0</span><br>            selectCnt = <span class="hljs-number">0</span>;<br>        &#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p>
<p>若发生空轮询BUG，那么<code>selectCnt</code>的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">currentTimeNanos</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 1.定时任务截止事时间快到了，中断本次轮询</span><br>    ...<br>    <span class="hljs-comment">// 2.轮询过程中发现有任务加入，中断本次轮询</span><br>    ...<br>    <span class="hljs-comment">// 3.阻塞式select操作</span><br>    selector.select(timeoutMillis);<br>    <span class="hljs-comment">// 4.解决jdk的nio bug</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    <span class="hljs-keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;<br>        selectCnt = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br><br>        rebuildSelector();<br>        selector = <span class="hljs-built_in">this</span>.selector;<br>        selector.selectNow();<br>        selectCnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    currentTimeNanos = time; <br>    ...<br> &#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过<code>rebuildSelector</code>方法重建<code>selector</code>，将原<code>selector</code>的配置信息传给新<code>selector</code>，再用新<code>selector</code>覆盖旧<code>selector</code>。同时将<code>selectCnt</code>的值设置为0</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rebuildSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Selector</span> <span class="hljs-variable">oldSelector</span> <span class="hljs-operator">=</span> selector;<br>    <span class="hljs-keyword">final</span> Selector newSelector;<br>    newSelector = openSelector();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nChannels</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">for</span> (SelectionKey key: oldSelector.keys()) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> key.attachment();<br>                <span class="hljs-keyword">if</span> (!key.isValid() || key.channel().keyFor(newSelector) != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> key.interestOps();<br>                key.cancel();<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">newKey</span> <span class="hljs-operator">=</span> key.channel().register(newSelector, interestOps, a);<br>                <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>                    ((AbstractNioChannel) a).selectionKey = newKey;<br>                &#125;<br>                nChannels ++;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ConcurrentModificationException e) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    selector = newSelector;<br>    oldSelector.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>rebuildSelector</code>的操作其实很简单:<code>new</code>一个新的<code>selector</code>，将之前注册到老的<code>selector</code>上的<code>channel</code>重新转移到新的<code>selector</code>上。它是通过<code>openSelector()</code>方法创建一个新的<code>selector</code>然后执行一个死循环，只要执行过程中出现过一次并发修改<code>selectionKeys</code>异常就重新开始转移，具体的转移步骤为</p>
<ol>
<li>拿到有效的key</li>
<li>取消该key在旧的selector上的事件注册</li>
<li>将该key对应的channel注册到新的selector上</li>
<li>重新绑定channel和新的key的关系</li>
</ol>
<p>转移完成之后就可以将原有的<code>selector</code>废弃，后面所有的轮询都是在新的<code>selector</code>进行</p>
<h3 id="处理产生的IO事件"><a href="#处理产生的IO事件" class="headerlink" title="处理产生的IO事件"></a>处理产生的IO事件</h3><p>处理<code>IO</code>事件的过程是在<code>processSelectedKeys()</code>中完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKeys</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-literal">null</span>) &#123;<br>        processSelectedKeysOptimized();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的<code>selectedKeys</code>是<code>SelectedSelectionKeySet</code>对象的实例，它是在<code>NioEventLoop</code>的构造方法中调用的<code>openSelector</code>时初始化的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Selector NioEventLoop.openSelector() &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectedSelectionKeySet</span> <span class="hljs-variable">selectedKeySet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySet</span>();<br>    <span class="hljs-comment">// selectorImplClass -&gt; sun.nio.ch.SelectorImpl</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">selectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">publicSelectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br>    selectedKeysField.setAccessible(<span class="hljs-literal">true</span>);<br>    publicSelectedKeysField.setAccessible(<span class="hljs-literal">true</span>);<br>    selectedKeysField.set(selector, selectedKeySet);<br>    publicSelectedKeysField.set(selector, selectedKeySet);<br>    <span class="hljs-comment">//...</span><br>    selectedKeys = selectedKeySet;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过反射将<code>selectedKeys</code>与<code>sun.nio.ch.SelectorImpl</code>中的两个<code>field</code>绑定，这两个<code>field</code>其实是两个<code>HashSet</code>。<code>selector</code>在调用<code>select()</code>方法的时候如果有<code>IO</code>事件发生，就会往里面的两个<code>field</code>中塞相应的<code>selectionKey</code>，相当于往一个<code>hashSet</code>中<code>add</code>元素，<code>Netty</code>通过反射将<code>JDK</code>中的两个<code>field</code>替换掉，接下来我们看一下<code>Netty</code>自定义<code>SelectedSelectionKeySet</code>的<code>add</code>方法做了哪些优化？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectedSelectionKeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;SelectionKey&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> SelectionKey[] keysA;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> keysASize;<br>    <span class="hljs-keyword">private</span> SelectionKey[] keysB;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> keysBSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    SelectedSelectionKeySet() &#123;<br>        keysA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionKey</span>[<span class="hljs-number">1024</span>];<br>        keysB = keysA.clone();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(SelectionKey o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isA) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> keysASize;<br>            keysA[size ++] = o;<br>            keysASize = size;<br>            <span class="hljs-keyword">if</span> (size == keysA.length) &#123;<br>                doubleCapacityA();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> keysBSize;<br>            keysB[size ++] = o;<br>            keysBSize = size;<br>            <span class="hljs-keyword">if</span> (size == keysB.length) &#123;<br>                doubleCapacityB();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doubleCapacityA</span><span class="hljs-params">()</span> &#123;<br>        SelectionKey[] newKeysA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionKey</span>[keysA.length &lt;&lt; <span class="hljs-number">1</span>];<br>        System.arraycopy(keysA, <span class="hljs-number">0</span>, newKeysA, <span class="hljs-number">0</span>, keysASize);<br>        keysA = newKeysA;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doubleCapacityB</span><span class="hljs-params">()</span> &#123;<br>        SelectionKey[] newKeysB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionKey</span>[keysB.length &lt;&lt; <span class="hljs-number">1</span>];<br>        System.arraycopy(keysB, <span class="hljs-number">0</span>, newKeysB, <span class="hljs-number">0</span>, keysBSize);<br>        keysB = newKeysB;<br>    &#125;<br><br>    SelectionKey[] flip() &#123;<br>        <span class="hljs-keyword">if</span> (isA) &#123;<br>            isA = <span class="hljs-literal">false</span>;<br>            keysA[keysASize] = <span class="hljs-literal">null</span>;<br>            keysBSize = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> keysA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            isA = <span class="hljs-literal">true</span>;<br>            keysB[keysBSize] = <span class="hljs-literal">null</span>;<br>            keysASize = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> keysB;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isA) &#123;<br>            <span class="hljs-keyword">return</span> keysASize;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> keysBSize;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;SelectionKey&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该类继承了<code>AbstractSet</code>说明该类可以当作一个<code>set</code>来用，但是底层使用两个数组来交替使用，在<code>add</code>方法中判断当前使用哪个数组，找到对应的数组，然后经历下面三个步骤</p>
<ol>
<li>将<code>SelectionKey</code>塞到该数组的逻辑尾部</li>
<li>更新该数组的逻辑长度+1</li>
<li>如果该数组的逻辑长度等于数组的物理长度，就将该数组扩容</li>
</ol>
<p>待程序跑过一段时间，等数组的长度足够长每次在轮询到<code>NIO</code>事件的时候，<code>Netty</code>只需要<code>O(1)</code>的时间复杂度就能将<code>SelectionKey</code>塞到<code>set</code>中去，而<code>JDK</code>底层使用的<code>hashSet</code>需要<code>O(lgn)</code>的时间复杂度，接下来我们继续跟进<code>processSelectedKeysOptimized</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKeysOptimized</span><span class="hljs-params">(SelectionKey[] selectedKeys)</span> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;; i ++) &#123;<br>         <span class="hljs-comment">// 1.取出IO事件以及对应的channel</span><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> selectedKeys[i];<br>         <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>         selectedKeys[i] = <span class="hljs-literal">null</span>;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> k.attachment();<br>         <span class="hljs-comment">// 2.处理该channel</span><br>         <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>             processSelectedKey(k, (AbstractNioChannel) a);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;<br>             processSelectedKey(k, task);<br>         &#125;<br>         <span class="hljs-comment">// 3.判断是否该再来次轮询</span><br>         <span class="hljs-keyword">if</span> (needsToSelectAgain) &#123;<br>             <span class="hljs-keyword">for</span> (;;) &#123;<br>                 i++;<br>                 <span class="hljs-keyword">if</span> (selectedKeys[i] == <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-keyword">break</span>;<br>                 &#125;<br>                 selectedKeys[i] = <span class="hljs-literal">null</span>;<br>             &#125;<br>             selectAgain();<br>             selectedKeys = <span class="hljs-built_in">this</span>.selectedKeys.flip();<br>             i = -<span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里其实也能体会到优化过的<code>SelectedSelectionKeySet</code>的好处，遍历的时候遍历的是数组相对<code>JDK</code>原生的<code>HashSet</code>效率有所提高。拿到当前<code>SelectionKey</code>之后将<code>selectedKeys[i]</code>置为<code>null</code>，这里解释一下这么做的理由:想象一下这种场景假设一个<code>NioEventLoop</code>平均每次轮询出<code>N</code>个<code>IO</code>事件高峰期轮询出<code>3N</code>个事件，那么<code>selectedKeys</code>的物理长度要大于等于<code>3N</code>，如果每次处理这些<code>key</code>不设置<code>selectedKeys[i]</code>为空，高峰期一过这些存在数组尾部的<code>selectedKeys[i]</code>对应的<code>SelectionKey</code>将一直无法被回收，<code>SelectionKey</code>对应的对象可能不大，但是它的<code>attachment</code>可能很大，这样一来这些元素是<code>GC Root</code>可达的很容易造成<code>GC</code>不掉，内存泄漏就发生了</p>
<h3 id="处理异步任务队列"><a href="#处理异步任务队列" class="headerlink" title="处理异步任务队列"></a>处理异步任务队列</h3><h4 id="用户自定义普通任务"><a href="#用户自定义普通任务" class="headerlink" title="用户自定义普通任务"></a>用户自定义普通任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>我们跟进<code>execute</code>方法，看重点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    addTask(task);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>execute</code>方法调用<code>addTask</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!offerTask(task)) &#123;<br>        reject(task);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerTask</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> taskQueue.offer(task);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>跟到<code>offerTask</code>方法基本上<code>task</code>就落地了，<code>Netty</code>内部使用一个<code>taskQueue</code>将<code>task</code>保存起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue;<br><br>taskQueue = newTaskQueue(<span class="hljs-built_in">this</span>.maxPendingTasks);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Queue&lt;Runnable&gt; <span class="hljs-title function_">newTaskQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPendingTasks)</span> &#123;<br>    <span class="hljs-comment">// This event loop never calls takeTask()</span><br>    <span class="hljs-keyword">return</span> PlatformDependent.newMpscQueue(maxPendingTasks);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>taskQueue</code>在<code>SingleThreadEventExecutor</code>构造方法中被初始化，我们发现<code>taskQueue</code>在<code>NioEventLoop</code>中默认实现是<code>MPSC</code>队列(<code>MPSC</code>队列即多生产者单消费者队列)，<code>Netty</code>使用<code>MPSC</code>方便的将外部线程的<code>task</code>聚集在<code>Reactor</code>线程内部用单线程来串行执行。我们可以借鉴<code>Netty</code>的任务执行模式来处理类似多线程数据上报，定时聚合的应用。本节讨论任务场景中所有代码执行都是在<code>Reactor</code>线程中的，所以所有调用<code>inEventLoop()</code>的地方都返回<code>true</code>，既然都是在<code>reactor</code>线程中执行那么其实这里的<code>MPSC</code>队列其实没有发挥真正的作用，<code>MPSC</code>大显身手的地方其实在第二种场景</p>
<h4 id="非当前Reactor线程调用Channel的各种方法"><a href="#非当前Reactor线程调用Channel的各种方法" class="headerlink" title="非当前Reactor线程调用Channel的各种方法"></a>非当前Reactor线程调用Channel的各种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.write(...)<br></code></pre></td></tr></table></figure>

<p>它会调用<code>AbstractChannelHandlerContext</code>的<code>write</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, <span class="hljs-type">boolean</span> flush, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-keyword">if</span> (flush) &#123;<br>            next.invokeWriteAndFlush(m, promise);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.invokeWrite(m, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        AbstractWriteTask task;<br>        <span class="hljs-keyword">if</span> (flush) &#123;<br>            task = WriteAndFlushTask.newInstance(next, m, promise);<br>        &#125;  <span class="hljs-keyword">else</span> &#123;<br>            task = WriteTask.newInstance(next, m, promise);<br>        &#125;<br>        safeExecute(executor, task, promise, m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>外部线程在调用<code>write</code>的时候<code>executor.inEventLoop()</code>会返回<code>false</code>，直接进入到<code>else</code>分支将<code>write</code>封装成一个<code>WriteTask</code>(这里仅仅是<code>write</code>而没有<code>flush</code>因此<code>flush</code>参数为<code>false</code>）, 然后调用<code>safeExecute</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">safeExecute</span><span class="hljs-params">(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    executor.execute(runnable);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来的调用链就进入到第一种场景了，但是和第一种场景有个明显的区别就是，第一种场景的调用链的发起线程是<code>Reactor</code>线程，第二种场景的调用链的发起线程是用户线程，用户线程可能会有很多个。显然多个线程并发写<code>taskQueue</code>可能出现线程同步问题，于是这种场景下<code>Netty</code>的<code>MPSC</code>就有了用武之地</p>
<h4 id="用户自定义定时任务"><a href="#用户自定义定时任务" class="headerlink" title="用户自定义定时任务"></a>用户自定义定时任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>

<p>第三种场景就是定时任务逻辑了，用的最多的便是如上方法:在一定时间之后执行任务，我们跟进<code>schedule</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(<span class="hljs-built_in">this</span>, command, <span class="hljs-literal">null</span>, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>ScheduledFutureTask</code>将用户自定义任务再次包装成一个<code>Netty</code>内部的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (inEventLoop()) &#123;<br>        scheduledTaskQueue().add(task);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                scheduledTaskQueue().add(task);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在执行定时任务前<code>Netty</code>会先判断当前是否在内部线程进行调用，如果是在内部线程则直接将任务添加进队列，如果是在外部线程调用<code>schedule</code>，<code>Netty</code>将添加定时任务的逻辑封装成一个普通的<code>task</code>，这个<code>task</code>的任务是添加[添加定时任务]的任务而不是添加定时任务，其实也就是第二种场景这样对<code>PriorityQueue</code>的访问就变成单线程即只有<code>Reactor</code>线程，确保线程安全</p>
<p><code>scheduledTaskQueue()</code>方法会返回一个优先级队列，然后调用<code>add</code>方法将定时任务加入到队列中去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() &#123;<br>    <span class="hljs-keyword">if</span> (scheduledTaskQueue == <span class="hljs-literal">null</span>) &#123;<br>        scheduledTaskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;ScheduledFutureTask&lt;?&gt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">return</span> scheduledTaskQueue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们分析一下优先级队列中定时任务的比较规则，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    ScheduledFutureTask&lt;?&gt; that = (ScheduledFutureTask&lt;?&gt;) o;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> deadlineNanos() - that.deadlineNanos();<br>    <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id &lt; that.id) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id == that.id) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两个定时任务的比较是先比较任务的截止时间，截止时间相同的情况下再比较<code>ID</code>(即任务添加的顺序)，若<code>ID</code>再相同抛异常，这样在执行定时任务的时候就能保证最近截止时间的任务先执行。下面我们再来看下<code>Netty</code>是如何来保证各种定时任务的执行的，<code>Netty</code>里面的定时任务分以下三种</p>
<ol>
<li>若干时间后执行一次</li>
<li>每隔一段时间执行一次</li>
<li>每次执行结束，隔一定时间再执行一次</li>
</ol>
<h4 id="任务的调度"><a href="#任务的调度" class="headerlink" title="任务的调度"></a>任务的调度</h4><p>在了解了Netty内部的任务添加机制后，我们回到处理异步任务队列方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">runAllTasks(<span class="hljs-type">long</span> timeoutNanos);<br></code></pre></td></tr></table></figure>

<p>这行代码表示了尽量在一定的时间内将所有的任务都取出来<code>run</code>一遍，<code>timeoutNanos</code>表示该方法最多执行这么长时间(这里有个<code>ioRatio</code>的变量意思是<code>IO</code>任务所占的比重(默认是<code>50</code>)，也就是说<code>IO</code>任务和非<code>IO</code>任务所分配的时间是<code>1:1</code>)。因为如果<code>Reactor</code>线程在此停留的时间过长，那么将积攒许多的<code>IO</code>事件无法处理最终导致大量客户端请求阻塞，因此默认情况下<code>Netty</code>将控制内部队列的执行时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAllTasks</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutNanos)</span> &#123;<br>    fetchFromScheduledTaskQueue();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> pollTask();<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> ScheduledFutureTask.nanoTime() + timeoutNanos;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">runTasks</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> lastExecutionTime;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        safeExecute(task);<br>        runTasks ++;<br>        <span class="hljs-keyword">if</span> ((runTasks &amp; <span class="hljs-number">0x3F</span>) == <span class="hljs-number">0</span>) &#123;<br>            lastExecutionTime = ScheduledFutureTask.nanoTime();<br>            <span class="hljs-keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        task = pollTask();<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>            lastExecutionTime = ScheduledFutureTask.nanoTime();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    afterRunningAllTasks();<br>    <span class="hljs-built_in">this</span>.lastExecutionTime = lastExecutionTime;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码便是Reactor执行task的所有逻辑，可以拆解成下面几个步骤</p>
<ol>
<li>从<code>scheduledTaskQueue</code>转移定时任务到<code>taskQueue(mpsc queue)</code></li>
<li>计算本次任务循环的截止时间</li>
<li>执行任务</li>
<li>收尾</li>
</ol>
<p><strong>从<code>scheduledTaskQueue</code>转移定时任务到<code>taskQueue(mpsc queue)</code></strong></p>
<p>首先调用<code>fetchFromScheduledTaskQueue()</code>方法，将到期的定时任务转移到<code>mpsc queue</code>里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">fetchFromScheduledTaskQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanoTime</span> <span class="hljs-operator">=</span> AbstractScheduledEventExecutor.nanoTime();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">scheduledTask</span>  <span class="hljs-operator">=</span> pollScheduledTask(nanoTime);<br>    <span class="hljs-keyword">while</span> (scheduledTask != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!taskQueue.offer(scheduledTask)) &#123;<br>            <span class="hljs-comment">// No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.</span><br>            scheduledTaskQueue().add((ScheduledFutureTask&lt;?&gt;) scheduledTask);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        scheduledTask  = pollScheduledTask(nanoTime);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>NioEventLoop</code>会维护两个任务队列(一个定时任务队列一个正常任务队列)，这里的逻辑就是把定时任务队列中已经到执行时间的任务取出来放到正常的任务队列中去，来看下<code>pollScheduledTask</code>这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Runnable <span class="hljs-title function_">pollScheduledTask</span><span class="hljs-params">(<span class="hljs-type">long</span> nanoTime)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-title function_">inEventLoop</span><span class="hljs-params">()</span>;<br><br>    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="hljs-built_in">this</span>.scheduledTaskQueue;<br>    ScheduledFutureTask&lt;?&gt; scheduledTask = scheduledTaskQueue == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : scheduledTaskQueue.peek();<br>    <span class="hljs-keyword">if</span> (scheduledTask == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (scheduledTask.deadlineNanos() &lt;= nanoTime) &#123;<br>        scheduledTaskQueue.remove();<br>        <span class="hljs-keyword">return</span> scheduledTask;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到每次<code>pollScheduledTask</code>的时候，只有在当前任务的截止时间已经到了才会取出来</p>
<p><strong>计算本次任务循环的截止时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> pollTask();<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> ScheduledFutureTask.nanoTime() + timeoutNanos;<br><span class="hljs-type">long</span> <span class="hljs-variable">runTasks</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> lastExecutionTime;<br></code></pre></td></tr></table></figure>

<p>这一步将取出第一个任务用<code>Reactor</code>线程传入的超时时间<code>timeoutNanos</code>来计算出当前任务循环<code>deadline</code>，并且使用<code>runTasks</code>，<code>lastExecutionTime</code>来时刻记录任务的状态</p>
<p><strong>循环执行任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    safeExecute(task);<br>    runTasks ++;<br>    <span class="hljs-keyword">if</span> ((runTasks &amp; <span class="hljs-number">0x3F</span>) == <span class="hljs-number">0</span>) &#123;<br>        lastExecutionTime = ScheduledFutureTask.nanoTime();<br>        <span class="hljs-keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    task = pollTask();<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>        lastExecutionTime = ScheduledFutureTask.nanoTime();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这一步便是<code>Netty</code>里面执行所有任务的核心代码了。首先调用<code>safeExecute</code>来确保任务安全执行忽略任何异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">safeExecute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        task.run();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.warn(<span class="hljs-string">&quot;A task raised an exception. Task: &#123;&#125;&quot;</span>, task, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后将已运行任务<code>runTasks</code>加一，每隔<code>0x3F</code>任务(每执行完<code>64</code>个任务)判断当前时间是否超过本次<code>reactor</code>任务循环的截止时间了，如果超过那就<code>break</code>掉，如果没有超过那就继续执行。可以看到<code>Netty</code>对性能的优化考虑地相当的周到，假设<code>Netty</code>任务队列里面如果有海量小任务，如果每次都要执行完任务都要判断一下是否到截止时间，那么效率是比较低下的</p>
<p><strong>收尾</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">afterRunningAllTasks();<br><span class="hljs-built_in">this</span>.lastExecutionTime = lastExecutionTime;<br></code></pre></td></tr></table></figure>

<p>收尾工作很简单，调用一下<code>afterRunningAllTasks</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterRunningAllTasks</span><span class="hljs-params">()</span> &#123;<br>    runAllTasksFrom(tailTasks);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>NioEventLoop</code>可以通过父类<code>SingleThreadEventLoop</code>的<code>executeAfterEventLoopIteration</code>方法向<code>tailTasks</code>中添加收尾任务，比如你想统计一下一次执行一次任务循环花了多长时间就可以调用此方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeAfterEventLoopIteration</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!tailTasks.offer(task)) &#123;<br>        reject(task);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Netty/">Netty</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Netty/">Netty</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/15/Netty%E6%BA%90%E7%A0%81(%E4%B8%89)-%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Netty源码(三)-新连接接入</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/08/Netty%E6%BA%90%E7%A0%81(%E4%B8%80)-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8/">
                        <span class="hidden-mobile">Netty源码(一)-服务端启动</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
