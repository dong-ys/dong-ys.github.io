<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kafka源码解析-日志段读写数据的流程</title>
    <link href="/2022/08/29/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%97%A5%E5%BF%97%E6%AE%B5%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/08/29/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%97%A5%E5%BF%97%E6%AE%B5%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka源码解析-日志段读写数据的流程"><a href="#Kafka源码解析-日志段读写数据的流程" class="headerlink" title="Kafka源码解析-日志段读写数据的流程"></a>Kafka源码解析-日志段读写数据的流程</h1><h2 id="Kafka日志结构概述"><a href="#Kafka日志结构概述" class="headerlink" title="Kafka日志结构概述"></a>Kafka日志结构概述</h2><p>Kafka 服务端的存储模块，包括涉及到的各种组件、存储流程和一些核心概念等。日志段及其相关代码是 Kafka 存储模块中最为重要的组件代码之一。首先了解一下服务端存储模块的大致结构：</p><img src="/2022/08/29/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%97%A5%E5%BF%97%E6%AE%B5%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/modb_20211012_1c519c84-2b3f-11ec-94a3-fa163eb4f6be.png" class="" title="modb_20211012_1c519c84-2b3f-11ec-94a3-fa163eb4f6be"><p>在 Kafka 中，Topic实际上只是一个逻辑概念，并没有物理结构，真正具有物理结构的是Partition分区，每个分区对应一个Log日志对象。</p><p>一个Log日志又划分成多个日志段LogSegment，日志段是真正进行数据读写的对象，每个日志段包含一组文件：.log数据文件、.index偏移量索引文件、.timeindex时间戳索引文件以及已中止（Aborted）事务的索引文件（.txnindex）</p><p>比如你创建了一个双分区的主题 test-topic，那么，Kafka 在磁盘上会创建两个子目录：test-topic-0 和 test-topic-1。而在服务器端，这就是两个 Log 对象。每个子目录下存在多组日志段，也就是多组.log、.index、.timeindex 文件组合，只不过文件名不同，因为每个日志段的起始位移不同。</p><h2 id="日志段对象分析"><a href="#日志段对象分析" class="headerlink" title="日志段对象分析"></a>日志段对象分析</h2><p>日志段源码位于 Kafka 的 core 工程下，具体文件位置是core&#x2F;src&#x2F;main&#x2F;scala&#x2F;kafka&#x2F;log&#x2F;LogSegment.scala。所有日志结构部分的源码都在 core 的 kafka.log 包下。</p><p>该文件下定义了三个 Scala 对象：</p><ul><li>LogSegment class</li><li>LogSegment object</li><li>LogFlushStats object：统计作用，主要负责为日志落盘进行计时</li></ul><p>其中比较关键的是 <strong>LogSegment class 和 object</strong>。在 Scala 语言里，在一个源代码文件中同时定义相同名字的 class 和 object 的用法被称为伴生（Companion）。Class 对象被称为伴生类，它和 Java 中的类是一样的；而 Object 对象是一个单例对象，用于保存一些静态变量或静态方法。如果用 Java 来做类比的话，我们必须要编写两个类才能实现，这两个类也就是 LogSegment 和 LogSegmentUtils。</p><p>引用源码中的注释：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">A <span class="hljs-keyword">segment</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">log</span>. Each <span class="hljs-keyword">segment</span> has <span class="hljs-literal">two</span> components: <span class="hljs-keyword">a</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">an</span> index. The<br><span class="hljs-built_in">log</span> is <span class="hljs-keyword">a</span> FileRecords containing <span class="hljs-keyword">the</span> actual messages. The index is <span class="hljs-keyword">an</span> OffsetIndex<br>that maps <span class="hljs-built_in">from</span> logical offsets <span class="hljs-built_in">to</span> physical <span class="hljs-built_in">file</span> positions. Each <span class="hljs-keyword">segment</span> has <span class="hljs-keyword">a</span> base<br><span class="hljs-built_in">offset</span> which is <span class="hljs-keyword">an</span> <span class="hljs-built_in">offset</span> &lt;= <span class="hljs-keyword">the</span> least <span class="hljs-built_in">offset</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">any</span> message <span class="hljs-keyword">in</span> this <span class="hljs-keyword">segment</span> <span class="hljs-keyword">and</span> &gt;<br><span class="hljs-keyword">any</span> <span class="hljs-built_in">offset</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">any</span> previous <span class="hljs-keyword">segment</span>.<br></code></pre></td></tr></table></figure><p>每个日志段由两个核心组件构成：日志和索引。日志存储实际数据（消息日志），索引存储逻辑位移和文件中实际位置的映射关系。</p><p>每个日志段都有一个起始位移值（base offset），前面日志段的所有位移值 &lt; base offset &lt;&#x3D; 此日志段中的所有位移值</p><p>接下来看下 LogSegment 的声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogSegment</span> <span class="hljs-title">private</span>[log] (<span class="hljs-params">val log: <span class="hljs-type">FileRecords</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">                               val lazyOffsetIndex: <span class="hljs-type">LazyIndex</span>[<span class="hljs-type">OffsetIndex</span>],</span></span><br><span class="hljs-params"><span class="hljs-class">                               val lazyTimeIndex: <span class="hljs-type">LazyIndex</span>[<span class="hljs-type">TimeIndex</span>],</span></span><br><span class="hljs-params"><span class="hljs-class">                               val txnIndex: <span class="hljs-type">TransactionIndex</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">                               val baseOffset: <span class="hljs-type">Long</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">                               val indexIntervalBytes: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">                               val rollJitterMs: <span class="hljs-type">Long</span>,</span></span><br><span class="hljs-params"><span class="hljs-class">                               val time: <span class="hljs-type">Time</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Logging</span></span><br></code></pre></td></tr></table></figure><p>一个日志段包含<strong>消息日志文件</strong>、<strong>位移索引文件</strong>、<strong>时间戳索引文件</strong>、<strong>已中止</strong>事务索引文件等。这里的 FileRecords 就是实际保存 Kafka 消息的对象，这里不深入探究。</p><p>下面的 lazyOffsetIndex、lazyTimeIndex 和 txnIndex 分别对应于刚才所说的 3 个索引文件。不过，在实现方式上，前两种使用了延迟初始化的原理，降低了初始化时间成本。</p><p>每个日志段对象保存自己的起始位移 <strong>baseOffset</strong>，磁盘文件上的文件名就是该值，每个LogSegment对象实例一旦被创建，它的起始位移就是固定的了，不能再被修改。</p><p>indexIntervalBytes 其实就是 Broker 端参数 <code>log.index.interval.bytes</code> 的值，它控制了<strong>日志段对象新增索引项的频率</strong>。默认情况下，日志段至少新写入 4KB 的消息数据才会新增一条索引项。而 rollJitterMs 是日志段对象新增倒计时的“扰动值”。因为目前 Broker 端日志段新增倒计时是全局设置的，也就是说，如果在某个时刻可能同时创建多个日志段对象，将极大地增加物理磁盘 I&#x2F;O 压力，而有了 rollJitterMs 值的扰动，每个新增日志段就不会同时在一个时刻进行创建，可以有效缓解 I&#x2F;O 负载瓶颈，这种思路同样可以应用于解决缓存雪崩。</p><p>最后的 time 参数，它就是用于统计计时的一个实现类，并不关键。</p><h2 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h2><p>对于一个日志段而言，最重要的方法就是写入消息和读取消息了，它们分别对应着源码中的 append 方法和 read 方法。</p><p>图示说明：</p><img src="/2022/08/29/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%97%A5%E5%BF%97%E6%AE%B5%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/modb_20211012_1cb92714-2b3f-11ec-94a3-fa163eb4f6be.png" class="" title="modb_20211012_1cb92714-2b3f-11ec-94a3-fa163eb4f6be"><p>append 方法解析：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span></span>(largestOffset: <span class="hljs-type">Long</span>, <span class="hljs-comment">//待写入消息集合的最大偏移量</span><br>           largestTimestamp: <span class="hljs-type">Long</span>, <span class="hljs-comment">//待写入消息集合待最大时间戳</span><br>           shallowOffsetOfMaxTimestamp: <span class="hljs-type">Long</span>, <span class="hljs-comment">//最大时间戳对应的数据偏移量</span><br>           records: <span class="hljs-type">MemoryRecords</span> <span class="hljs-comment">//待写入消息集合</span><br>          ): <span class="hljs-type">Unit</span> = &#123;<br>  <span class="hljs-keyword">if</span> (records.sizeInBytes &gt; <span class="hljs-number">0</span>) &#123;<br>    trace(<span class="hljs-string">s&quot;Inserting <span class="hljs-subst">$&#123;records.sizeInBytes&#125;</span> bytes at end offset <span class="hljs-subst">$largestOffset</span> at position <span class="hljs-subst">$&#123;log.sizeInBytes&#125;</span> &quot;</span> +<br>          <span class="hljs-string">s&quot;with largest timestamp <span class="hljs-subst">$largestTimestamp</span> at shallow offset <span class="hljs-subst">$shallowOffsetOfMaxTimestamp</span>&quot;</span>)<br>    <span class="hljs-keyword">val</span> physicalPosition = log.sizeInBytes()<br>    <span class="hljs-comment">// 判断该日志段是否为空，如果是空的话， 记录要写入消息集合的最大时间戳，并将其作为后面新增日志段倒计时的依据</span><br>    <span class="hljs-keyword">if</span> (physicalPosition == <span class="hljs-number">0</span>)<br>      rollingBasedTimestamp = <span class="hljs-type">Some</span>(largestTimestamp)<br>    <span class="hljs-comment">// 确保输入参数最大位移值是合法的</span><br>    <span class="hljs-comment">// 判断largestOffset - baseOffset 的值是不是 介于 [0，Int.MAXVALUE] 之间</span><br>    ensureOffsetInRange(largestOffset)<br><br>    <span class="hljs-comment">// append the messages</span><br>    <span class="hljs-comment">// 将内存中的消息对象写入到操作系统的页缓存</span><br>    <span class="hljs-keyword">val</span> appendedBytes = log.append(records)<br>    trace(<span class="hljs-string">s&quot;Appended <span class="hljs-subst">$appendedBytes</span> to <span class="hljs-subst">$&#123;log.file&#125;</span> at end offset <span class="hljs-subst">$largestOffset</span>&quot;</span>)<br>    <span class="hljs-comment">// Update the in memory max timestamp and corresponding offset.</span><br>    <span class="hljs-comment">// 更新日志段的最大时间戳以及最大时间戳所属消息的位移值属性</span><br>    <span class="hljs-keyword">if</span> (largestTimestamp &gt; maxTimestampSoFar) &#123;<br>      maxTimestampSoFar = largestTimestamp<br>      offsetOfMaxTimestampSoFar = shallowOffsetOfMaxTimestamp<br>    &#125;<br>    <span class="hljs-comment">// append an entry to the index (if needed)</span><br>    <span class="hljs-comment">// 更新索引项和写入的字节数</span><br>    <span class="hljs-keyword">if</span> (bytesSinceLastIndexEntry &gt; indexIntervalBytes) &#123;<br>      offsetIndex.append(largestOffset, physicalPosition)<br>      timeIndex.maybeAppend(maxTimestampSoFar, offsetOfMaxTimestampSoFar)<br>      bytesSinceLastIndexEntry = <span class="hljs-number">0</span><br>    &#125;<br>    bytesSinceLastIndexEntry += records.sizeInBytes<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一步一步具体分析步骤：</p><ol><li><p>判断待写入消息的字节数是否大于0，如果小于等于0，说明消息已经写完，直接结束append方法。</p></li><li><p>然后调用 log.sizeInBytes 方法判断该日志段是否为空，如果是空的话， Kafka 需要记录要写入消息集合的最大时间戳，并将其作为后面新增日志段倒计时的依据。</p></li><li><p>判断代写入消息的最大位移值是否合法，标准就是看它与日志段起始位移的差值是否在整数范围内，即 largestOffset - baseOffset 的值是不是 介于 [0，Int.MAXVALUE] 之间。在极个别的情况下，这个差值可能会越界，这时 append 方法就会抛出异常，阻止后续的消息写入。</p></li><li><p>接下来调用 FileRecords 的 append 方法执行真正的写入。</p></li><li><p>再下一步，就是更新日志段的最大时间戳以及最大时间戳所属消息的位移值属性。每个日志段都要保存当前最大时间戳信息和所属消息的位移信息。当前最大时间戳的值就是 Broker 定时删除日志功能的依据，而最大时间戳对应的消息的位移值则用于更新时间戳索引项。</p></li><li><p>append 方法的最后一步就是更新索引项和写入的字节数了。日志段每写入4KB 数据就要写入一个索引项，因此当已写入字节数超过了 4KB 之后，append 方法会调用索引对象的 append 方法新增索引项，同时清空已写入字节数，以备下次重新累积计算。</p></li></ol><h2 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h2><p>图示说明：</p><img src="/2022/08/29/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%97%A5%E5%BF%97%E6%AE%B5%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/modb_20211012_1d2336ea-2b3f-11ec-94a3-fa163eb4f6be.png" class="" title="img"><p>read 方法解析：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span></span>(startOffset: <span class="hljs-type">Long</span>, <span class="hljs-comment">// 要读取的第一条消息的位移</span><br>         maxSize: <span class="hljs-type">Int</span>, <span class="hljs-comment">// 能读取的最大字节数</span><br>         maxPosition: <span class="hljs-type">Long</span> = size, <span class="hljs-comment">// 能读到的最大文件位置</span><br>         minOneMessage: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">// 在消息体过大时，是否最少返回一条消息</span><br>        ): <span class="hljs-type">FetchDataInfo</span> = &#123;<br>  <span class="hljs-keyword">if</span> (maxSize &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">s&quot;Invalid max size <span class="hljs-subst">$maxSize</span> for log read from segment <span class="hljs-subst">$log</span>&quot;</span>)<br><br>  <span class="hljs-comment">// 获取对应的物理文件位置和文件大小</span><br>  <span class="hljs-keyword">val</span> startOffsetAndSize = translateOffset(startOffset)<br><br>  <span class="hljs-comment">// if the start position is already off the end of the log, return null</span><br>  <span class="hljs-keyword">if</span> (startOffsetAndSize == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>  <span class="hljs-keyword">val</span> startPosition = startOffsetAndSize.position<br>  <span class="hljs-keyword">val</span> offsetMetadata = <span class="hljs-type">LogOffsetMetadata</span>(startOffset, <span class="hljs-keyword">this</span>.baseOffset, startPosition)<br><br>  <span class="hljs-keyword">val</span> adjustedMaxSize =<br>    <span class="hljs-keyword">if</span> (minOneMessage) math.max(maxSize, startOffsetAndSize.size)<br>    <span class="hljs-keyword">else</span> maxSize<br><br>  <span class="hljs-comment">// return a log segment but with zero size in the case below</span><br>  <span class="hljs-keyword">if</span> (adjustedMaxSize == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">FetchDataInfo</span>(offsetMetadata, <span class="hljs-type">MemoryRecords</span>.<span class="hljs-type">EMPTY</span>)<br><br>  <span class="hljs-comment">// calculate the length of the message set to read based on whether or not they gave us a maxOffset</span><br>  <span class="hljs-comment">// 计算要读取的总字节数</span><br>  <span class="hljs-keyword">val</span> fetchSize: <span class="hljs-type">Int</span> = min((maxPosition - startPosition).toInt, adjustedMaxSize)<br><br>  <span class="hljs-comment">// 从指定位置读取指定大小的消息集合</span><br>  <span class="hljs-type">FetchDataInfo</span>(offsetMetadata, log.slice(startPosition, fetchSize),<br>    firstEntryIncomplete = adjustedMaxSize &lt; startOffsetAndSize.size)<br>&#125;<br></code></pre></td></tr></table></figure><p>当 minOneMessage 这个参数为 true 时，即使出现消息体字节数超过了 maxSize 的情形，read 方法依然能返回至少一条消息。引入这个参数主要是为了确保不出现消费饿死的情况。</p><p>主要逻辑如下：</p><ol><li><p>根据起始位移值定位到要读取的起始文件位置，startOffset仅仅是位移值，需要通过索引定位到物理地址。</p></li><li><p>待确定了读取起始位置，日志段代码需要根据这部分信息以及 maxSize 和 maxPosition 参数共同计算要读取的总字节数。假设 maxSize&#x3D;100，maxPosition&#x3D;300，startPosition&#x3D;250，那么 read 方法只能读取 50 字节，因为 maxPosition - startPosition &#x3D; 50。我们把它和 maxSize 参数相比较，其中的最小值就是最终能够读取的总字节数。</p></li><li><p>最后一步是调用 FileRecords 的 slice 方法，从指定位置读取指定大小的消息集合，并封装成 FetchDataInfo 对象返回。</p></li></ol><h2 id="恢复日志段"><a href="#恢复日志段" class="headerlink" title="恢复日志段"></a>恢复日志段</h2><p>除了 append 和 read 方法，LogSegment 还有一个重要的方法，就是 recover 方法，用于<strong>恢复日志段</strong>。</p><p>图示说明：</p><img src="/2022/08/29/Kafka%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%97%A5%E5%BF%97%E6%AE%B5%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/modb_20211012_1d7fe70a-2b3f-11ec-94a3-fa163eb4f6be.png" class="" title="img"><p>下面的代码是 recover 方法源码。恢复日志段其实就是， Broker 在启动时会从磁盘上加载所有日志段信息到内存中，并创建相应的 LogSegment 对象实例。在这个过程中，它需要执行一系列的操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recover</span></span>(producerStateManager: <span class="hljs-type">ProducerStateManager</span>, leaderEpochCache: <span class="hljs-type">Option</span>[<span class="hljs-type">LeaderEpochFileCache</span>] = <span class="hljs-type">None</span>): <span class="hljs-type">Int</span> = &#123;<br>  <span class="hljs-comment">// 清空所有索引信息</span><br>  offsetIndex.reset()<br>  timeIndex.reset()<br>  txnIndex.reset()<br>  <span class="hljs-keyword">var</span> validBytes = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">var</span> lastIndexEntry = <span class="hljs-number">0</span><br>  maxTimestampSoFar = <span class="hljs-type">RecordBatch</span>.<span class="hljs-type">NO_TIMESTAMP</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (batch &lt;- log.batches.asScala) &#123;<br>      batch.ensureValid()<br>      ensureOffsetInRange(batch.lastOffset)<br><br>      <span class="hljs-comment">// The max timestamp is exposed at the batch level, so no need to iterate the records</span><br>      <span class="hljs-comment">// 保存最大时间戳和所属消息位移</span><br>      <span class="hljs-keyword">if</span> (batch.maxTimestamp &gt; maxTimestampSoFar) &#123;<br>        maxTimestampSoFar = batch.maxTimestamp<br>        offsetOfMaxTimestampSoFar = batch.lastOffset<br>      &#125;<br><br>      <span class="hljs-comment">// Build offset index</span><br>      <span class="hljs-comment">// 更新索引项</span><br>      <span class="hljs-keyword">if</span> (validBytes - lastIndexEntry &gt; indexIntervalBytes) &#123;<br>        offsetIndex.append(batch.lastOffset, validBytes)<br>        timeIndex.maybeAppend(maxTimestampSoFar, offsetOfMaxTimestampSoFar)<br>        lastIndexEntry = validBytes<br>      &#125;<br>      <span class="hljs-comment">// 更新总消息字节数</span><br>      validBytes += batch.sizeInBytes()<br><br>      <span class="hljs-comment">// 更新事务Producer状态和Leader Epoch缓存</span><br>      <span class="hljs-keyword">if</span> (batch.magic &gt;= <span class="hljs-type">RecordBatch</span>.<span class="hljs-type">MAGIC_VALUE_V2</span>) &#123;<br>        leaderEpochCache.foreach &#123; cache =&gt;<br>          <span class="hljs-keyword">if</span> (batch.partitionLeaderEpoch &gt;= <span class="hljs-number">0</span> &amp;&amp; cache.latestEpoch.forall(batch.partitionLeaderEpoch &gt; _))<br>            cache.assign(batch.partitionLeaderEpoch, batch.baseOffset)<br>        &#125;<br>        updateProducerState(producerStateManager, batch)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> e@ (_: <span class="hljs-type">CorruptRecordException</span> | _: <span class="hljs-type">InvalidRecordException</span>) =&gt;<br>      warn(<span class="hljs-string">&quot;Found invalid messages in log segment %s at byte offset %d: %s. %s&quot;</span><br>        .format(log.file.getAbsolutePath, validBytes, e.getMessage, e.getCause))<br>  &#125;<br>  <span class="hljs-keyword">val</span> truncated = log.sizeInBytes - validBytes<br>  <span class="hljs-keyword">if</span> (truncated &gt; <span class="hljs-number">0</span>)<br>    debug(<span class="hljs-string">s&quot;Truncated <span class="hljs-subst">$truncated</span> invalid bytes at the end of segment <span class="hljs-subst">$&#123;log.file.getAbsoluteFile&#125;</span> during recovery&quot;</span>)<br><br>  <span class="hljs-comment">// 日志段大小调整和索引文件截断</span><br>  log.truncateTo(validBytes)<br>  offsetIndex.trimToValidSize()<br>  <span class="hljs-comment">// A normally closed segment always appends the biggest timestamp ever seen into log segment, we do this as well.</span><br>  timeIndex.maybeAppend(maxTimestampSoFar, offsetOfMaxTimestampSoFar, skipFullCheck = <span class="hljs-literal">true</span>)<br>  timeIndex.trimToValidSize()<br>  truncated<br>&#125;<br></code></pre></td></tr></table></figure><p>主要步骤如下：</p><ol><li><p>recover 开始时，会依次调用索引文件的 reset 方法，清空所有的索引文件</p></li><li><p>之后开始遍历日志段中的所有消息集合或消息批次（RecordBatch）。对于读取到的每个消息集合，日志段必须要确保它们是合法的，主要根据两方面判断：</p><ul><li>batch.ensureValid()，该集合中的消息必须要符合 Kafka 定义的二进制格式</li><li>ensureOffsetInRange(batch.lastOffset)，该集合中最后一条消息的位移值不能越界，即它与日志段起始位移的差值必须是一个正整数值</li></ul></li><li><p>校验完消息集合之后，代码会更新遍历过程中观测到的最大时间戳以及所属消息的位移值。同样，这两个数据用于后续构建索引项。</p></li><li><p>再之后就是不断累加当前已读取的消息字节数，并根据该值有条件地写入索引项。</p></li><li><p>最后是更新事务型 Producer 的状态以及 Leader Epoch 缓存。</p></li><li><p>遍历执行完成后，Kafka 会将日志段当前总字节数和刚刚累加的已读取字节数进行比较，如果发现前者比后者大，说明日志段写入了一些非法消息，需要执行截断操作，将日志段大小调整回合法的数值。同时， Kafka 还必须相应地调整索引文件的大小。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-DashBoard</title>
    <link href="/2021/08/24/Kubernetes-DashBoard/"/>
    <url>/2021/08/24/Kubernetes-DashBoard/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-DashBoard"><a href="#Kubernetes-DashBoard" class="headerlink" title="Kubernetes-DashBoard"></a>Kubernetes-DashBoard</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>之前在kubernetes中完成的所有操作都是通过命令行工具kubectl完成的。其实，为了提供更丰富的用户体验，kubernetes还开发了一个基于web的用户界面（Dashboard）。用户可以使用Dashboard部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理kubernetes中各种资源。</p><h2 id="2-部署Dashboard"><a href="#2-部署Dashboard" class="headerlink" title="2. 部署Dashboard"></a>2. 部署Dashboard</h2><h3 id="2-1-下载yaml，并运行Dashboard"><a href="#2-1-下载yaml，并运行Dashboard" class="headerlink" title="2.1 下载yaml，并运行Dashboard"></a>2.1 下载yaml，并运行Dashboard</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载yaml</span><br>[root@master ~]# wget  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改kubernetes-dashboard的Service类型</span><br>kind: Service<br>apiVersion: v1<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>  namespace: kubernetes-dashboard<br>spec:<br>  type: NodePort  # 新增<br>  ports:<br>    - port: 443<br>      targetPort: 8443<br>      nodePort: 30009  # 新增<br>  selector:<br>    k8s-app: kubernetes-dashboard<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">部署</span><br>[root@master ~]# kubectl create -f recommended.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看namespace下的kubernetes-dashboard下的资源</span><br>[root@master ~]# kubectl get pod,svc -n kubernetes-dashboard <br>NAME                                             READY   STATUS    RESTARTS   AGE<br>pod/dashboard-metrics-scraper-6b4884c9d5-vl5bv   1/1     Running   0          2m9s<br>pod/kubernetes-dashboard-7b544877d5-pjmnt        1/1     Running   0          2m10s<br><br>NAME                                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE<br>service/dashboard-metrics-scraper   ClusterIP   10.111.19.242    &lt;none&gt;        8000/TCP        2m10s<br>service/kubernetes-dashboard        NodePort    10.110.251.117   &lt;none&gt;        443:30009/TCP   2m10s<br></code></pre></td></tr></table></figure><h3 id="2-2-创建账号，获取token"><a href="#2-2-创建账号，获取token" class="headerlink" title="2.2 创建账号，获取token"></a>2.2 创建账号，获取token</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建账号</span><br>[root@master ~]# kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard<br>serviceaccount/dashboard-admin created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">授权</span><br>[root@master ~]# kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin<br>clusterrolebinding.rbac.authorization.k8s.io/dashboard-admin-rb created<br>[root@master ~]# kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin<br>dashboard-admin-token-f4nwv        kubernetes.io/service-account-token   3      15s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取账号token</span><br>[root@master ~]# kubectl describe secrets dashboard-admin-token-f4nwv -n kubernetes-dashboard      <br>Name:         dashboard-admin-token-f4nwv<br>Namespace:    kubernetes-dashboard<br>Labels:       &lt;none&gt;<br>Annotations:  kubernetes.io/service-account.name: dashboard-admin<br>              kubernetes.io/service-account.uid: 65db1dda-b51b-4b05-abfc-c7e18fdd7eb4<br><br>Type:  kubernetes.io/service-account-token<br><br>Data<br>====<br>ca.crt:     1025 bytes<br>namespace:  20 bytes<br>token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IjZBcG5aUHdIWDNBRDhxSWdLbzg2Ynh6eEFsN1pqVllrV0dwMnZ4c2lDU28ifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tZjRud3YiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiNjVkYjFkZGEtYjUxYi00YjA1LWFiZmMtYzdlMThmZGQ3ZWI0Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.YnorlbvJxy5PgNFvaFzZKhBGVWiBW3JP9-FwWoRVQUk7ltCHXnBaRWC59Pr8Cwf5y5H8p1kmyY5N0zF8DXEYwNgeLY7v5-EcPoPdeJj_TnM1NJVOc-_p9gMOKrv-MGec9p8uejKPKp8BKCSYzuT7UpkhEiA-y9GzBZf5eoWPWmA5JC8bwarC93QutLU5DiBNPMwTyJ3HFims26eBABjGWRoiu5P_cwZPD4xgmY6VR7qdUfhDY40ufO3aAZvHxaV7exAbcas5tsY4eA65VvGp6G-8ioPF1zuOkQAnxbN-pMeTG0Uc2lZgObyLKHh0NyD_yWMGjn0Pvw58SWvU1GL7CA<br></code></pre></td></tr></table></figure><h3 id="2-3-通过浏览器访问Dashboard的UI"><a href="#2-3-通过浏览器访问Dashboard的UI" class="headerlink" title="2.3 通过浏览器访问Dashboard的UI"></a>2.3 通过浏览器访问Dashboard的UI</h3><p>在登陆页面上输入上面的token</p><img src="/2021/08/24/Kubernetes-DashBoard/image-20210824171057795-1629796425251.png" class="" title="image-20210824171057795"><p>出现下面的页面代表成功</p><img src="/2021/08/24/Kubernetes-DashBoard/image-20210824171123383-1629796426998.png" class="" title="image-20210824171123383"><h2 id="3-使用DashBoard"><a href="#3-使用DashBoard" class="headerlink" title="3. 使用DashBoard"></a>3. 使用DashBoard</h2><p><strong>查看</strong></p><p>选择指定的命名空间<code>dev</code>，然后点击<code>Deployments</code>，查看dev空间下的所有deployment</p><img src="/2021/08/24/Kubernetes-DashBoard/image-20200520154628679.png" class="" title="img"><p><strong>扩缩容</strong></p><p>在<code>Deployment</code>上点击<code>规模</code>，然后指定<code>目标副本数量</code>，点击确定</p><img src="/2021/08/24/Kubernetes-DashBoard/image-20200520162605102.png" class="" title="img"><p><strong>编辑</strong></p><p>在<code>Deployment</code>上点击<code>编辑</code>，然后修改<code>yaml文件</code>，点击确定</p><img src="/2021/08/24/Kubernetes-DashBoard/image-20200520163253644.png" class="" title="image-20200520163253644"><p><strong>查看Pod</strong></p><p>点击<code>Pods</code>, 查看pods列表</p><img src="/2021/08/24/Kubernetes-DashBoard/image-20200520163552110.png" class="" title="img"><p><strong>操作Pod</strong></p><p>选中某个Pod，可以对其执行日志（logs）、进入执行（exec）、编辑、删除操作</p><img src="/2021/08/24/Kubernetes-DashBoard/image-20200520163832827.png" class="" title="img">]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-安全认证</title>
    <link href="/2021/08/24/Kubernetes-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/"/>
    <url>/2021/08/24/Kubernetes-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-安全认证"><a href="#Kubernetes-安全认证" class="headerlink" title="Kubernetes-安全认证"></a>Kubernetes-安全认证</h1><h2 id="1-访问控制概述"><a href="#1-访问控制概述" class="headerlink" title="1. 访问控制概述"></a>1. 访问控制概述</h2><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种<strong>客户端</strong>进行<strong>认证和鉴权</strong>操作。</p><p><strong>客户端</strong></p><p>在Kubernetes集群中，客户端通常有两类：</p><ul><li><strong>User Account</strong>：一般是独立于kubernetes之外的其他服务管理的用户账号。</li><li><strong>Service Account</strong>：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。</li></ul><img src="/2021/08/24/Kubernetes-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/image-20200520102949189.png" class="" title="image-20200520102949189"><p><strong>认证、授权与准入控制</strong></p><p>ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：</p><ul><li>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证</li><li>Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作</li><li>Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。</li></ul><img src="/2021/08/24/Kubernetes-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/image-20200520103942580.png" class="" title="image-20200520103942580"><h2 id="2-认证管理"><a href="#2-认证管理" class="headerlink" title="2. 认证管理"></a>2. 认证管理</h2><p>Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：</p><ul><li><p>HTTP Base认证：通过用户名+密码的方式认证</p><p>​    这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。</p></li><li><p>HTTP Token认证：通过一个Token来识别合法用户</p><p>​    这种认证方式是用一个很长的难以被模仿的字符串–Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。</p></li><li><p>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式</p><p>​    这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。</p></li></ul><img src="/2021/08/24/Kubernetes-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/image-20200518211037434.png" class="" title="image-20200518211037434"><p><strong>HTTPS认证大体分为3个过程：</strong></p><ol><li><p>证书申请和下发</p><ul><li>HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者</li></ul></li><li><p>客户端和服务端的双向认证</p><ul><li>客户端向服务器端发起请求，服务端下发自己的证书给客户端，<br>客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥，<br>客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器</li><li>客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，<br> 在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法</li></ul></li><li><p>服务器端和客户端进行通信</p><ul><li>服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。</li><li>服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密</li></ul></li></ol><p>Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可</p><h2 id="3-授权管理"><a href="#3-授权管理" class="headerlink" title="3. 授权管理"></a>3. 授权管理</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。</p><p>每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。</p><p>API Server目前支持以下几种授权策略：</p><ul><li>AlwaysDeny：表示拒绝所有请求，一般用于测试</li><li>AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）</li><li>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li><li>Webhook：通过调用外部REST服务对用户进行授权</li><li>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制</li><li>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）</li></ul><h3 id="3-2-RBAC"><a href="#3-2-RBAC" class="headerlink" title="3.2 RBAC"></a>3.2 RBAC</h3><p>RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：<strong>给哪些对象授予了哪些权限</strong></p><p>其中涉及到了下面几个概念：</p><ul><li>对象：User、Groups、ServiceAccount</li><li>角色：代表着一组定义在资源上的可操作动作(权限)的集合</li><li>绑定：将定义好的角色跟用户绑定在一起</li></ul><img src="/2021/08/24/Kubernetes-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/image-20200519181209566.png" class="" title="image-20200519181209566"><p>RBAC引入了4个顶级资源对象：</p><ul><li>Role、ClusterRole：角色，用于指定一组权限</li><li>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象</li></ul><p><strong>Role、ClusterRole</strong></p><p>一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Role只能对命名空间内的资源进行授权，需要指定nameapce</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-role</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]  <span class="hljs-comment"># 支持的API组列表,&quot;&quot; 空字符串，表示核心API群</span><br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;pods&quot;</span>] <span class="hljs-comment"># 支持的资源对象列表</span><br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>] <span class="hljs-comment"># 允许的对资源对象的操作方法列表</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><br><span class="hljs-attr">metadata:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-clusterrole</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;pods&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>]<br></code></pre></td></tr></table></figure><p>需要详细说明的是，rules中的参数：</p><ul><li><p>apiGroups: 支持的API组列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;&quot;,&quot;apps&quot;, &quot;autoscaling&quot;, &quot;batch&quot;<br></code></pre></td></tr></table></figure></li><li><p>resources：支持的资源对象列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;services&quot;, &quot;endpoints&quot;, &quot;pods&quot;,&quot;secrets&quot;,&quot;configmaps&quot;,&quot;crontabs&quot;,&quot;deployments&quot;,&quot;jobs&quot;,<br>&quot;nodes&quot;,&quot;rolebindings&quot;,&quot;clusterroles&quot;,&quot;daemonsets&quot;,&quot;replicasets&quot;,&quot;statefulsets&quot;,<br>&quot;horizontalpodautoscalers&quot;,&quot;replicationcontrollers&quot;,&quot;cronjobs&quot;<br></code></pre></td></tr></table></figure></li><li><p>verbs：对资源对象的操作方法列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;exec&quot;<br></code></pre></td></tr></table></figure></li></ul><p><strong>RoleBinding、ClusterRoleBinding</strong></p><p>角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-role-binding</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dongys</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-role</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><br><span class="hljs-attr">metadata:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-clusterrole-binding</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dongys</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-clusterrole</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><p><strong>RoleBinding引用ClusterRole进行授权</strong></p><p>RoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。</p><p>一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding</span><br><span class="hljs-comment"># 所以只能读取dev命名空间中的资源</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-role-binding-ns</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dongys</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-clusterrole</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><h3 id="3-3-RBAC实战"><a href="#3-3-RBAC实战" class="headerlink" title="3.3 RBAC实战"></a>3.3 RBAC实战</h3><p>创建账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1) 创建证书</span><br>[root@master ~]# cd /etc/kubernetes/pki/<br>[root@master pki]# (umask 077;openssl genrsa -out devman.key 2048)<br>Generating RSA private key, 2048 bit long modulus<br>....................................................................................................................................................................+++<br>..........+++<br>e is 65537 (0x10001)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2) 用apiserver的证书去签署</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2-1) 签名申请，申请的用户是devman,组是devgroup</span><br>[root@master pki]# openssl req -new -key devman.key -out devman.csr -subj &quot;/CN=devman/O=devgroup&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2-2) 签署证书</span><br>[root@master pki]# openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650<br>Signature ok<br>subject=/CN=devman/O=devgroup<br>Getting CA Private Key<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3) 设置集群、用户、上下文信息</span><br>[root@master pki]# kubectl config set-cluster kubernetes --embed-certs=true --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.249.100:6443<br>Cluster &quot;kubernetes&quot; set.<br><br>[root@master pki]# kubectl config set-credentials devman --embed-certs=true --client-certificate=/etc/kubernetes/pki/devman.crt --client-key=/etc/kubernetes/pki/devman.key<br>User &quot;devman&quot; set.<br><br>[root@master pki]# kubectl config set-context devman@kubernetes --cluster=kubernetes --user=devman<br>Context &quot;devman@kubernetes&quot; created.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换账户到devman</span><br>[root@master pki]# kubectl config use-context devman@kubernetes<br>Switched to context &quot;devman@kubernetes&quot;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看dev下pod，发现没有权限</span><br>[root@master pki]# kubectl get pods -n dev<br>Error from server (Forbidden): pods is forbidden: User &quot;devman&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;dev&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到admin账户</span><br>[root@master pki]# kubectl config use-context kubernetes-admin@kubernetes<br>Switched to context &quot;kubernetes-admin@kubernetes&quot;.<br></code></pre></td></tr></table></figure><p>创建Role和RoleBinding，为devman用户授权，文件dev-role.yaml如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev-role</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;pods&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>]<br>  <br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1beta1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">authorization-role-binding</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">devman</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev-role</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master pki]# kubectl create -f dev-role.yaml<br>role.rbac.authorization.k8s.io/dev-role created<br>rolebinding.rbac.authorization.k8s.io/authorization-role-binding created<br></code></pre></td></tr></table></figure><p>切换账户，再次验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切换账户到devman</span><br>[root@master pki]# kubectl config use-context devman@kubernetes<br>Switched to context &quot;devman@kubernetes&quot;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看</span><br>[root@master pki]# kubectl get pods -n dev<br>NAME              READY   STATUS    RESTARTS   AGE<br>pod-configmap     1/1     Running   0          3h<br>pod-secret        1/1     Running   0          174m<br>pod1              1/1     Running   0          3h13m<br>pod2              1/1     Running   0          3h13m<br>volume-emptydir   2/2     Running   2          4h5m<br>volume-nfs        2/2     Running   0          3h48m<br></code></pre></td></tr></table></figure><h2 id="4-准入控制"><a href="#4-准入控制" class="headerlink" title="4. 准入控制"></a>4. 准入控制</h2><p>通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver才会处理这个请求。</p><p>准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,<br>                      DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds<br></code></pre></td></tr></table></figure><p>只有当所有的准入控制器都检查通过之后，apiserver才执行该请求，否则返回拒绝。</p><p>当前可配置的Admission Control准入控制如下：</p><ul><li>AlwaysAdmit：允许所有请求</li><li>AlwaysDeny：禁止所有请求，一般用于测试</li><li>AlwaysPullImages：在启动容器之前总去下载镜像</li><li>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求</li><li>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。</li><li>Service Account：实现ServiceAccount实现了自动化</li><li>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效</li><li>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标</li><li>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制</li><li>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置</li><li>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。</li><li>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节</li><li>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min</li><li>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制</li></ul>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-数据存储</title>
    <link href="/2021/08/24/Kubernetes-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <url>/2021/08/24/Kubernetes-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-数据存储"><a href="#Kubernetes-数据存储" class="headerlink" title="Kubernetes-数据存储"></a>Kubernetes-数据存储</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在前面已经提到，容器的生命周期可能很短，会被频繁的创建和销毁。那么容器在销毁的时候，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器中的数据，kubernetes引入了Volume的概念。</p><p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里面的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命周期不和Pod中的单个容器的生命周期有关，当容器终止或者重启的时候，Volume中的数据也不会丢失。</p><p>kubernetes的Volume支持多种类型，比较常见的有下面的几个：</p><ul><li><p>简单存储：EmptyDir、HostPath、NFS。</p></li><li><p>高级存储：PV、PVC。</p></li><li><p>配置存储：ConfigMap、Secret。</p></li></ul><h2 id="2-基本存储"><a href="#2-基本存储" class="headerlink" title="2. 基本存储"></a>2. 基本存储</h2><h3 id="2-1-EmptyDir"><a href="#2-1-EmptyDir" class="headerlink" title="2.1 EmptyDir"></a>2.1 EmptyDir</h3><p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</p><p>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p><ul><li>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</li><li>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li></ul><p>接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。</p><p>在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。</p><img src="/2021/08/24/Kubernetes-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/image-20200413174713773.png" class="" title="image-20200413174713773"><p>创建一个volume-emptydir.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-emptydir</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">volumeMounts:</span>  <span class="hljs-comment"># 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/nginx</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;tail -f /logs/access.log&quot;</span>] <span class="hljs-comment"># 初始命令，动态读取指定文件中内容</span><br>    <span class="hljs-attr">volumeMounts:</span>  <span class="hljs-comment"># 将logs-volume 挂在到busybox容器中，对应的目录为 /logs</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/logs</span><br>  <span class="hljs-attr">volumes:</span> <span class="hljs-comment"># 声明volume， name为logs-volume，类型为emptyDir</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f volume-emptydir.yaml<br>pod/volume-emptydir created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods volume-emptydir -n dev -o wide<br>NAME              READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES<br>volume-emptydir   2/2     Running   0          13s   10.244.1.4   node01   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过podIp访问nginx</span><br>[root@master ~]# curl 10.244.1.5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过kubectl logs命令查看指定容器的标准输出</span><br>[root@master ~]# kubectl logs -f volume-emptydir -n dev -c busybox<br>10.244.0.0 - - [24/Aug/2021:04:51:46 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;<br></code></pre></td></tr></table></figure><h3 id="2-2-HostPath"><a href="#2-2-HostPath" class="headerlink" title="2.2 HostPath"></a>2.2 HostPath</h3><p>上节课提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p><p>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。</p><img src="/2021/08/24/Kubernetes-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/image-20200413214031331.png" class="" title="image-20200413214031331"><p>创建一个volume-hostpath.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-hostpath</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/nginx</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;tail -f /logs/access.log&quot;</span>]<br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/logs</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>    <span class="hljs-attr">hostPath:</span> <br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/root/logs</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span>  <span class="hljs-comment"># 目录存在就使用，不存在就先创建后使用</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">关于type的值的一点说明：</span><br>    <span class="hljs-string">DirectoryOrCreate</span> <span class="hljs-string">目录存在就使用，不存在就先创建后使用</span><br>    <span class="hljs-string">Directory</span>   <span class="hljs-string">目录必须存在</span><br>    <span class="hljs-string">FileOrCreate</span>  <span class="hljs-string">文件存在就使用，不存在就先创建后使用</span><br>    <span class="hljs-string">File</span> <span class="hljs-string">文件必须存在</span> <br>    <span class="hljs-string">Socket</span>  <span class="hljs-string">unix套接字必须存在</span><br>    <span class="hljs-string">CharDevice</span>  <span class="hljs-string">字符设备必须存在</span><br>    <span class="hljs-string">BlockDevice</span> <span class="hljs-string">块设备必须存在</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f volume-hostpath.yaml<br>pod/volume-hostpath created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods volume-hostpath -n dev -o wide<br>NAME              READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES<br>volume-hostpath   2/2     Running   0          9s    10.244.2.6   node02   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问nginx</span><br>[root@master ~]# curl 10.244.2.6<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来就可以去host的/root/logs目录下查看存储的文件了</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##  注意: 下面的操作需要到Pod所在的节点运行（案例中是node02）</span></span><br>[root@node02 ~]# ls /root/logs/<br>access.log  error.log<br>[root@node02 ~]# tail -f /root/logs/access.log<br>10.244.0.0 - - [24/Aug/2021:04:55:30 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;<br></code></pre></td></tr></table></figure><h3 id="2-3-NFS"><a href="#2-3-NFS" class="headerlink" title="2.3 NFS"></a>2.3 NFS</h3><p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。</p><p>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。</p><img src="/2021/08/24/Kubernetes-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/image-20200413215133559.png" class="" title="image-20200413215133559"><p>首先要准备nfs的服务器，这里为了简单，直接是master节点做nfs服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在nfs上安装nfs服务</span><br>[root@master ~]# yum install nfs-utils -y<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">准备一个共享目录</span><br>[root@master ~]# mkdir /root/data/nfs -pv<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将共享目录以读写权限暴露给192.168.5.0/24网段中的所有主机</span><br>[root@master ~]# vim /etc/exports<br>[root@master ~]# more /etc/exports<br>/root/data/nfs     192.168.249.0/24(rw,no_root_squash)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动nfs服务</span><br>[root@master ~]# systemctl restart nfs<br></code></pre></td></tr></table></figure><p>接下来，要在的每个node节点上都安装下nfs，这样的目的是为了node节点可以驱动nfs设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在node上安装nfs服务，注意不需要启动</span><br>[root@node01 ~]# yum install nfs-utils -y<br>[root@node02 ~]# yum install nfs-utils -y<br></code></pre></td></tr></table></figure><p>接下来，就可以编写pod的配置文件了，创建volume-nfs.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-nfs</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/nginx</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;tail -f /logs/access.log&quot;</span>] <br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/logs</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">logs-volume</span><br>    <span class="hljs-attr">nfs:</span><br>      <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.249</span><span class="hljs-number">.100</span>  <span class="hljs-comment">#nfs服务器地址</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/root/data/nfs</span> <span class="hljs-comment">#共享文件路径</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f volume-nfs.yaml<br>pod/volume-nfs created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods volume-nfs -n dev<br>NAME         READY   STATUS    RESTARTS   AGE<br>volume-nfs   2/2     Running   0          11s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看nfs服务器上的共享目录，发现已经有文件了</span><br>[root@master ~]# ls /root/data/nfs<br>access.log  error.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问podIp之后，再查看日志文件</span><br>[root@master ~]# tail -f /root/data/nfs/access.log <br>10.244.0.0 - - [24/Aug/2021:05:07:31 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;<br></code></pre></td></tr></table></figure><h2 id="3-高级存储"><a href="#3-高级存储" class="headerlink" title="3. 高级存储"></a>3. 高级存储</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。</p><p>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</p><p>PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。</p><img src="/2021/08/24/Kubernetes-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/image-20200514194111567.png" class="" title="image-20200514194111567"><p>使用了PV和PVC之后，工作可以得到进一步的细分：</p><ul><li>存储：存储工程师维护</li><li>PV： kubernetes管理员维护</li><li>PVC：kubernetes用户维护</li></ul><h3 id="3-2-PV"><a href="#3-2-PV" class="headerlink" title="3.2 PV"></a>3.2 PV</h3><p>PV是存储资源的抽象，下面是资源清单文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>  <br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv2</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">nfs:</span> <span class="hljs-comment"># 存储类型，与底层真正存储对应</span><br>  <span class="hljs-attr">capacity:</span>  <span class="hljs-comment"># 存储能力，目前只支持存储空间的设置</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">2Gi</span><br>  <span class="hljs-attr">accessModes:</span>  <span class="hljs-comment"># 访问模式</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-comment"># 存储类别</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-comment"># 回收策略</span><br></code></pre></td></tr></table></figure><p>PV 的关键配置参数说明：</p><ul><li><p><strong>存储类型</strong></p><p>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</p></li><li><p><strong>存储能力（capacity）</strong></p><p>目前只支持存储空间的设置( storage&#x3D;1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</p></li><li><p><strong>访问模式（accessModes）</strong></p><p>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p><ul><li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li><li>ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载</li><li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li></ul><p><code>需要注意的是，底层不同的存储类型可能支持的访问模式不同</code></p></li><li><p><strong>回收策略（persistentVolumeReclaimPolicy）</strong></p><p>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：</p><ul><li>Retain （保留） 保留数据，需要管理员手工清理数据</li><li>Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf &#x2F;thevolume&#x2F;*</li><li>Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务</li></ul><p><code>需要注意的是，底层不同的存储类型可能支持的回收策略不同</code></p></li><li><p><strong>存储类别</strong></p><p>PV可以通过storageClassName参数指定一个存储类别</p><ul><li>具有特定类别的PV只能与请求了该类别的PVC进行绑定</li><li>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</li></ul></li><li><p><strong>状态（status）</strong></p><p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p><ul><li>Available（可用）： 表示可用状态，还未被任何 PVC 绑定</li><li>Bound（已绑定）： 表示 PV 已经被 PVC 绑定</li><li>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明</li><li>Failed（失败）： 表示该 PV 的自动回收失败</li></ul></li></ul><p><strong>实验</strong></p><p>使用NFS作为存储，来演示PV的使用，创建3个PV，对应NFS中的3个暴露的路径。</p><p>准备NFS环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建目录</span><br>[root@master ~]# mkdir /root/data/&#123;pv1,pv2,pv3&#125; -pv<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">暴露服务</span><br>[root@master ~]# more /etc/exports<br>/root/data/pv1     192.168.249.0/24(rw,no_root_squash)<br>/root/data/pv2     192.168.249.0/24(rw,no_root_squash)<br>/root/data/pv3     192.168.249.0/24(rw,no_root_squash)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span><br>[root@master ~]#  systemctl restart nfs<br></code></pre></td></tr></table></figure><p>创建pv.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span>  <span class="hljs-string">pv1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span> <br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Retain</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/root/data/pv1</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.249</span><span class="hljs-number">.100</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span>  <span class="hljs-string">pv2</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span> <br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">2Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Retain</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/root/data/pv2</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.249</span><span class="hljs-number">.100</span><br>    <br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span>  <span class="hljs-string">pv3</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span> <br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">3Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Retain</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/root/data/pv3</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.249</span><span class="hljs-number">.100</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl create -f pv.yaml<br>persistentvolume/pv1 created<br>persistentvolume/pv2 created<br>persistentvolume/pv3 created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pv</span><br>[root@master ~]# kubectl get pv -o wide<br>NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE   VOLUMEMODE<br>pv1    1Gi        RWX            Retain           Available                                   19s   Filesystem<br>pv2    2Gi        RWX            Retain           Available                                   19s   Filesystem<br>pv3    3Gi        RWX            Retain           Available                                   19s   Filesystem<br></code></pre></td></tr></table></figure><h3 id="3-3-PVC"><a href="#3-3-PVC" class="headerlink" title="3.3 PVC"></a>3.3 PVC</h3><p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pvc</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span> <span class="hljs-comment"># 访问模式</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 采用标签对PV选择</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-comment"># 存储类别</span><br>  <span class="hljs-attr">resources:</span> <span class="hljs-comment"># 请求空间</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span><br></code></pre></td></tr></table></figure><p>PVC 的关键配置参数说明：</p><ul><li><p><strong>访问模式（accessModes）</strong></p><p>用于描述用户应用对存储资源的访问权限</p></li><li><p><strong>选择条件（selector）</strong></p><p>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</p></li><li><p><strong>存储类别（storageClassName）</strong></p><p>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</p></li><li><p><strong>资源请求（Resources ）</strong></p><p>描述对存储资源的请求</p></li></ul><p><strong>实验</strong></p><p>创建pvc.yaml，申请pv</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pvc1</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pvc2</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pvc3</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pvc</span><br>[root@master ~]# kubectl create -f pvc.yaml<br>persistentvolumeclaim/pvc1 created<br>persistentvolumeclaim/pvc2 created<br>persistentvolumeclaim/pvc3 created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pvc</span><br>[root@master ~]# kubectl get pvc -n dev -o wide<br>NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE   VOLUMEMODE<br>pvc1   Bound    pv1      1Gi        RWX                           8s    Filesystem<br>pvc2   Bound    pv2      2Gi        RWX                           8s    Filesystem<br>pvc3   Bound    pv3      3Gi        RWX                           8s    Filesystem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pv</span><br>[root@master ~]# kubectl get pv -o wide<br>NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM      STORAGECLASS   REASON   AGE     VOLUMEMODE<br>pv1    1Gi        RWX            Retain           Bound    dev/pvc1                           7m18s   Filesystem<br>pv2    2Gi        RWX            Retain           Bound    dev/pvc2                           7m18s   Filesystem<br>pv3    3Gi        RWX            Retain           Bound    dev/pvc3                           7m18s   Filesystem<br></code></pre></td></tr></table></figure><p>创建pods.yaml, 使用pv</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod1</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]<br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/root/</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume</span><br>      <span class="hljs-attr">persistentVolumeClaim:</span><br>        <span class="hljs-attr">claimName:</span> <span class="hljs-string">pvc1</span><br>        <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">false</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod2</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;while true;do echo pod2 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]<br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/root/</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume</span><br>      <span class="hljs-attr">persistentVolumeClaim:</span><br>        <span class="hljs-attr">claimName:</span> <span class="hljs-string">pvc2</span><br>        <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pods.yaml<br>pod/pod1 created<br>pod/pod2 created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods -n dev -o wide<br>NAME              READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES<br>pod1              1/1     Running   0          5s    10.244.1.7   node01   &lt;none&gt;           &lt;none&gt;<br>pod2              1/1     Running   0          5s    10.244.1.8   node01   &lt;none&gt;           &lt;none&gt;<br>volume-emptydir   2/2     Running   2          52m   10.244.1.5   node01   &lt;none&gt;           &lt;none&gt;<br>volume-nfs        2/2     Running   0          35m   10.244.2.7   node02   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pvc</span><br>[root@master ~]# kubectl get pvc -n dev -o wide<br>NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE     VOLUMEMODE<br>pvc1   Bound    pv1      1Gi        RWX                           2m17s   Filesystem<br>pvc2   Bound    pv2      2Gi        RWX                           2m17s   Filesystem<br>pvc3   Bound    pv3      3Gi        RWX                           2m17s   Filesystem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pv</span><br>[root@master ~]# kubectl get pv -n dev -o wide<br>NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM      STORAGECLASS   REASON   AGE     VOLUMEMODE<br>pv1    1Gi        RWX            Retain           Bound    dev/pvc1                           9m11s   Filesystem<br>pv2    2Gi        RWX            Retain           Bound    dev/pvc2                           9m11s   Filesystem<br>pv3    3Gi        RWX            Retain           Bound    dev/pvc3                           9m11s   Filesystem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看nfs中的文件存储</span><br>[root@master ~]# more /root/data/pv1/out.txt<br>pod1<br>pod1<br>pod1<br>pod1<br>[root@master ~]# more /root/data/pv2/out.txt<br>pod2<br>pod2<br>pod2<br>pod2<br></code></pre></td></tr></table></figure><h3 id="3-4-生命周期"><a href="#3-4-生命周期" class="headerlink" title="3.4 生命周期"></a>3.4 生命周期</h3><p>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：</p><ul><li><p><strong>资源供应</strong>：管理员手动创建底层存储和PV</p></li><li><p><strong>资源绑定</strong>：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的</p><ul><li>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</li><li>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV</li></ul><p>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</p></li><li><p><strong>资源使用</strong>：用户可在pod中像volume一样使用pvc</p><p>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。</p></li><li><p><strong>资源释放</strong>：用户删除pvc来释放pv</p><p>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</p></li><li><p><strong>资源回收</strong>：kubernetes根据pv设置的回收策略进行资源的回收</p><p>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</p></li></ul><img src="/2021/08/24/Kubernetes-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/image-20200515002806726.png" class="" title="image-20200515002806726"><h2 id="4-配置存储"><a href="#4-配置存储" class="headerlink" title="4. 配置存储"></a>4. 配置存储</h2><h3 id="4-1-ConfigMap"><a href="#4-1-ConfigMap" class="headerlink" title="4.1 ConfigMap"></a>4.1 ConfigMap</h3><p>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。</p><p>创建configmap.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">configmap</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">info:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    username:admin</span><br><span class="hljs-string">    password:123456</span><br></code></pre></td></tr></table></figure><p>接下来，使用此配置文件创建configmap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建configmap</span><br>[root@master ~]# kubectl create -f configmap.yaml<br>configmap/configmap created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看configmap详情</span><br>[root@master ~]# kubectl describe cm configmap -n dev<br>Name:         configmap<br>Namespace:    dev<br>Labels:       &lt;none&gt;<br>Annotations:  &lt;none&gt;<br><br>Data<br>====<br>info:<br>----<br>username:admin<br>password:123456<br><br>Events:  &lt;none&gt;<br></code></pre></td></tr></table></figure><p>接下来创建一个pod-configmap.yaml，将上面创建的configmap挂载进去</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-configmap</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment"># 将configmap挂载到目录</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/configmap/config</span><br>  <span class="hljs-attr">volumes:</span> <span class="hljs-comment"># 引用configmap</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">configmap</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-configmap.yaml<br>pod/pod-configmap created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pod pod-configmap -n dev<br>NAME            READY   STATUS    RESTARTS   AGE<br>pod-configmap   1/1     Running   0          8s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>[root@master ~]# kubectl exec -it pod-configmap -n dev /bin/sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> /configmap/config/</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">more info</span><br>username:admin<br>password:123456<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看到映射已经成功，每个configmap都映射成了一个目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">key---&gt;文件     value----&gt;文件中的内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时如果更新configmap的内容, 容器中的值也会动态更新</span><br></code></pre></td></tr></table></figure><h3 id="4-2-Secret"><a href="#4-2-Secret" class="headerlink" title="4.2 Secret"></a>4.2 Secret</h3><p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。</p><p>首先使用base64对数据进行编码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# echo -n &#x27;admin&#x27; | base64 #准备username<br>YWRtaW4=<br>[root@master ~]# echo -n &#x27;123456&#x27; | base64 #准备password<br>MTIzNDU2<br></code></pre></td></tr></table></figure><p>接下来编写secret.yaml，并创建Secret</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">YWRtaW4=</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-string">MTIzNDU2</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建secret</span><br>[root@master ~]# kubectl create -f secret.yaml<br>secret/secret created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看secret详情</span><br>[root@master ~]# kubectl describe secret secret -n dev<br>Name:         secret<br>Namespace:    dev<br>Labels:       &lt;none&gt;<br>Annotations:  &lt;none&gt;<br><br>Type:  Opaque<br><br>Data<br>====<br>username:  5 bytes<br>password:  6 bytes<br></code></pre></td></tr></table></figure><p>创建pod-secret.yaml，将上面创建的secret挂载进去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-secret</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment"># 将secret挂载到目录</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/secret/config</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>    <span class="hljs-attr">secret:</span><br>      <span class="hljs-attr">secretName:</span> <span class="hljs-string">secret</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-secret.yaml<br>pod/pod-secret created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pod pod-secret -n dev<br>NAME         READY   STATUS    RESTARTS   AGE<br>pod-secret   1/1     Running   0          8s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器，查看secret信息，发现已经自动解码了</span><br>[root@master ~]# kubectl exec -it pod-secret /bin/sh -n dev<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ls</span> /secret/config</span><br>password  username<br><span class="hljs-meta prompt_"># </span><span class="language-bash">more /secret/config/username</span><br>admin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">more /secret/config/password</span><br>123456<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-Service详解</title>
    <link href="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-Service详解"><a href="#Kubernetes-Service详解" class="headerlink" title="Kubernetes-Service详解"></a>Kubernetes-Service详解</h1><h2 id="1-Service介绍"><a href="#1-Service介绍" class="headerlink" title="1. Service介绍"></a>1. Service介绍</h2><p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p><p>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200408194716912-1626783758946.png" class="" title="image-20200408194716912-1626783758946"><p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong>。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200509121254425.png" class="" title="image-20200509121254425"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">10.97.97.97:80 是service提供的访问入口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。</span><br>[root@master ~]# ipvsadm -Ln<br>IP Virtual Server version 1.2.1 (size=4096)<br>Prot LocalAddress:Port Scheduler Flags<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br>TCP  172.17.0.1:31884 rr<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.140.99:80             Masq    1      0          0</span>         <br>TCP  192.168.249.100:31884 rr<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.140.99:80             Masq    1      0          0</span><br></code></pre></td></tr></table></figure><p>kube-proxy目前支持三种工作模式</p><p><strong>userspace模式</strong></p><p>userspaces模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster Ip的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立连接，以将请求转发到Pod上。该模式下，kube-proxy充当了一个四层负载均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200509151424280.png" class="" title="image-20200509151424280"><p><strong>iptables 模式</strong></p><p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。  该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200509152947714.png" class="" title="image-20200509152947714"><p><strong>ipvs 模式</strong></p><p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200509153731363-1629700884860.png" class="" title="image-20200509153731363"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此模式必须安装ipvs内核模块，否则会降级为iptables</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启ipvs，修改mode: <span class="hljs-string">&quot;ipvs&quot;</span></span><br>[root@master ~]# kubectl edit cm kube-proxy -n kube-system<br>Edit cancelled, no changes made.<br><br>[root@master ~]# kubectl delete pod -l k8s-app=kube-proxy -n kube-system<br>pod &quot;kube-proxy-lv2rw&quot; deleted<br>pod &quot;kube-proxy-mmlrd&quot; deleted<br>pod &quot;kube-proxy-tvmzr&quot; deleted<br>[root@master ~]# ipvsadm -Ln<br>IP Virtual Server version 1.2.1 (size=4096)<br>Prot LocalAddress:Port Scheduler Flags<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br>TCP  172.17.0.1:31884 rr<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.140.99:80             Masq    1      0          0</span>         <br>TCP  192.168.249.100:31884 rr<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.140.99:80             Masq    1      0          0</span>         <br>TCP  10.96.0.1:443 rr<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">192.168.249.100:6443         Masq    1      7          0</span>         <br>TCP  10.96.0.10:53 rr<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.219.68:53             Masq    1      0          0</span>         <br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.219.69:53             Masq    1      0          0</span><br></code></pre></td></tr></table></figure><h2 id="2-Service类型"><a href="#2-Service类型" class="headerlink" title="2. Service类型"></a>2. Service类型</h2><p>Service的资源清单文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>  <span class="hljs-comment"># 资源类型</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>  <span class="hljs-comment"># 资源版本</span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service</span> <span class="hljs-comment"># 资源名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 命名空间</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 描述</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 标签选择器，用于确定当前service代理哪些pod</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-comment"># Service类型，指定service的访问方式</span><br>  <span class="hljs-attr">clusterIP:</span>  <span class="hljs-comment"># 虚拟服务的ip地址</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-comment"># session亲和性，支持ClientIP、None两个选项</span><br>  <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 端口信息</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span> <br>      <span class="hljs-attr">port:</span> <span class="hljs-number">3017</span>  <span class="hljs-comment"># service端口</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5003</span> <span class="hljs-comment"># pod端口</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">31122</span> <span class="hljs-comment"># 主机端口</span><br></code></pre></td></tr></table></figure><ul><li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li><li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li><li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li><li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li></ul><h2 id="3-Service使用"><a href="#3-Service使用" class="headerlink" title="3. Service使用"></a>3. Service使用</h2><h3 id="3-1-实验环境准备"><a href="#3-1-实验环境准备" class="headerlink" title="3.1 实验环境准备"></a>3.1 实验环境准备</h3><p>在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置<code>app=nginx-pod</code>的标签</p><p>创建deployment.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>      <br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-deployment</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span> <br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f deployment.yaml<br>deployment.apps/pc-deployment created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod详情</span><br>[root@master ~]# kubectl get pods -n dev -o wide --show-labels<br>NAME                             READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES   LABELS<br>pc-deployment-7d7dd5499b-fdvxh   1/1     Running   1          11m   10.244.140.107   node02   &lt;none&gt;           &lt;none&gt;            app=nginx-pod,pod-template-hash=7d7dd5499b<br>pc-deployment-7d7dd5499b-jf79c   1/1     Running   1          11m   10.244.196.184   node01   &lt;none&gt;           &lt;none&gt;            app=nginx-pod,pod-template-hash=7d7dd5499b<br>pc-deployment-7d7dd5499b-pj8rt   1/1     Running   1          11m   10.244.196.183   node01   &lt;none&gt;           &lt;none&gt;            app=nginx-pod,pod-template-hash=7d7dd5499b<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）</span><br>[root@master ~]#kubectl exec -it pc-deployment-7d7dd5499b-fdvxh -n dev /bin/sh<br>echo &quot;10.244.1.39&quot; &gt; /usr/share/nginx/html/index.html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改完毕之后，访问测试</span><br>[root@master ~]# curl 10.244.140.107<br>10.244.140.107<br>[root@master ~]# curl 10.244.196.184<br>10.244.196.184<br>[root@master ~]# curl 10.244.196.183<br>10.244.196.183<br></code></pre></td></tr></table></figure><h3 id="3-2-ClusterIP类型的Service"><a href="#3-2-ClusterIP类型的Service" class="headerlink" title="3.2 ClusterIP类型的Service"></a>3.2 ClusterIP类型的Service</h3><p>创建service-clusterip.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-clusterip</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.97</span><span class="hljs-number">.97</span><span class="hljs-number">.97</span> <span class="hljs-comment"># service的ip地址，如果不写，默认会生成一个</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>  <span class="hljs-comment"># Service端口       </span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># pod端口</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建service</span><br>[root@master ~]# kubectl create -f service-clusterip.yaml<br>service/service-clusterip created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看service</span><br>[root@master ~]# kubectl get svc service-clusterip -n dev<br>NAME                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE<br>service-clusterip   ClusterIP   10.97.97.97   &lt;none&gt;        80/TCP    15s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看service的详细信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口</span><br>[root@master ~]# kubectl describe svc service-clusterip -n dev   <br>Name:              service-clusterip<br>Namespace:         dev<br>Labels:            &lt;none&gt;<br>Annotations:       &lt;none&gt;<br>Selector:          app=nginx-pod<br>Type:              ClusterIP<br>IP:                10.97.97.97<br>Port:              &lt;unset&gt;  80/TCP<br>TargetPort:        80/TCP<br>Endpoints:         10.244.140.107:80,10.244.196.183:80,10.244.196.184:80<br>Session Affinity:  None<br>Events:            &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看ipvs的映射规则</span><br>[root@master ~]# ipvsadm -Ln<br>TCP  10.97.97.97:80 rr<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.140.107:80            Masq    1      0          0</span>         <br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.196.183:80            Masq    1      0          0</span>         <br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.196.184:80            Masq    1      0          0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试效果</span><br>[root@master ~]# curl 10.97.97.97:80<br>10.244.196.184<br>[root@master ~]# curl 10.97.97.97:80<br>10.244.196.183<br>[root@master ~]# curl 10.97.97.97:80<br>10.244.140.107<br></code></pre></td></tr></table></figure><p><strong>Endpoint</strong></p><p>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。</p><p>一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，<strong>Endpoints是实现实际服务的端点集合</strong>。换句话说，service和pod之间的联系是通过endpoints实现的。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200509191917069.png" class="" title="image-20200509191917069"><p><strong>负载分发策略</strong></p><p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p><ul><li>如果不定义，默认使用kube-proxy的策略，比如随机、轮询</li><li>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上</li></ul><p>此模式可以使在spec中添加<code>sessionAffinity:ClientIP</code>选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看ipvs的映射规则</span><br>[root@master ~]# ipvsadm -Ln<br>TCP  10.97.97.97:80 rr<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.140.107:80            Masq    1      0          0</span>         <br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.196.183:80            Masq    1      0          0</span>         <br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.196.184:80            Masq    1      0          0</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">循环访问测试</span><br>[root@master ~]# while true;do curl 10.97.97.97:80; sleep 1; done; <br>10.244.140.107<br>10.244.196.184<br>10.244.196.183<br>10.244.140.107<br>10.244.196.184<br>10.244.196.183<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看ipvs规则【persistent 代表持久】</span><br>[root@master ~]# ipvsadm -Ln<br>TCP  10.97.97.97:80 rr persistent 10800<br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.140.107:80            Masq    1      0          3</span>         <br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.196.183:80            Masq    1      0          4</span>         <br><span class="hljs-meta prompt_">  -&gt; </span><span class="language-bash">10.244.196.184:80            Masq    1      0          4</span><br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">循环访问测试</span><br>[root@master ~]# while true;do curl 10.97.97.97; sleep 1; done; <br>10.244.196.184<br>10.244.196.184<br>10.244.196.184<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除service</span><br>[root@master ~]# kubectl delete -f service-clusterip.yaml<br>service &quot;service-clusterip&quot; deleted<br></code></pre></td></tr></table></figure><h3 id="3-3-HeadLiness类型的Service"><a href="#3-3-HeadLiness类型的Service" class="headerlink" title="3.3 HeadLiness类型的Service"></a>3.3 HeadLiness类型的Service</h3><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。</p><p>创建service-headliness.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-headliness</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span> <span class="hljs-comment"># 将clusterIP设置为None，即可创建headliness Service</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>    <br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl create -f service-headliness.yaml<br>service/service-headliness created<br>[root@master ~]# kubectl get svc service-headliness -n dev -o wide<br>NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR<br>service-headliness   ClusterIP   None         &lt;none&gt;        80/TCP    12s   app=nginx-pod<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看service详情</span><br>[root@master ~]# kubectl describe svc service-headliness -n dev       <br>Name:              service-headliness<br>Namespace:         dev<br>Labels:            &lt;none&gt;<br>Annotations:       &lt;none&gt;<br>Selector:          app=nginx-pod<br>Type:              ClusterIP<br>IP:                None<br>Port:              &lt;unset&gt;  80/TCP<br>TargetPort:        80/TCP<br>Endpoints:         10.244.140.107:80,10.244.196.183:80,10.244.196.184:80<br>Session Affinity:  None<br>Events:            &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看域名的解析情况</span><br>[root@master ~]# kubectl exec -it pc-deployment-7d7dd5499b-fdvxh -n dev /bin/sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span> /etc/resolv.conf</span><br>nameserver 10.96.0.10<br>search dev.svc.cluster.local svc.cluster.local cluster.local<br>options ndots:5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过域名进行查询</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dig @10.96.0.10 service-headliness.dev.svc.cluster.local</span><br></code></pre></td></tr></table></figure><h3 id="3-4-NodePort类型的Service"><a href="#3-4-NodePort类型的Service" class="headerlink" title="3.4 NodePort类型的Service"></a>3.4 NodePort类型的Service</h3><p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是<strong>将service的端口映射到Node的一个端口上</strong>，然后就可以通过<code>NodeIp:NodePort</code>来访问service了。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200620175731338.png" class="" title="image-20200620175731338"><p>创建service-nodeport.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-nodeport</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span> <span class="hljs-comment"># service类型</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30002</span> <span class="hljs-comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建service</span><br>[root@master ~]# kubectl create -f service-nodeport.yaml<br>service/service-nodeport created<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看service</span><br>[root@master ~]# kubectl get svc -n dev -o wide<br>NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE   SELECTOR<br>service-nodeport     NodePort    10.111.175.128   &lt;none&gt;        80:30002/TCP   8s    app=nginx-pod<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以通过浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod</span><br></code></pre></td></tr></table></figure><h3 id="3-5-LoadBalancer类型的Service"><a href="#3-5-LoadBalancer类型的Service" class="headerlink" title="3.5 LoadBalancer类型的Service"></a>3.5 LoadBalancer类型的Service</h3><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200510103945494.png" class="" title="image-20200510103945494"><h3 id="3-6-ExternalName类型的Service"><a href="#3-6-ExternalName类型的Service" class="headerlink" title="3.6 ExternalName类型的Service"></a>3.6 ExternalName类型的Service</h3><p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200510113311209.png" class="" title="image-20200510113311209"><p>创建service-externalname.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-externalname</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ExternalName</span> <span class="hljs-comment"># service类型</span><br>  <span class="hljs-attr">externalName:</span> <span class="hljs-string">www.baidu.com</span>  <span class="hljs-comment">#改成ip地址也可以</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建service</span><br>[root@master ~]# kubectl create -f service-externalname.yaml<br>service/service-externalname created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看service，可以通过域名解析访问</span><br>[root@master ~]# kubectl get svc service-externalname -n dev<br>NAME                   TYPE           CLUSTER-IP   EXTERNAL-IP     PORT(S)   AGE<br>service-externalname   ExternalName   &lt;none&gt;       www.baidu.com   &lt;none&gt;    18<br></code></pre></td></tr></table></figure><h2 id="4-Ingress介绍"><a href="#4-Ingress介绍" class="headerlink" title="4. Ingress介绍"></a>4. Ingress介绍</h2><p>Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p><ul><li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</li><li>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</li></ul><p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/1609905648464-a3f21b67-099e-4c8f-9152-786b6bc3e46a.png" class="" title="Ingress介绍.png"><p>实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在<strong>Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务</strong>。在这里有两个核心概念：</p><ul><li>ingress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则</li><li>ingress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等</li></ul><p>Ingress（以Nginx为例）的工作原理如下：</p><ol><li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li><li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li><li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li><li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则</li></ol><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200516112704764.png" class="" title="image-20200516112704764"><h2 id="5-Ingress使用"><a href="#5-Ingress使用" class="headerlink" title="5. Ingress使用"></a>5. Ingress使用</h2><h3 id="5-1-环境准备"><a href="#5-1-环境准备" class="headerlink" title="5.1 环境准备"></a>5.1 环境准备</h3><p><strong>搭建ingress环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建文件夹</span><br>[root@master ~]# mkdir ingress-controller<br>[root@master ~]# cd ingress-controller/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取ingress-nginx，本次案例使用的是0.30版本</span><br>[root@master ingress-controller]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml<br>[root@master ingress-controller]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改mandatory.yaml文件中的仓库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建ingress-nginx</span><br>[root@master ingress-controller]# kubectl apply -f ./<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看ingress-nginx</span><br>[root@master ingress-controller]# kubectl get pod -n ingress-nginx<br>NAME                                           READY   STATUS    RESTARTS   AGE<br>pod/nginx-ingress-controller-fbf967dd5-4qpbp   1/1     Running   0          12h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看service</span><br>[rootmaster ingress-controller]# kubectl get svc -n ingress-nginx<br>NAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE<br>ingress-nginx   NodePort   10.98.75.163   &lt;none&gt;        80:32240/TCP,443:31335/TCP   11h<br></code></pre></td></tr></table></figure><p><strong>准备service和pod</strong></p><p>为了后面的实验比较方便，创建如下图所示的模型</p><img src="/2021/08/23/Kubernetes-Service%E8%AF%A6%E8%A7%A3/image-20200516102419998.png" class="" title="image-20200516102419998"><p>创建tomcat-nginx.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-deployment</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat:8.5-jre10-slim</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat-pod</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><h3 id="5-2-Http代理"><a href="#5-2-Http代理" class="headerlink" title="5.2 Http代理"></a>5.2 Http代理</h3><p>创建ingress-http.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-http</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.itheima.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-service</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">tomcat.itheima.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">tomcat-service</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建</span><br>[root@master ~]# kubectl create -f ingress-http.yaml<br>ingress.extensions/ingress-http created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看</span><br>[root@master ~]# kubectl get ing ingress-http -n dev<br>NAME           HOSTS                                  ADDRESS   PORTS   AGE<br>ingress-http   nginx.itheima.com,tomcat.itheima.com             80      22s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看详情</span><br>[root@master ~]# kubectl describe ing ingress-http  -n dev<br>...<br>Rules:<br>Host                Path  Backends<br>----                ----  --------<br>nginx.itheima.com   / nginx-service:80 (10.244.1.96:80,10.244.1.97:80,10.244.2.112:80)<br>tomcat.itheima.com  / tomcat-service:8080(10.244.1.94:8080,10.244.1.95:8080,10.244.2.111:8080)<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后,就可以分别访问tomcat.itheima.com:32240  和  nginx.itheima.com:32240 查看效果了</span><br></code></pre></td></tr></table></figure><h3 id="5-3-Https代理"><a href="#5-3-Https代理" class="headerlink" title="5.3 Https代理"></a>5.3 Https代理</h3><p>创建证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生成证书</span><br>openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=itheima.com&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建密钥</span><br>kubectl create secret tls tls-secret --key tls.key --cert tls.crt<br></code></pre></td></tr></table></figure><p>创建ingress-https.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-https</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tls:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">nginx.itheima.com</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">tomcat.itheima.com</span><br>      <span class="hljs-attr">secretName:</span> <span class="hljs-string">tls-secret</span> <span class="hljs-comment"># 指定秘钥</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.itheima.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-service</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">tomcat.itheima.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">tomcat-service</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建</span><br>[root@master ~]# kubectl create -f ingress-https.yaml<br>ingress.extensions/ingress-https created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看</span><br>[root@master ~]# kubectl get ing ingress-https -n dev<br>NAME            HOSTS                                  ADDRESS         PORTS     AGE<br>ingress-https   nginx.itheima.com,tomcat.itheima.com   10.104.184.38   80, 443   2m42s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看详情</span><br>[root@master ~]# kubectl describe ing ingress-https -n dev<br>...<br>TLS:<br>  tls-secret terminates nginx.itheima.com,tomcat.itheima.com<br>Rules:<br>Host              Path Backends<br>----              ---- --------<br>nginx.itheima.com  /  nginx-service:80 (10.244.1.97:80,10.244.1.98:80,10.244.2.119:80)<br>tomcat.itheima.com /  tomcat-service:8080(10.244.1.99:8080,10.244.2.117:8080,10.244.2.120:8080)<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下面可以通过浏览器访问https://nginx.itheima.com:31335 和 https://tomcat.itheima.com:31335来查看了</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-Pod控制器详解</title>
    <link href="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-Pod控制器详解"><a href="#Kubernetes-Pod控制器详解" class="headerlink" title="Kubernetes-Pod控制器详解"></a>Kubernetes-Pod控制器详解</h1><h2 id="1-Pod控制器介绍"><a href="#1-Pod控制器介绍" class="headerlink" title="1. Pod控制器介绍"></a>1. Pod控制器介绍</h2><p>Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：</p><ul><li>自主式Pod：Kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建</li><li>控制器创建的Pod：Kubernetes通过控制器创建的Pod，这种Pod删除之后还会自动重建</li></ul><p>Pod控制器是管理Pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p><p>在Kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p><ul><li>ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代</li><li>RepilcateSet：保证副本数量一直维持在期望值，并支持Pod数量扩缩容，镜像版本升级</li><li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</li><li>Horizontal Pod Autoscaler：可以根据集群负载水平自动调整Pod的数量，实现削峰填谷</li><li>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</li><li>Job：它创建出来的Pod只要完成任务就立即退出，不需要重建或重启，用于执行一次性任务</li><li>CronJob：它创建的Pod负责周期性任务控制，不需要持续后台运行</li><li>StatefulSet：管理有状态应用</li></ul><h2 id="2-ReplicaSet-RS"><a href="#2-ReplicaSet-RS" class="headerlink" title="2. ReplicaSet(RS)"></a>2. ReplicaSet(RS)</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>ReplicaSet的主要作用是<strong>保证一定数量的pod正常运行</strong>，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</p><img src="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20200612005334159.png" class="" title="image-20200612005334159"><p>ReplicaSet的资源清单文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">rs</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 副本数量</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>在这里面，需要新了解的配置项就是<code>spec</code>下面几个选项：</p><ul><li><p>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</p></li><li><p>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</p></li><li><p>template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是pod的定义</p></li></ul><h3 id="2-2-创建ReplicaSet"><a href="#2-2-创建ReplicaSet" class="headerlink" title="2.2 创建ReplicaSet"></a>2.2 创建ReplicaSet</h3><p>创建pc-replicaset.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span>   <br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-replicaset</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span> <br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建rs</span><br>[root@master ~]# kubectl create -f pc-replicaset.yaml<br>replicaset.apps/pc-replicaset created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看rs</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">DESIRED:期望副本数量</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">CURRENT:当前副本数量</span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">READY:已经准备好提供服务的副本数量</span><br>[root@master ~]# kubectl get rs pc-replicaset -n dev -o wide<br>NAME            DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         SELECTOR<br>pc-replicaset   3         3         3       3m59s   nginx        nginx:1.17.1   app=nginx-pod<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前控制器创建出来的pod</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码</span><br>[root@master ~]# kubectl get pods -n dev            <br>NAME                  READY   STATUS    RESTARTS   AGE<br>pc-replicaset-gqchm   1/1     Running   0          4m36s<br>pc-replicaset-hcsq2   1/1     Running   0          4m36s<br>pc-replicaset-ppfkv   1/1     Running   0          4m36s<br></code></pre></td></tr></table></figure><h3 id="2-3-扩缩容"><a href="#2-3-扩缩容" class="headerlink" title="2.3 扩缩容"></a>2.3 扩缩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑rs的副本数量，修改spec:replicas: 6即可</span><br>[root@master ~]# kubectl edit rs pc-replicaset -n dev<br>replicaset.apps/pc-replicaset edited<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods -n dev<br>NAME                  READY   STATUS    RESTARTS   AGE<br>pc-replicaset-5wmpw   1/1     Running   0          45s<br>pc-replicaset-gpdsf   1/1     Running   0          45s<br>pc-replicaset-gqchm   1/1     Running   0          17m<br>pc-replicaset-hcsq2   1/1     Running   0          17m<br>pc-replicaset-ppfkv   1/1     Running   0          17m<br>pc-replicaset-zrpsn   1/1     Running   0          45s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以直接使用命令实现</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可</span><br>[root@master ~]# kubectl scale rs pc-replicaset  --replicas=2 -n dev<br>replicaset.apps/pc-replicaset scaled<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令运行完毕，立即查看，发现已经有4个开始准备退出了</span><br>[root@master ~]# kubectl get pods -n dev                            <br>NAME                  READY   STATUS        RESTARTS   AGE<br>pc-replicaset-5wmpw   1/1     Terminating   0          2m14s<br>pc-replicaset-gpdsf   1/1     Terminating   0          2m14s<br>pc-replicaset-gqchm   0/1     Terminating   0          19m<br>pc-replicaset-hcsq2   1/1     Running       0          19m<br>pc-replicaset-ppfkv   1/1     Running       0          19m<br>pc-replicaset-zrpsn   1/1     Terminating   0          2m14s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">稍等片刻，就只剩两个了</span><br>[root@master ~]# kubectl get pods -n dev<br>NAME                  READY   STATUS    RESTARTS   AGE<br>pc-replicaset-hcsq2   1/1     Running   0          19m<br>pc-replicaset-ppfkv   1/1     Running   0          19m<br></code></pre></td></tr></table></figure><h3 id="2-4-镜像升级"><a href="#2-4-镜像升级" class="headerlink" title="2.4 镜像升级"></a>2.4 镜像升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑rs的容器镜像 - image: nginx:1.17.2</span><br>[root@master ~]# kubectl edit rs pc-replicaset -n dev<br>replicaset.apps/pc-replicaset edited<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看，发现镜像版本已经变了</span><br>[root@master ~]# kubectl get rs pc-replicaset -n dev -o wide<br>NAME            DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES         SELECTOR<br>pc-replicaset   2         2         2       24m   nginx        nginx:1.17.2   app=nginx-pod<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以使用命令完成这个工作</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image rs rs名称 容器=镜像版本 -n namespace</span><br>[root@master ~]# kubectl set image rs pc-replicaset nginx=nginx:1.17.1 -n dev<br>replicaset.apps/pc-replicaset image updated<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看，发现镜像版本已经变更了</span><br>[root@master ~]# kubectl get rs pc-replicaset -n dev -o wide<br>NAME            DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES         SELECTOR<br>pc-replicaset   2         2         2       26m   nginx        nginx:1.17.1   app=nginx-pod<br></code></pre></td></tr></table></figure><h3 id="2-5-删除ReplicaSet"><a href="#2-5-删除ReplicaSet" class="headerlink" title="2.5 删除ReplicaSet"></a>2.5 删除ReplicaSet</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用kubectl delete命令会删除此RS以及它管理的Pod</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除</span><br>[root@master ~]# kubectl delete rs pc-replicaset -n dev<br>replicaset.apps &quot;pc-replicaset&quot; deleted<br>[root@master ~]# kubectl get pod -n dev -o wide<br>No resources found in dev namespace.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=<span class="hljs-literal">false</span>选项（不推荐）。</span><br>[root@master ~]# kubectl delete rs pc-replicaset -n dev --cascade=false<br>replicaset.apps &quot;pc-replicaset&quot; deleted<br>[root@master ~]# kubectl get pods -n dev<br>NAME                  READY   STATUS    RESTARTS   AGE<br>pc-replicaset-cl82j   1/1     Running   0          75s<br>pc-replicaset-dslhb   1/1     Running   0          75s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以使用yaml直接删除(推荐)</span><br>[root@master ~]# kubectl delete -f pc-replicaset.yaml<br>replicaset.apps &quot;pc-replicaset&quot; deleted<br></code></pre></td></tr></table></figure><h2 id="3-Deployment-Deploy"><a href="#3-Deployment-Deploy" class="headerlink" title="3. Deployment(Deploy)"></a>3. Deployment(Deploy)</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>为了更好的解决服务编排的问题，kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。</p><img src="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20200612005524778.png" class="" title="image-20200612005524778"><p>Deployment主要功能有下面几个：</p><ul><li>支持ReplicaSet的所有功能</li><li>支持发布的停止、继续</li><li>支持滚动升级和回滚版本</li></ul><p>Deployment的资源清单文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">deploy</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 副本数量</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 保留历史版本</span><br>  <span class="hljs-attr">paused:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 暂停部署，默认是false</span><br>  <span class="hljs-attr">progressDeadlineSeconds:</span> <span class="hljs-number">600</span> <span class="hljs-comment"># 部署超时时间（s），默认是600</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-comment"># 策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span> <span class="hljs-comment"># 滚动更新策略</span><br>    <span class="hljs-attr">rollingUpdate:</span> <span class="hljs-comment"># 滚动更新</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">30</span><span class="hljs-string">%</span> <span class="hljs-comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">30</span><span class="hljs-string">%</span> <span class="hljs-comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="3-2-创建Deployment"><a href="#3-2-创建Deployment" class="headerlink" title="3.2 创建Deployment"></a>3.2 创建Deployment</h3><p>创建pc-deployment.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>      <br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-deployment</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span> <br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建deployment</span><br>[root@master ~]# kubectl create -f pc-deployment.yaml<br>deployment.apps/pc-deployment created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看deployment</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">UP-TO-DATE 最新版本的pod的数量</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">AVAILABLE  当前可用的pod的数量</span><br>[root@master ~]# kubectl get deploy -n dev -o wide<br>NAME            READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR<br>pc-deployment   3/3     3            3           11s   nginx        nginx:1.17.1   app=nginx-pod<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串</span><br>[root@master ~]# kubectl get rs -n dev -o wide<br>NAME                       DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES         SELECTOR<br>pc-deployment-858db84f89   3         3         3       55s   nginx        nginx:1.17.1   app=nginx-pod,pod-template-hash=858db84f89<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods -n dev<br>NAME                             READY   STATUS    RESTARTS   AGE<br>pc-deployment-858db84f89-4tqcr   1/1     Running   0          102s<br>pc-deployment-858db84f89-krs8x   1/1     Running   0          102s<br>pc-deployment-858db84f89-zxnvt   1/1     Running   0          102s<br></code></pre></td></tr></table></figure><h3 id="3-3-扩缩容"><a href="#3-3-扩缩容" class="headerlink" title="3.3 扩缩容"></a>3.3 扩缩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">变更副本数量为5个</span><br>[root@master ~]# kubectl scale deploy pc-deployment --replicas=5 -n dev<br>deployment.apps/pc-deployment scaled<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看deployment</span><br>[root@master ~]# kubectl get deploy pc-deployment -n dev<br>NAME            READY   UP-TO-DATE   AVAILABLE   AGE<br>pc-deployment   5/5     5            5           4m47s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods -n dev<br>NAME                             READY   STATUS    RESTARTS   AGE<br>pc-deployment-858db84f89-4tqcr   1/1     Running   0          3m49s<br>pc-deployment-858db84f89-krs8x   1/1     Running   0          3m49s<br>pc-deployment-858db84f89-pc7nj   1/1     Running   0          24s<br>pc-deployment-858db84f89-rlnm8   1/1     Running   0          24s<br>pc-deployment-858db84f89-zxnvt   1/1     Running   0          3m49s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑deployment的副本数量，修改spec:replicas: 4即可</span><br>[root@master ~]# kubectl edit deploy pc-deployment -n dev<br>deployment.apps/pc-deployment edited<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods -n dev                 <br>NAME                             READY   STATUS    RESTARTS   AGE<br>pc-deployment-858db84f89-4tqcr   1/1     Running   0          5m40s<br>pc-deployment-858db84f89-krs8x   1/1     Running   0          5m40s<br>pc-deployment-858db84f89-pc7nj   1/1     Running   0          2m15s<br>pc-deployment-858db84f89-zxnvt   1/1     Running   0          5m40s<br></code></pre></td></tr></table></figure><h3 id="3-4-镜像更新"><a href="#3-4-镜像更新" class="headerlink" title="3.4 镜像更新"></a>3.4 镜像更新</h3><h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h4><p>deployment支持两种更新策略:<strong>重建更新和滚动更新</strong>,可以通过<code>strategy</code>指定策略类型,支持两个属性:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">strategy：指定新的Pod替换旧的Pod的策略，</span> <span class="hljs-string">支持两个属性：</span><br>  <span class="hljs-string">type：指定策略类型，支持两种策略</span><br>    <span class="hljs-string">Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod</span><br>    <span class="hljs-string">RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod</span><br>  <span class="hljs-string">rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：</span><br>    <span class="hljs-string">maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。</span><br>    <span class="hljs-string">maxSurge：</span> <span class="hljs-string">用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</span><br></code></pre></td></tr></table></figure><h4 id="3-4-2-重建更新"><a href="#3-4-2-重建更新" class="headerlink" title="3.4.2 重建更新"></a>3.4.2 重建更新</h4><p>编辑pc-deployment.yaml,在spec节点下添加更新策略</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-comment"># 策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span> <span class="hljs-comment"># 重建更新</span><br></code></pre></td></tr></table></figure><p>创建deploy进行验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">变更镜像</span><br>[root@master ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n dev<br>deployment.apps/pc-deployment image updated<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">观察升级状态</span><br>[root@master ~]# kubectl get pods -n dev -w<br>NAME                             READY   STATUS    RESTARTS   AGE<br>pc-deployment-858db84f89-4tqcr   1/1     Running   0          141m<br>pc-deployment-858db84f89-krs8x   1/1     Running   0          141m<br>pc-deployment-858db84f89-zxnvt   1/1     Running   0          141m<br>pc-deployment-858db84f89-zxnvt   1/1     Terminating   0          141m<br>pc-deployment-858db84f89-krs8x   1/1     Terminating   0          141m<br>pc-deployment-858db84f89-4tqcr   1/1     Terminating   0          141m<br>pc-deployment-6c78d7875b-dsgrz   0/1     Pending       0          0s<br>pc-deployment-6c78d7875b-gbgvx   0/1     Pending       0          0s<br>pc-deployment-6c78d7875b-7c642   0/1     Pending       0          0s<br>pc-deployment-6c78d7875b-7c642   0/1     ContainerCreating   0          0s<br>pc-deployment-6c78d7875b-gbgvx   0/1     ContainerCreating   0          0s<br>pc-deployment-6c78d7875b-dsgrz   0/1     ContainerCreating   0          0s<br>pc-deployment-6c78d7875b-gbgvx   1/1     Running             0          41s<br>pc-deployment-6c78d7875b-dsgrz   1/1     Running             0          46s<br>pc-deployment-6c78d7875b-7c642   1/1     Running             0          61s<br></code></pre></td></tr></table></figure><h4 id="3-4-3-滚动更新"><a href="#3-4-3-滚动更新" class="headerlink" title="3.4.3 滚动更新"></a>3.4.3 滚动更新</h4><p>编辑pc-deployment.yaml,在spec节点下添加更新策略</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-comment"># 策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span> <span class="hljs-comment"># 滚动更新策略</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">25</span><span class="hljs-string">%</span> <br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">25</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure><p>创建deploy进行验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">变更镜像</span><br>[root@master ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev <br>deployment.apps/pc-deployment image updated<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">观察升级过程</span><br>[root@master ~]# kubectl get pods -n dev -w<br>NAME                           READY   STATUS    RESTARTS   AGE<br>pc-deployment-c848d767-8rbzt   1/1     Running   0          31m<br>pc-deployment-c848d767-h4p68   1/1     Running   0          31m<br>pc-deployment-c848d767-hlmz4   1/1     Running   0          31m<br>pc-deployment-c848d767-rrqcn   1/1     Running   0          31m<br><br>pc-deployment-966bf7f44-226rx   0/1     Pending             0          0s<br>pc-deployment-966bf7f44-226rx   0/1     ContainerCreating   0          0s<br>pc-deployment-966bf7f44-226rx   1/1     Running             0          1s<br>pc-deployment-c848d767-h4p68    0/1     Terminating         0          34m<br><br>pc-deployment-966bf7f44-cnd44   0/1     Pending             0          0s<br>pc-deployment-966bf7f44-cnd44   0/1     ContainerCreating   0          0s<br>pc-deployment-966bf7f44-cnd44   1/1     Running             0          2s<br>pc-deployment-c848d767-hlmz4    0/1     Terminating         0          34m<br><br>pc-deployment-966bf7f44-px48p   0/1     Pending             0          0s<br>pc-deployment-966bf7f44-px48p   0/1     ContainerCreating   0          0s<br>pc-deployment-966bf7f44-px48p   1/1     Running             0          0s<br>pc-deployment-c848d767-8rbzt    0/1     Terminating         0          34m<br><br>pc-deployment-966bf7f44-dkmqp   0/1     Pending             0          0s<br>pc-deployment-966bf7f44-dkmqp   0/1     ContainerCreating   0          0s<br>pc-deployment-966bf7f44-dkmqp   1/1     Running             0          2s<br>pc-deployment-c848d767-rrqcn    0/1     Terminating         0          34m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">至此，新版本的pod创建完毕，就版本的pod销毁完毕</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中间过程是滚动进行的，也就是边销毁边创建</span><br></code></pre></td></tr></table></figure><p>滚动更新的过程：</p><img src="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20200416140251491.png" class="" title="image-20200416140251491"><p>镜像更新中rs的变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其实这就是deployment能够进行版本回退的奥妙所在</span><br>[root@master ~]# kubectl get rs -n dev<br>NAME                       DESIRED   CURRENT   READY   AGE<br>pc-deployment-57df6f8b8c   3         3         3       10m<br>pc-deployment-6c78d7875b   0         0         0       15m<br>pc-deployment-858db84f89   0         0         0       157m<br></code></pre></td></tr></table></figure><h3 id="3-5-版本回退"><a href="#3-5-版本回退" class="headerlink" title="3.5 版本回退"></a>3.5 版本回退</h3><p>deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.</p><p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p><ul><li>status 显示当前升级状态</li><li>history 显示 升级历史记录</li><li>pause 暂停版本升级过程</li><li>resume 继续已经暂停的版本升级过程</li><li>restart 重启版本升级过程</li><li>undo 回滚到上一级版本（可以使用–to-revision回滚到指定版本）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前升级版本的状态</span><br>[root@master ~]# kubectl rollout status deploy pc-deployment -n dev<br>deployment &quot;pc-deployment&quot; successfully rolled out<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看升级历史记录</span><br>[root@master ~]# kubectl rollout history deploy pc-deployment -n dev<br>deployment.apps/pc-deployment<br>REVISION  CHANGE-CAUSE<br>1         kubectl create --filename=pc-deployment.yaml --record=true<br>2         kubectl create --filename=pc-deployment.yaml --record=true<br>3         kubectl create --filename=pc-deployment.yaml --record=true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以发现有三次版本记录，说明完成过两次升级</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">版本回退</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里直接使用--to-revision=1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本</span><br>[root@master ~]# kubectl rollout undo deploy pc-deployment --to-revision=2 -n dev<br>deployment.apps/pc-deployment rolled back<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看rs，发现第一个rs中有3个pod运行，后面两个版本的rs中没有pod运行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了</span><br>[root@master ~]# kubectl get deploy,rs -n dev                                 <br>NAME                            READY   UP-TO-DATE   AVAILABLE   AGE<br>deployment.apps/pc-deployment   3/3     3            3           161m<br><br>NAME                                       DESIRED   CURRENT   READY   AGE<br>replicaset.apps/pc-deployment-57df6f8b8c   0         0         0       14m<br>replicaset.apps/pc-deployment-6c78d7875b   3         3         3       19m<br>replicaset.apps/pc-deployment-858db84f89   0         0         0       161m<br></code></pre></td></tr></table></figure><h3 id="3-6-金丝雀发布"><a href="#3-6-金丝雀发布" class="headerlink" title="3.6 金丝雀发布"></a>3.6 金丝雀发布</h3><p>Deployment控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。</p><p>比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新deployment的版本，并配置暂停deployment</span><br>[root@master ~]#  kubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deployment pc-deployment  -n dev<br>deployment.apps/pc-deployment image updated<br>deployment.apps/pc-deployment paused<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">观察更新状态</span><br>[root@master ~]# kubectl rollout status deploy pc-deployment -n dev　<br>Waiting for deployment &quot;pc-deployment&quot; rollout to finish: 2 out of 4 new replicas have been updated...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令</span><br><br>[root@master ~]# kubectl get rs -n dev -o wide<br>NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         <br>pc-deployment-5d89bdfbf9   3         3         3       19m     nginx        nginx:1.17.1   <br>pc-deployment-675d469f8b   0         0         0       14m     nginx        nginx:1.17.2   <br>pc-deployment-6c9f56fcfb   2         2         2       3m16s   nginx        nginx:1.17.4   <br>[root@master ~]# kubectl get pods -n dev<br>NAME                             READY   STATUS    RESTARTS   AGE<br>pc-deployment-5d89bdfbf9-rj8sq   1/1     Running   0          7m33s<br>pc-deployment-5d89bdfbf9-ttwgg   1/1     Running   0          7m35s<br>pc-deployment-5d89bdfbf9-v4wvc   1/1     Running   0          7m34s<br>pc-deployment-6c9f56fcfb-996rt   1/1     Running   0          3m31s<br>pc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          3m31s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保更新的pod没问题了，继续更新</span><br>[root@master ~]# kubectl rollout resume deploy pc-deployment -n dev<br>deployment.apps/pc-deployment resumed<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看最后的更新情况</span><br>[root@master ~]# kubectl get rs -n dev -o wide<br>NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         <br>pc-deployment-5d89bdfbf9   0         0         0       21m     nginx        nginx:1.17.1   <br>pc-deployment-675d469f8b   0         0         0       16m     nginx        nginx:1.17.2   <br>pc-deployment-6c9f56fcfb   4         4         4       5m11s   nginx        nginx:1.17.4   <br><br>[root@master ~]# kubectl get pods -n dev<br>NAME                             READY   STATUS    RESTARTS   AGE<br>pc-deployment-6c9f56fcfb-7bfwh   1/1     Running   0          37s<br>pc-deployment-6c9f56fcfb-996rt   1/1     Running   0          5m27s<br>pc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          5m27s<br>pc-deployment-6c9f56fcfb-rf84v   1/1     Running   0          37s<br></code></pre></td></tr></table></figure><h3 id="3-7-删除Deployment"><a href="#3-7-删除Deployment" class="headerlink" title="3.7 删除Deployment"></a>3.7 删除Deployment</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除deployment，其下的rs和pod也将被删除</span><br>[root@master ~]# kubectl delete -f pc-deployment.yaml<br>deployment.apps &quot;pc-deployment&quot; deleted<br></code></pre></td></tr></table></figure><h2 id="4-Horizontal-Pod-Autoscaler（HPA）"><a href="#4-Horizontal-Pod-Autoscaler（HPA）" class="headerlink" title="4. Horizontal Pod Autoscaler（HPA）"></a>4. Horizontal Pod Autoscaler（HPA）</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>通过手工执行<code>kubectl scale</code>命令实现Pod扩容或缩容，这显然不符合Kubernetes的定位目标–自动化、智能化。 Kubernetes期望可以实现通过监测Pod的使用情况，实现pod数量的自动调整，于是就产生了Horizontal Pod Autoscaler（HPA）这种控制器。</p><p>HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理</p><img src="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20200608155858271.png" class="" title="image-20200608155858271"><h3 id="4-2-安装metricds-server"><a href="#4-2-安装metricds-server" class="headerlink" title="4.2 安装metricds-server"></a>4.2 安装metricds-server</h3><p>metrics-server可以用来收集集群中的资源使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装git</span><br>[root@master ~]# yum install git -y<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取metrics-server, 注意使用的版本</span><br>[root@master ~]# git clone -b v0.3.6 https://github.com/kubernetes-incubator/metrics-server<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改deployment, 注意修改的是镜像和初始化参数</span><br>[root@master ~]# cd /root/metrics-server/deploy/1.8+/<br>[root@master 1.8+]# vim metrics-server-deployment.yaml<br>按图中添加下面选项<br>hostNetwork: true<br>image: registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6<br>args:<br>- --kubelet-insecure-tls<br>- --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP<br></code></pre></td></tr></table></figure><img src="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20200608163326496-1629594082953.png" class="" title="image-20200608163326496"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装metrics-server</span><br>[root@master 1.8+]# kubectl apply -f ./<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod运行情况</span><br>[root@master 1.8+]# kubectl get pod -n kube-system<br>metrics-server-5f55b696bd-jskkp            1/1     Running   0          13s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用kubectl top node 查看资源使用情况</span><br>[root@master 1.8+]# kubectl top node<br>NAME     CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%   <br>master   489m         24%    1294Mi          75%       <br>node01   101m         5%     870Mi           50%       <br>node02   103m         5%     820Mi           47%<br>[root@k8s-master01 1.8+]# kubectl top pod -n kube-system<br>NAME                              CPU(cores)   MEMORY(bytes)<br>coredns-6955765f44-7ptsb          3m           9Mi<br>coredns-6955765f44-vcwr5          3m           8Mi<br>etcd-master                       14m          145Mi<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">至此,metrics-server安装完成</span><br></code></pre></td></tr></table></figure><h3 id="4-3-准备Deployment和Service"><a href="#4-3-准备Deployment和Service" class="headerlink" title="4.3 准备Deployment和Service"></a>4.3 准备Deployment和Service</h3><p>创建pc-hpa-pod.yaml文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span> <span class="hljs-comment"># 类型</span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># deployment的名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 命名类型</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详细描述</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器可以管理哪些Pod</span><br>    <span class="hljs-attr">matchLabels:</span> <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模块 当副本数据不足的时候，会根据下面的模板创建Pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 容器名称</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span> <span class="hljs-comment"># 容器需要的镜像地址</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 容器所监听的端口</span><br>          <span class="hljs-attr">resources:</span> <span class="hljs-comment"># 资源限制</span><br>            <span class="hljs-attr">requests:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;100m&quot;</span> <span class="hljs-comment"># 100m表示100millicpu，即0.1个CPU</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建deployment</span><br>[root@master ~]# kubectl create -f pc-hpa-pod.yaml<br>deployment.apps/nginx created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看deployment和pod</span><br>[root@master ~]# kubectl get pod,deploy -n dev<br>NAME                         READY   STATUS    RESTARTS   AGE<br>pod/nginx-587f44948f-6pcfg   1/1     Running   0          18s<br><br>NAME                    READY   UP-TO-DATE   AVAILABLE   AGE<br>deployment.apps/nginx   1/1     1            1           19s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建service</span><br>[root@master ~]# kubectl expose deployment nginx --name=nginx --type=NodePort --port=80 -n dev<br>service/nginx exposed<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看</span><br>[root@master ~]# kubectl get deploy,pod,svc -n dev<br>NAME                    READY   UP-TO-DATE   AVAILABLE   AGE<br>deployment.apps/nginx   1/1     1            1           119s<br><br>NAME                         READY   STATUS    RESTARTS   AGE<br>pod/nginx-587f44948f-6pcfg   1/1     Running   0          118s<br><br>NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE<br>service/nginx   NodePort   10.96.241.211   &lt;none&gt;        80:31113/TCP   13s<br></code></pre></td></tr></table></figure><h3 id="4-4-配置HPA"><a href="#4-4-配置HPA" class="headerlink" title="4.4 配置HPA"></a>4.4 配置HPA</h3><p>创建pc-hpa.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">autoscaling/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">HorizontalPodAutoscaler</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-hpa</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">minReplicas:</span> <span class="hljs-number">1</span>  <span class="hljs-comment">#最小pod数量</span><br>  <span class="hljs-attr">maxReplicas:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#最大pod数量</span><br>  <span class="hljs-attr">targetCPUUtilizationPercentage:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># CPU使用率指标</span><br>  <span class="hljs-attr">scaleTargetRef:</span>   <span class="hljs-comment"># 指定要控制的nginx信息</span><br>    <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建hpa</span><br>[root@master ~]# kubectl create -f pc-hpa.yaml<br>horizontalpodautoscaler.autoscaling/pc-hpa created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看hpa</span><br>[root@master ~]# kubectl get hpa -n dev<br>NAME     REFERENCE          TARGETS        MINPODS   MAXPODS   REPLICAS   AGE<br>pc-hpa   Deployment/nginx   &lt;unknown&gt;/3%   1         10        0          7s<br></code></pre></td></tr></table></figure><h3 id="4-5-测试"><a href="#4-5-测试" class="headerlink" title="4.5 测试"></a>4.5 测试</h3><p>使用压测工具对service地址<code>192.168.249.100:31113</code>进行压测，然后通过控制台查看hpa和pod的变化</p><p>hpa变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get hpa -n dev -w<br>NAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE<br>pc-hpa   Deployment/nginx   0%/3%     1         10        1          106s<br>pc-hpa   Deployment/nginx   0%/3%     1         10        1          5m49s<br>pc-hpa   Deployment/nginx   6%/3%     1         10        1          6m4s<br>pc-hpa   Deployment/nginx   6%/3%     1         10        2          6m19s<br>pc-hpa   Deployment/nginx   14%/3%    1         10        2          7m5s<br>pc-hpa   Deployment/nginx   14%/3%    1         10        4          7m20s<br>pc-hpa   Deployment/nginx   14%/3%    1         10        8          7m36s<br>pc-hpa   Deployment/nginx   14%/3%    1         10        10         7m51s<br>pc-hpa   Deployment/nginx   0%/3%     1         10        10         8m6s<br></code></pre></td></tr></table></figure><p>depolyment变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deploy -n dev -w<br>NAME    READY   UP-TO-DATE   AVAILABLE   AGE<br>nginx   1/1     1            1           3m20s<br>nginx   1/2     1            1           8m2s<br>nginx   1/2     1            1           8m2s<br>nginx   1/2     1            1           8m2s<br>nginx   1/2     2            1           8m3s<br>nginx   2/2     2            2           8m4s<br>nginx   2/4     2            2           9m3s<br>nginx   2/4     2            2           9m3s<br>nginx   2/4     2            2           9m3s<br>nginx   2/4     4            2           9m3s<br>nginx   3/4     4            3           9m4s<br>nginx   4/4     4            4           9m5s<br>nginx   4/8     4            4           9m18s<br>nginx   4/8     4            4           9m18s<br>nginx   4/8     4            4           9m18s<br>nginx   4/8     8            4           9m18s<br>nginx   5/8     8            5           9m19s<br>nginx   6/8     8            6           9m20s<br>nginx   7/8     8            7           9m20s<br>nginx   8/8     8            8           9m21s<br>nginx   8/10    8            8           9m34s<br>nginx   8/10    8            8           9m34s<br>nginx   8/10    8            8           9m34s<br>nginx   8/10    10           8           9m34s<br>nginx   9/10    10           9           9m35s<br>nginx   10/10   10           10          9m36<br></code></pre></td></tr></table></figure><p>pod变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pods -n dev -w<br>NAME                     READY   STATUS    RESTARTS   AGE<br>nginx-587f44948f-87dnf   1/1     Running   0          3m32s<br>nginx-587f44948f-qtpv2   0/1     Pending   0          0s<br>nginx-587f44948f-qtpv2   0/1     Pending   0          1s<br>nginx-587f44948f-qtpv2   0/1     ContainerCreating   0          1s<br>nginx-587f44948f-qtpv2   0/1     ContainerCreating   0          1s<br>nginx-587f44948f-qtpv2   1/1     Running             0          2s<br>nginx-587f44948f-dch4x   0/1     Pending             0          0s<br>nginx-587f44948f-dch4x   0/1     Pending             0          0s<br>nginx-587f44948f-q75dc   0/1     Pending             0          0s<br>nginx-587f44948f-q75dc   0/1     Pending             0          0s<br>nginx-587f44948f-dch4x   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-q75dc   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-dch4x   0/1     ContainerCreating   0          1s<br>nginx-587f44948f-q75dc   0/1     ContainerCreating   0          1s<br>nginx-587f44948f-q75dc   1/1     Running             0          1s<br>nginx-587f44948f-dch4x   1/1     Running             0          2s<br>nginx-587f44948f-pwct2   0/1     Pending             0          0s<br>nginx-587f44948f-pwct2   0/1     Pending             0          0s<br>nginx-587f44948f-mdkbm   0/1     Pending             0          0s<br>nginx-587f44948f-6c9q4   0/1     Pending             0          0s<br>nginx-587f44948f-hqd7n   0/1     Pending             0          0s<br>nginx-587f44948f-mdkbm   0/1     Pending             0          0s<br>nginx-587f44948f-6c9q4   0/1     Pending             0          0s<br>nginx-587f44948f-hqd7n   0/1     Pending             0          0s<br>nginx-587f44948f-pwct2   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-mdkbm   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-6c9q4   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-hqd7n   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-pwct2   0/1     ContainerCreating   0          1s<br>nginx-587f44948f-6c9q4   0/1     ContainerCreating   0          1s<br>nginx-587f44948f-mdkbm   0/1     ContainerCreating   0          1s<br>nginx-587f44948f-hqd7n   0/1     ContainerCreating   0          1s<br>nginx-587f44948f-mdkbm   1/1     Running             0          1s<br>nginx-587f44948f-pwct2   1/1     Running             0          2s<br>nginx-587f44948f-6c9q4   1/1     Running             0          2s<br>nginx-587f44948f-hqd7n   1/1     Running             0          2s<br>nginx-587f44948f-pvzrc   0/1     Pending             0          0s<br>nginx-587f44948f-pvzrc   0/1     Pending             0          0s<br>nginx-587f44948f-h2m6k   0/1     Pending             0          0s<br>nginx-587f44948f-h2m6k   0/1     Pending             0          0s<br>nginx-587f44948f-pvzrc   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-h2m6k   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-pvzrc   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-h2m6k   0/1     ContainerCreating   0          0s<br>nginx-587f44948f-pvzrc   1/1     Running             0          1s<br>nginx-587f44948f-h2m6k   1/1     Running             0          2s<br></code></pre></td></tr></table></figure><h2 id="5-DaemonSet-DS"><a href="#5-DaemonSet-DS" class="headerlink" title="5. DaemonSet(DS)"></a>5. DaemonSet(DS)</h2><p>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p><img src="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20200612010223537.png" class="" title="image-20200612010223537"><p>DaemonSet控制器的特点：</p><ul><li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li><li>当节点从集群中移除时，Pod 也就被垃圾回收了</li></ul><p>下面先来看下DaemonSet的资源清单文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">daemonset</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 保留历史版本</span><br>  <span class="hljs-attr">updateStrategy:</span> <span class="hljs-comment"># 更新策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span> <span class="hljs-comment"># 滚动更新策略</span><br>    <span class="hljs-attr">rollingUpdate:</span> <span class="hljs-comment"># 滚动更新</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>创建pc-daemonset.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span>      <br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-daemonset</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span> <br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建daemonset</span><br>[root@master ~]# kubectl create -f pc-daemonset.yaml  <br>daemonset.apps/pc-daemonset created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看daemonset</span><br>[root@master ~]# kubectl get ds pc-daemonset -n dev<br>NAME           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE<br>pc-daemonset   2         2         2       2            2           &lt;none&gt;          21s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod 发现在每个Node山都运行一个pod</span><br>[root@master ~]# kubectl get pod -n dev -o wide<br>NAME                     READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES<br>nginx-587f44948f-87dnf   1/1     Running   0          24m   10.244.140.99    node02   &lt;none&gt;           &lt;none&gt;<br>pc-daemonset-jrbtx       1/1     Running   0          42s   10.244.140.104   node02   &lt;none&gt;           &lt;none&gt;<br>pc-daemonset-vw7jb       1/1     Running   0          42s   10.244.196.174   node01   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除daemonset</span><br>[root@master ~]# kubectl delete -f pc-daemonset.yaml<br>daemonset.apps &quot;pc-daemonset&quot; delete<br></code></pre></td></tr></table></figure><h2 id="6-Job"><a href="#6-Job" class="headerlink" title="6. Job"></a>6. Job</h2><p>Job，主要用于负责**批量处理(一次要处理指定数量任务)<strong>短暂的</strong>一次性(每个任务仅运行一次就结束)**任务。Job特点如下：</p><ul><li>当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量</li><li>当成功结束的pod达到指定的数量时，Job将完成执行</li></ul><img src="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20200618213054113.png" class="" title="image-20200618213054113"><p>Job的资源清单文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">job</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 指定job需要成功运行Pods的次数。默认值: 1</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span><br>  <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">30</span> <span class="hljs-comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。</span><br>  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">6</span> <span class="hljs-comment"># 指定job失败后进行重试的次数。默认是6</span><br>  <span class="hljs-attr">manualSelector:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否可以使用selector选择器选择pod，默认是false</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">counter-pod</span>]&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span> <span class="hljs-comment"># 重启策略只能设置为Never或者OnFailure</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;</span>]<br></code></pre></td></tr></table></figure><p>关于重启策略设置的说明：</p><ul><li>如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变</li><li>如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1</li><li>如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always</li></ul><p>创建pc-job.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span>      <br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-job</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">manualSelector:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建job</span><br>[root@master ~]# kubectl create -f pc-job.yaml<br>job.batch/pc-job created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看job</span><br>[root@master ~]# kubectl get job -n dev -o wide -w<br>NAME     COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES         SELECTOR<br>pc-job   0/1           13s        13s   counter      busybox:1.30   app=counter-pod<br>pc-job   1/1           28s        28s   counter      busybox:1.30   app=counter-pod<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态</span><br>[root@master ~]# kubectl get pods -n dev -w<br>NAME                     READY   STATUS    RESTARTS   AGE<br>nginx-587f44948f-87dnf   1/1     Running   0          43m<br>pc-job-8h5nm             1/1     Running   0          26s<br>pc-job-8h5nm             0/1     Completed   0          28s<br>pc-job-8h5nm             0/1     Completed   0          28s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> completions: 6 <span class="hljs-comment"># 指定job需要成功运行Pods的次数为6</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> parallelism: 3 <span class="hljs-comment"># 指定job并发运行Pods的数量为3</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> 然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除job</span><br>[root@master ~]# kubectl delete -f pc-job.yaml<br>job.batch &quot;pc-job&quot; deleted<br></code></pre></td></tr></table></figure><h2 id="7-CronJob-CJ"><a href="#7-CronJob-CJ" class="headerlink" title="7. CronJob(CJ)"></a>7. CronJob(CJ)</h2><p>CronJob控制器以Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行<strong>时间点</strong>及<strong>重复运行</strong>的方式。也就是说，<strong>CronJob可以在特定的时间点(反复的)去运行job任务</strong>。</p><img src="/2021/08/20/Kubernetes-Pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20200618213149531.png" class="" title="image-20200618213149531"><p>CronJob的资源清单文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1beta1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">cronjob</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span><br>  <span class="hljs-attr">concurrencyPolicy:</span> <span class="hljs-comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span><br>  <span class="hljs-attr">failedJobHistoryLimit:</span> <span class="hljs-comment"># 为失败的任务执行保留的历史记录数，默认为1</span><br>  <span class="hljs-attr">successfulJobHistoryLimit:</span> <span class="hljs-comment"># 为成功的任务执行保留的历史记录数，默认为3</span><br>  <span class="hljs-attr">startingDeadlineSeconds:</span> <span class="hljs-comment"># 启动作业错误的超时时长</span><br>  <span class="hljs-attr">jobTemplate:</span> <span class="hljs-comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span><br>    <span class="hljs-attr">metadata:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">completions:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">30</span><br>      <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">6</span><br>      <span class="hljs-attr">manualSelector:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">selector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>        <span class="hljs-attr">matchExpressions:</span> <span class="hljs-string">规则</span><br>          <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">counter-pod</span>]&#125;<br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">metadata:</span><br>          <span class="hljs-attr">labels:</span><br>            <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span> <br>          <span class="hljs-attr">containers:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>            <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>            <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">需要重点解释的几个选项：</span><br><span class="hljs-attr">schedule:</span> <span class="hljs-string">cron表达式，用于指定任务的执行时间</span><br>    <span class="hljs-string">*/1</span>    <span class="hljs-string">*</span>      <span class="hljs-string">*</span>    <span class="hljs-string">*</span>     <span class="hljs-string">*</span><br>    <span class="hljs-string">&lt;分钟&gt;</span> <span class="hljs-string">&lt;小时&gt;</span> <span class="hljs-string">&lt;日&gt;</span> <span class="hljs-string">&lt;月份&gt;</span> <span class="hljs-string">&lt;星期&gt;</span><br><br>    <span class="hljs-string">分钟</span> <span class="hljs-string">值从</span> <span class="hljs-number">0</span> <span class="hljs-string">到</span> <span class="hljs-number">59</span><span class="hljs-string">.</span><br>    <span class="hljs-string">小时</span> <span class="hljs-string">值从</span> <span class="hljs-number">0</span> <span class="hljs-string">到</span> <span class="hljs-number">23</span><span class="hljs-string">.</span><br>    <span class="hljs-string">日</span> <span class="hljs-string">值从</span> <span class="hljs-number">1</span> <span class="hljs-string">到</span> <span class="hljs-number">31</span><span class="hljs-string">.</span><br>    <span class="hljs-string">月</span> <span class="hljs-string">值从</span> <span class="hljs-number">1</span> <span class="hljs-string">到</span> <span class="hljs-number">12</span><span class="hljs-string">.</span><br>    <span class="hljs-string">星期</span> <span class="hljs-string">值从</span> <span class="hljs-number">0</span> <span class="hljs-string">到</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">0</span> <span class="hljs-string">代表星期日</span><br>    <span class="hljs-string">多个时间可以用逗号隔开；</span> <span class="hljs-string">范围可以用连字符给出；*可以作为通配符；</span> <span class="hljs-string">/表示每...</span><br><span class="hljs-attr">concurrencyPolicy:</span><br>    <span class="hljs-attr">Allow:</span>   <span class="hljs-string">允许Jobs并发运行(默认)</span><br>    <span class="hljs-attr">Forbid:</span>  <span class="hljs-string">禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行</span><br>    <span class="hljs-attr">Replace:</span> <span class="hljs-string">替换，取消当前正在运行的作业并用新作业替换它</span><br></code></pre></td></tr></table></figure><p>创建pc-cronjob.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-cronjob</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">cronjob</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-string">&quot;*/1 * * * *&quot;</span><br>  <span class="hljs-attr">jobTemplate:</span><br>    <span class="hljs-attr">metadata:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>          <span class="hljs-attr">containers:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>            <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>            <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建cronjob</span><br>[root@master ~]# kubectl create -f pc-cronjob.yaml<br>cronjob.batch/pc-cronjob created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看cronjob</span><br>[root@master ~]# kubectl get cj -n dev  <br>NAME         SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE<br>pc-cronjob   */1 * * * *   False     1        7s              45s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看job</span><br>[root@master ~]# kubectl get jobs -n dev -w<br>NAME                    COMPLETIONS   DURATION   AGE<br>pc-cronjob-1629600780   0/1           12s        12s<br>pc-cronjob-1629600780   1/1           29s        29s<br>pc-cronjob-1629600840   0/1                      0s<br>pc-cronjob-1629600840   0/1           0s         0s<br>pc-cronjob-1629600840   1/1           28s        28s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods -n dev -w<br>NAME                          READY   STATUS    RESTARTS   AGE<br>nginx-587f44948f-87dnf        1/1     Running   0          59m<br>pc-cronjob-1629600780-sswsk   1/1     Running   0          21s<br>pc-cronjob-1629600780-sswsk   0/1     Completed   0          29s<br>pc-cronjob-1629600780-sswsk   0/1     Completed   0          29s<br>pc-cronjob-1629600840-4jqp7   0/1     Pending     0          0s<br>pc-cronjob-1629600840-4jqp7   0/1     Pending     0          0s<br>pc-cronjob-1629600840-4jqp7   0/1     ContainerCreating   0          0s<br>pc-cronjob-1629600840-4jqp7   0/1     ContainerCreating   0          1s<br>pc-cronjob-1629600840-4jqp7   1/1     Running             0          1s<br>pc-cronjob-1629600840-4jqp7   0/1     Completed           0          28s<br>pc-cronjob-1629600840-4jqp7   0/1     Completed           0          28s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除cronjob</span><br>[root@master ~]# kubectl delete -f pc-cronjob.yaml<br>cronjob.batch &quot;pc-cronjob&quot; deleted<br></code></pre></td></tr></table></figure><h2 id="8-StatefullSet-有状态"><a href="#8-StatefullSet-有状态" class="headerlink" title="8. StatefullSet(有状态)"></a>8. StatefullSet(有状态)</h2><p>无状态应用：</p><ul><li>认为Pod都是一样的。</li><li>没有顺序要求。</li><li>不用考虑在哪个Node节点上运行。</li><li>随意进行伸缩和扩展。</li></ul><p>有状态应用：</p><ul><li>有顺序的要求。</li><li>认为每个Pod都是不一样的。</li><li>需要考虑在哪个Node节点上运行。</li><li>需要按照顺序进行伸缩和扩展。</li><li>让每个Pod都是独立的，保持Pod启动顺序和唯一性。</li></ul><p>StatefulSet是Kubernetes提供的管理有状态应用的负载管理控制器。</p><p>StatefulSet部署需要HeadLinessService（无头服务）。</p><p>为什么需要HeadLinessService（无头服务）？</p><ul><li>在用Deployment时，每一个Pod名称是没有顺序的，是随机字符串，因此是Pod名称是无序的，但是在StatefulSet中要求必须是有序 ，每一个Pod不能被随意取代，Pod重建后pod名称还是一样的。</li><li>而Pod IP是变化的，所以是以Pod名称来识别。Pod名称是Pod唯一性的标识符，必须持久稳定有效。这时候要用到无头服务，它可以给每个Pod一个唯一的名称 。</li></ul><p><strong>StatefulSet常用来部署RabbitMQ集群、Zookeeper集群、MySQL集群、Eureka集群等。</strong></p><p>创建pc-stateful.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-headliness</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span> <span class="hljs-comment"># 将clusterIP设置为None，即可创建headliness Service</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># Service的端口</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># Pod的端口</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-statefulset</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">service-headliness</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建StatefullSet</span><br>[root@master ~]# kubectl create -f pc-stateful.yaml <br>service/service-headliness created<br>statefulset.apps/pc-statefulset created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看StatefulSet</span><br>[root@master ~]# kubectl get statefulset pc-statefulset -n dev -o wide<br>NAME             READY   AGE   CONTAINERS   IMAGES<br>pc-statefulset   3/3     26s   nginx        nginx:1.17.1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod</span><br>[root@master ~]# kubectl get pods -n dev -o wide<br>NAME                     READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES<br>pc-statefulset-0         1/1     Running   0          49s   10.244.196.179   node01   &lt;none&gt;           &lt;none&gt;<br>pc-statefulset-1         1/1     Running   0          47s   10.244.140.105   node02   &lt;none&gt;           &lt;none&gt;<br>pc-statefulset-2         1/1     Running   0          45s   10.244.196.180   node01   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除StatefullSet</span><br>[root@master ~]# kubectl delete -f pc-stateful.yaml<br>service &quot;service-headliness&quot; deleted<br>statefulset.apps &quot;pc-statefulset&quot; deleted<br></code></pre></td></tr></table></figure><p><strong>Deployment和StatefulSet的区别</strong></p><ul><li><p>Deployment和StatefulSet的区别：Deployment没有唯一标识而StatefulSet有唯一标识。</p></li><li><p>StatefulSet的唯一标识是根据主机名+一定规则生成的。</p></li><li><p>StatefulSet的唯一标识是<code>主机名.无头Service名称.命名空间.svc.cluster.local</code>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-Pod详解</title>
    <link href="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-Pod详解"><a href="#Kubernetes-Pod详解" class="headerlink" title="Kubernetes-Pod详解"></a>Kubernetes-Pod详解</h1><h2 id="1-Pod的介绍"><a href="#1-Pod的介绍" class="headerlink" title="1. Pod的介绍"></a>1. Pod的介绍</h2><h3 id="1-1-Pod的结构"><a href="#1-1-Pod的结构" class="headerlink" title="1.1 Pod的结构"></a>1.1 Pod的结构</h3><img src="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/image-20200407121501907-1626781151898.png" class="" title="image-20200407121501907-1626781151898"><p>每个 Pod 中都可以包含一个或者多个容器，这些容器可以分为两类：</p><ul><li>用户程序所在的容器，数量可多可少</li><li>Pause 容器，这时每个 Pod 都会有的一个根容器，它的作用有两个：<ul><li>可以以它为依据，评估整个 Pod 的健康状态</li><li>可以在根容器上设置 IP 地址，其他容器都共享此 IP （Pod的IP），以实现Pod内部的网络通信（这里是Pod内部的通讯，Pod之间的通讯采用虚拟二层网络技术来实现，我们当前环境使用的是Flannel）。</li></ul></li></ul><h3 id="1-2-Pod定义"><a href="#1-2-Pod定义" class="headerlink" title="1.2 Pod定义"></a>1.2 Pod定义</h3><p>下面是 Pod 的资源清单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>     <span class="hljs-comment">#必选，版本号，例如v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>       　 <span class="hljs-comment">#必选，资源类型，例如 Pod</span><br><span class="hljs-attr">metadata:</span>       　 <span class="hljs-comment">#必选，元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#必选，Pod名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#Pod所属的命名空间,默认为&quot;default&quot;</span><br>  <span class="hljs-attr">labels:</span>       　　  <span class="hljs-comment">#自定义标签列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>      　          <br><span class="hljs-attr">spec:</span>  <span class="hljs-comment">#必选，Pod中容器的详细定义</span><br>  <span class="hljs-attr">containers:</span>  <span class="hljs-comment">#必选，Pod中容器列表</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>   <span class="hljs-comment">#必选，容器名称</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#必选，容器的镜像名称</span><br>    <span class="hljs-attr">imagePullPolicy:</span> [ <span class="hljs-string">Always|Never|IfNotPresent</span> ]  <span class="hljs-comment">#获取镜像的策略 </span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]   <span class="hljs-comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">string</span>]      <span class="hljs-comment">#容器的启动命令参数列表</span><br>    <span class="hljs-attr">workingDir:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#容器的工作目录</span><br>    <span class="hljs-attr">volumeMounts:</span>       <span class="hljs-comment">#挂载到容器内部的存储卷配置</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>      <span class="hljs-comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#存储卷在容器内mount的绝对路径，应少于512字符</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-string">boolean</span> <span class="hljs-comment">#是否为只读模式</span><br>    <span class="hljs-attr">ports:</span> <span class="hljs-comment">#需要暴露的端口库号列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>        <span class="hljs-comment">#端口的名称</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-string">int</span>  <span class="hljs-comment">#容器需要监听的端口号</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-string">int</span>       <span class="hljs-comment">#容器所在主机需要监听的端口号，默认与Container相同</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#端口协议，支持TCP和UDP，默认TCP</span><br>    <span class="hljs-attr">env:</span>   <span class="hljs-comment">#容器运行前需设置的环境变量列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#环境变量名称</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#环境变量的值</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-comment">#资源限制和请求的设置</span><br>      <span class="hljs-attr">limits:</span>  <span class="hljs-comment">#资源限制的设置</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span><br>      <span class="hljs-attr">requests:</span> <span class="hljs-comment">#资源请求的设置</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#Cpu请求，容器启动的初始可用数量</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#内存请求,容器启动的初始可用数量</span><br>    <span class="hljs-attr">lifecycle:</span> <span class="hljs-comment">#生命周期钩子</span><br>        <span class="hljs-attr">postStart:</span> <span class="hljs-comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span><br>        <span class="hljs-attr">preStop:</span> <span class="hljs-comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span><br>    <span class="hljs-attr">livenessProbe:</span>  <span class="hljs-comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span><br>      <span class="hljs-attr">exec:</span>       　 <span class="hljs-comment">#对Pod容器内检查方式设置为exec方式</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]  <span class="hljs-comment">#exec方式需要制定的命令或脚本</span><br>      <span class="hljs-attr">httpGet:</span>       <span class="hljs-comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">HttpHeaders:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">tcpSocket:</span>     <span class="hljs-comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span><br>         <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>       <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">0</span>       <span class="hljs-comment">#容器启动完成后首次探测的时间，单位为秒</span><br>       <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">0</span>    　　    <span class="hljs-comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br>       <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">0</span>     　　    <span class="hljs-comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br>       <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">0</span><br>       <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">0</span><br>       <span class="hljs-attr">securityContext:</span><br>         <span class="hljs-attr">privileged:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">restartPolicy:</span> [<span class="hljs-string">Always</span> <span class="hljs-string">|</span> <span class="hljs-string">Never</span> <span class="hljs-string">|</span> <span class="hljs-string">OnFailure</span>]  <span class="hljs-comment">#Pod的重启策略</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">&lt;string&gt;</span> <span class="hljs-comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span><br>  <span class="hljs-attr">nodeSelector:</span> <span class="hljs-string">obeject</span> <span class="hljs-comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span><br>  <span class="hljs-attr">imagePullSecrets:</span> <span class="hljs-comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br>  <span class="hljs-attr">volumes:</span>   <span class="hljs-comment">#在该pod上定义共享存储卷列表</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#共享存储卷名称 （volumes类型有很多种）</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;       <span class="hljs-comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br>    <span class="hljs-attr">hostPath:</span> <span class="hljs-string">string</span>   <span class="hljs-comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">string</span>      　　        <span class="hljs-comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span><br>    <span class="hljs-attr">secret:</span>       　　　<span class="hljs-comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span><br>      <span class="hljs-attr">scretname:</span> <span class="hljs-string">string</span>  <br>      <span class="hljs-attr">items:</span>     <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>    <span class="hljs-attr">configMap:</span>         <span class="hljs-comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">items:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">小提示：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在这里，可通过一个命令来查看每种资源的可配置项</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">kubectl explain 资源类型         查看某种资源可以配置的一级属性</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">kubectl explain 资源类型.属性     查看属性的子属性</span><br>[root@master ~]# kubectl explain pod<br>KIND:     Pod<br>VERSION:  v1<br>FIELDS:<br>   apiVersion   &lt;string&gt;<br>   kind &lt;string&gt;<br>   metadata     &lt;Object&gt;<br>   spec &lt;Object&gt;<br>   status       &lt;Object&gt;<br><br>[root@master ~]# kubectl explain pod.metadata<br>KIND:     Pod<br>VERSION:  v1<br>RESOURCE: metadata &lt;Object&gt;<br>FIELDS:<br>   annotations  &lt;map[string]string&gt;<br>   clusterName  &lt;string&gt;<br>   creationTimestamp    &lt;string&gt;<br>   deletionGracePeriodSeconds   &lt;integer&gt;<br>   deletionTimestamp    &lt;string&gt;<br>   finalizers   &lt;[]string&gt;<br>   generateName &lt;string&gt;<br>   generation   &lt;integer&gt;<br>   labels       &lt;map[string]string&gt;<br>   managedFields        &lt;[]Object&gt;<br>   name &lt;string&gt;<br>   namespace    &lt;string&gt;<br>   ownerReferences      &lt;[]Object&gt;<br>   resourceVersion      &lt;string&gt;<br>   selfLink     &lt;string&gt;<br>   uid  &lt;string&gt;<br></code></pre></td></tr></table></figure><p>在 kubernetes 中基本所有资源的一级属性都是一样的，主要包含5部分：</p><ul><li>apiVersion <string> 版本，由kubernetes内部定义，版本号必须可以用<code>kubectl api-versions</code>查询到</li><li>kind <string> 类型，由kubernetes内部定义，版本号必须可以用<code>kubectl api-resources</code>查询到</li><li>metadata <Object> 元数据，主要是资源标识和说明，常用的有<code>name、namespace、labels</code>等</li><li>spec <Object> 描述，<strong>这是配置中最重要的一部分，里面是对各种资源配置的详细描述</strong></li><li>status <Object> 状态信息，里面的内容不需要定义，由kubernetes自动生成</li></ul><p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p><ul><li>containers &lt;[]Object&gt; 容器列表，用于定义容器的详细信息</li><li>nodeName <String> 根据nodeName的值将pod调度到指定的Node节点上</li><li>nodeSelector &lt;map[]&gt; 根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li><li>hostNetwork <boolean> 是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li><li>volumes &lt;[]Object&gt; 存储卷，用于定义Pod上面挂在的存储信息</li><li>restartPolicy <string> 重启策略，表示Pod在遇到故障的时候的处理策略</li></ul><h2 id="2-Pod的配置"><a href="#2-Pod的配置" class="headerlink" title="2. Pod的配置"></a>2. Pod的配置</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p><code>pod.spec.containers</code>属性，这是Pod配置中最为关键的一项配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl explain pod.spec.containers<br>KIND:     Pod<br>VERSION:  v1<br>RESOURCE: containers &lt;[]Object&gt;   # 数组，代表可以有多个容器<br>FIELDS:<br>   name  &lt;string&gt;     # 容器名称<br>   image &lt;string&gt;     # 容器需要的镜像地址<br>   imagePullPolicy  &lt;string&gt; # 镜像拉取策略 <br>   command  &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令<br>   args     &lt;[]string&gt; # 容器的启动命令需要的参数列表<br>   env      &lt;[]Object&gt; # 容器环境变量的配置<br>   ports    &lt;[]Object&gt;     # 容器需要暴露的端口号列表<br>   resources &lt;Object&gt;      # 资源限制和资源请求的设置<br></code></pre></td></tr></table></figure><h3 id="2-2-基本配置"><a href="#2-2-基本配置" class="headerlink" title="2.2 基本配置"></a>2.2 基本配置</h3><p>创建 pod-base.yaml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-base</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">dongys</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br></code></pre></td></tr></table></figure><p>上面定义了一个比较简单Pod的配置，里面有两个容器：</p><ul><li>nginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）</li><li>busybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）</li></ul><p>创建Pod，并查看Pod状况：</p><img src="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/image-20210819150809889.png" class="" title="image-20210819150809889"><p>表示当前 Pod 中有两个容器，其中一个准备就绪，另一个未就绪</p><p>RESTARTS表示重启次数，有一个容器出现故障，Pod 一直在尝试重启</p><p>通过describe命令查看内部详情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此时已经运行起来了一个基本的Pod，虽然它暂时有问题</span><br>kubectl describe pod pod-base -n dev<br></code></pre></td></tr></table></figure><img src="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/image-20210819151010680.png" class="" title="image-20210819151010680"><h3 id="2-3-镜像拉取策略"><a href="#2-3-镜像拉取策略" class="headerlink" title="2.3 镜像拉取策略"></a>2.3 镜像拉取策略</h3><p>创建pod-imagepullpolicy.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-imagepullpolicy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">dongys</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 容器名称</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span> <span class="hljs-comment"># 容器需要的镜像地址</span><br>      <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span> <span class="hljs-comment"># 用于设置镜像的拉取策略</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span> <span class="hljs-comment"># 容器名称</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span> <span class="hljs-comment"># 容器需要的镜像地址</span><br></code></pre></td></tr></table></figure><p>imagePullPolicy：用于设置镜像拉取的策略，kubernetes支持配置三种拉取策略：</p><ul><li><p>Always：总是从远程仓库拉取镜像（一直远程下载）。</p></li><li><p>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就用本地，本地没有就使用远程下载）。</p></li><li><p>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错（一直使用本地，没有就报错）。</p></li></ul><p>默认值说明：</p><ul><li><p>如果镜像tag为具体的版本号，默认策略是IfNotPresent。</p></li><li><p>如果镜像tag为latest（最终版本），默认策略是Always。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建Pod：</span><br>kubectl apply -f pod-imagepullpolicy.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod详情：</span><br>kubectl describe pod pod-imagepullpolicy -n dev<br></code></pre></td></tr></table></figure><img src="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/image-20210819152533030.png" class="" title="image-20210819152533030"><h3 id="2-4-启动命令"><a href="#2-4-启动命令" class="headerlink" title="2.4 启动命令"></a>2.4 启动命令</h3><p>在前面的案例中，一直有一个问题没有解决，就是busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障的呢？</p><p>原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command的配置。</p><p>创建pod-command.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-command</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">dongys</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 容器名称</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span> <span class="hljs-comment"># 容器需要的镜像地址</span><br>      <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span> <span class="hljs-comment"># 设置镜像拉取策略</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span> <span class="hljs-comment"># 容器名称</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span> <span class="hljs-comment"># 容器需要的镜像地址</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt;sleep 3;done;&quot;</span>]<br></code></pre></td></tr></table></figure><p>command，用于在pod中的容器初始化完毕之后运行一个命令。</p><blockquote><p>稍微解释下上面命令的意思：</p><p>“&#x2F;bin&#x2F;sh”,”-c”, 使用sh执行命令</p><p>touch &#x2F;tmp&#x2F;hello.txt; 创建一个&#x2F;tmp&#x2F;hello.txt 文件</p><p>while true;do &#x2F;bin&#x2F;echo $(date +%T) &gt;&gt; &#x2F;tmp&#x2F;hello.txt; sleep 3; done; 每隔3秒向文件中写入当前时间</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建Pod</span><br>[root@master ~]# kubectl apply -f pod-command.yaml<br>pod/pod-command created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod状态</span><br>[root@master ~]# kubectl get pods pod-command -n dev<br>NAME          READY   STATUS    RESTARTS   AGE<br>pod-command   2/2     Running   0          108s<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入pod中的busybox容器，查看文件内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">补充一个命令: kubectl <span class="hljs-built_in">exec</span>  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用这个命令就可以进入某个容器的内部，然后进行相关操作了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如，可以查看txt文件的内容</span><br>kubectl exec pod-command -n dev -it -c busybox /bin/sh<br></code></pre></td></tr></table></figure><img src="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/image-20210819153738272.png" class="" title="image-20210819153738272"><p>特别说明：通过上面发现command已经可以完成启动命令和传递参数的功能，为什么还要提供一个args选项，用于传递参数？其实和Docker有点关系，kubernetes中的command和args两个参数其实是为了实现覆盖Dockerfile中的ENTRYPOINT的功能：</p><ul><li><p>如果command和args均没有写，那么用Dockerfile的配置。</p></li><li><p>如果command写了，但是args没有写，那么Dockerfile默认的配置会被忽略，执行注入的command。</p></li><li><p>如果command没有写，但是args写了，那么Dockerfile中配置的ENTRYPOINT命令会被执行，使用当前args的参数。</p></li><li><p>如果command和args都写了，那么Dockerfile中的配置会被忽略，执行command并追加上args参数。</p></li></ul><h3 id="2-5-环境变量（不推荐）"><a href="#2-5-环境变量（不推荐）" class="headerlink" title="2.5 环境变量（不推荐）"></a>2.5 环境变量（不推荐）</h3><p>创建pod-env.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-env</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;while true;do /bin/echo $(date +%T);sleep 60; done;&quot;</span>]<br>    <span class="hljs-attr">env:</span> <span class="hljs-comment"># 设置环境变量列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;username&quot;</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;admin&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;password&quot;</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;123456&quot;</span><br></code></pre></td></tr></table></figure><p>env，环境变量，用于在pod中的容器设置环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建Pod</span><br>[root@k8s-master01 ~]# kubectl create -f pod-env.yaml<br>pod/pod-env created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器，输出环境变量</span><br>[root@k8s-master01 ~]# kubectl exec pod-env -n dev -c busybox -it /bin/sh<br>/ # echo $username<br>admin<br>/ # echo $password<br>123456<br></code></pre></td></tr></table></figure><p>这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。</p><h3 id="2-6-端口设置"><a href="#2-6-端口设置" class="headerlink" title="2.6 端口设置"></a>2.6 端口设置</h3><p>查看ports支持的子选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl explain pod.spec.containers.ports<br>KIND:     Pod<br>VERSION:  v1<br>RESOURCE: ports &lt;[]Object&gt;<br>FIELDS:<br>   name         &lt;string&gt;  # 端口名称，如果指定，必须保证name在pod中是唯一的<br>   containerPort&lt;integer&gt; # 容器要监听的端口(0&lt;x&lt;65536)<br>   hostPort     &lt;integer&gt; # 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) <br>   hostIP       &lt;string&gt;  # 要将外部端口绑定到的主机IP(一般省略)<br>   protocol     &lt;string&gt;  # 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。<br></code></pre></td></tr></table></figure><p>创建pod-ports.yaml，文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-ports</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">xudaxian</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 容器名称</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span> <span class="hljs-comment"># 容器需要的镜像地址</span><br>      <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span> <span class="hljs-comment"># 设置镜像拉取策略</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span> <span class="hljs-comment"># 端口名称，如果执行，必须保证name在Pod中是唯一的</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 容器要监听的端口 （0~65536）</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span> <span class="hljs-comment"># 端口协议</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建Pod</span><br>[root@master ~]# kubectl create -f pod-ports.yaml<br>pod/pod-ports created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在下面可以明显看到配置信息</span><br>[root@master ~]# kubectl get pod pod-ports -n dev -o yaml<br>......<br>spec:<br>  containers:<br>  - image: nginx:1.17.1<br>    imagePullPolicy: IfNotPresent<br>    name: nginx<br>    ports:<br>    - containerPort: 80<br>      name: nginx-port<br>      protocol: TCP<br>......<br></code></pre></td></tr></table></figure><p>访问容器中的程序需要使用的是<code>PodIp: containerPort</code></p><h3 id="2-7-资源配额"><a href="#2-7-资源配额" class="headerlink" title="2.7 资源配额"></a>2.7 资源配额</h3><p>容器中的程序要运行，肯定会占用一定的资源，比如CPU和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量的资源，导致其他的容器无法运行。针对这种情况，kubernetes提供了对内存和CPU的资源进行配额的机制，这种机制主要通过resources选项实现，它有两个子选项：</p><ul><li><p>limits：用于限制运行的容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启。</p></li><li><p>requests：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动。</p></li></ul><p>可以通过上面的两个选项设置资源的上下限。</p><p>创建pod-resoures.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-resoures</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">xudaxian</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 容器名称</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span> <span class="hljs-comment"># 容器需要的镜像地址</span><br>      <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span> <span class="hljs-comment"># 设置镜像拉取策略</span><br>      <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 端口设置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span> <span class="hljs-comment"># 端口名称，如果执行，必须保证name在Pod中是唯一的</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 容器要监听的端口 （0~65536）</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span> <span class="hljs-comment"># 端口协议</span><br>      <span class="hljs-attr">resources:</span> <span class="hljs-comment"># 资源配额</span><br>        <span class="hljs-attr">limits:</span> <span class="hljs-comment"># 限制资源的上限</span><br>          <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-comment"># CPU限制，单位是core数</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;10Gi&quot;</span> <span class="hljs-comment"># 内存限制</span><br>        <span class="hljs-attr">requests:</span> <span class="hljs-comment"># 限制资源的下限</span><br>          <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-comment"># CPU限制，单位是core数 </span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;10Mi&quot;</span> <span class="hljs-comment"># 内存限制</span><br></code></pre></td></tr></table></figure><p>在这对cpu和memory的单位做一个说明：</p><ul><li>cpu：core数，可以为整数或小数</li><li>memory： 内存大小，可以使用Gi、Mi、G、M等形式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行Pod</span><br>[root@master ~]# kubectl apply -f pod-resources.yaml<br>pod/pod-resoures created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看发现Pod运行正常</span><br>[root@master ~]# kubectl get pods pod-resoures -n dev            <br>NAME           READY   STATUS    RESTARTS   AGE<br>pod-resoures   1/1     Running   0          31s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来停止Pod</span><br>[root@master ~]# kubectl delete -f pod-resources.yaml<br>pod &quot;pod-resoures&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑pod-resources.yaml 文件，将resources.requests.memory的值改为10Gi</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次启动Pod</span><br>[root@master ~]# kubectl create -f pod-resources.yaml<br>pod/pod-resoures created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod状态，发现Pod启动失败</span><br>[root@master ~]# kubectl get pods pod-resoures -n dev<br>NAME           READY   STATUS    RESTARTS   AGE<br>pod-resoures   0/1     Pending   0          27s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod详情</span><br>[root@master ~]# kubectl describe pod pod-resoures -n dev<br>...<br>Events:<br>  Type     Reason            Age        From               Message<br>  ----     ------            ----       ----               -------<br>  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 1 Insufficient cpu, 3 Insufficient memory.<br>  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 1 Insufficient cpu, 3 Insufficient memory.<br></code></pre></td></tr></table></figure><h2 id="3-Pod生命周期"><a href="#3-Pod生命周期" class="headerlink" title="3. Pod生命周期"></a>3. Pod生命周期</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>我们一般将Pod对象从创建到终止的这段时间范围称为Pod的生命周期，它主要包含下面的过程：</p><ul><li>Pod 创建过程</li><li>运行初始化容器（init container）过程</li><li>运行主容器（main container）：<ul><li>容器启动后钩子（post start）、容器中之前钩子（pre stop）</li><li>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</li></ul></li><li>Pod 终止过程</li></ul><img src="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/image-20200412111402706-1626782188724.png" class="" title="image-20200412111402706-1626782188724"><p>在整个生命周期中，Pod 会出现5种状态（相位），分别如下：</p><ul><li>挂起（Pending）：apiserver 已经创建了 pod 资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li><li>运行中（Running）：pod 已经被调度至某节点，并且所有容器都已经被 kubelet 创建完成</li><li>成功（Succeeded）：pod 中的所有容器都已经完成终止并且不会被重启</li><li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li><li>未知（Unkown）：apiserver 无法正常获取到 pod 对象的状态信息，通常由网络通信失败所导致</li></ul><h3 id="3-2-创建和终止"><a href="#3-2-创建和终止" class="headerlink" title="3.2 创建和终止"></a>3.2 创建和终止</h3><h4 id="3-2-1-Pod的创建过程"><a href="#3-2-1-Pod的创建过程" class="headerlink" title="3.2.1 Pod的创建过程"></a>3.2.1 Pod的创建过程</h4><img src="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/image-20200406184656917-1626782168787.png" class="" title="image-20200406184656917-1626782168787"><ol><li>用户通过kubectl或其他的api客户端提交需要创建的Pod信息给ApiServer</li><li>ApiServer开始生成Pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</li><li>ApiServer开始反映etcd中的Pod对象的变化，其它组件使用watch机制来跟踪检查ApiServer上的变动</li><li>Scheduler发现有新的Pod对象要创建，开始为Pod分配主机并将结果信息更新至ApiServer</li><li>Node节点上的kubelet发现有Pod调度过来，尝试调度Docker启动容器，并将结果回送至ApiServer</li><li>ApiServer将接收到的Pod状态信息存入到etcd中</li></ol><h4 id="3-2-2-Pod的终止过程"><a href="#3-2-2-Pod的终止过程" class="headerlink" title="3.2.2 Pod的终止过程"></a>3.2.2 Pod的终止过程</h4><ol><li>用户向ApiServer发送删除Pod对象的命令</li><li>ApiServer中的Pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），Pod被视为Dead</li><li>将Pod标记为Terminating状态</li><li>kubelete在监听Pod对象转为Terminating状态的同时启动Pod的关闭过程</li><li>端点控制器监控到Pod对象的关闭行为时将其从所有匹配到此端点的service资源的断电列表中移除</li><li>如果当前Pod对象定义了preStop钩子处理器，则在其标记为Terminating后会以同步的方式启动执行</li><li>Pod对象中的容器进程收到停止信号</li><li>宽限期结束后，如果Pod中还存在运行的进程，那么Pod对象会收到立即终止的信息</li><li>kubectl请求ApiServer将此Pod资源的宽限期设置为0从而完成删除操作，此时Pod对于用户已经不可用了</li></ol><h3 id="3-3-初始化容器"><a href="#3-3-初始化容器" class="headerlink" title="3.3 初始化容器"></a>3.3 初始化容器</h3><p>初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：</p><ol><li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成</li><li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行</li></ol><p>初始化容器有很多的应用场景，下面列出的是最常见的几个：</p><ul><li>提供主容器镜像中不具备的工具程序或自定义代码</li><li>初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足</li></ul><p>接下来做一个案例，模拟下面这个需求：</p><p>假设要以主容器来运行nginx，但是要求在运行nginx之前先要能够连接上mysql和redis所在服务器</p><p>为了简化测试，事先规定好mysql<code>(192.168.249.4)</code>和redis<code>(192.168.249.5)</code>服务器的地址</p><p>创建pod-initcontainer.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-initcontainer</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">initContainers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-mysql</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until ping 192.168.249.4 -c 1 ; do echo waiting for mysql...; sleep 2; done;&#x27;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-redis</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until ping 192.168.249.5 -c 1 ; do echo waiting for reids...; sleep 2; done;&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-initcontainer.yaml <br>pod/pod-initcontainer created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod状态</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">由于此时initcontainer无法启动，后面的容器不会运行</span><br>[root@master ~]# kubectl get pod pod-initcontainer -n dev<br>NAME                READY   STATUS     RESTARTS   AGE<br>pod-initcontainer   0/1     Init:0/2   0          18s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来新开一个连接，为当前服务器新增两个ip，观察pod的变化</span><br>[root@master ~]# ifconfig ens33:1 192.168.249.4 netmask 255.255.255.0 up<br>[root@master ~]# ifconfig ens33:1 192.168.249.5 netmask 255.255.255.0 up<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">动态查询pod</span><br>[root@master ~]# kubectl get pod pod-initcontainer -n dev -w<br>NAME                READY   STATUS     RESTARTS   AGE<br>pod-initcontainer   0/1     Init:0/2   0          39s<br>pod-initcontainer   0/1     Init:1/2   0          97s<br>pod-initcontainer   0/1     Init:1/2   0          98s<br>pod-initcontainer   0/1     PodInitializing   0          3m50s<br>pod-initcontainer   1/1     Running           0          3m51s<br></code></pre></td></tr></table></figure><h3 id="3-4-钩子函数"><a href="#3-4-钩子函数" class="headerlink" title="3.4 钩子函数"></a>3.4 钩子函数</h3><p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p><p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p><ul><li>post start：容器创建之后执行，如果失败了会重启容器</li><li>pre stop ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li></ul><p>钩子处理器支持使用下面三种方式定义动作：</p><ul><li><p>Exec命令：在容器内执行一次命令</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">……</span><br>  <span class="hljs-attr">lifecycle:</span><br>    <span class="hljs-attr">postStart:</span> <br>      <span class="hljs-attr">exec:</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/healthy</span><br><span class="hljs-string">……</span><br></code></pre></td></tr></table></figure></li><li><p>TCPSocket：在当前容器尝试访问指定的socket</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">……</span>      <br>  <span class="hljs-attr">lifecycle:</span><br>    <span class="hljs-attr">postStart:</span><br>      <span class="hljs-attr">tcpSocket:</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-string">……</span><br></code></pre></td></tr></table></figure></li><li><p>HTTPGet：在当前容器中向某url发起http请求</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">……</span><br>  <span class="hljs-attr">lifecycle:</span><br>    <span class="hljs-attr">postStart:</span><br>      <span class="hljs-attr">httpGet:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment">#URI地址</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#端口号</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.5</span><span class="hljs-number">.3</span> <span class="hljs-comment">#主机地址</span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span> <span class="hljs-comment">#支持的协议，http或者https</span><br><span class="hljs-string">……</span><br></code></pre></td></tr></table></figure></li></ul><p>以exec方式为例，演示钩子函数的使用，创建pod-hook-exec.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-hook-exec</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">lifecycle:</span><br>      <span class="hljs-attr">postStart:</span> <br>        <span class="hljs-attr">exec:</span> <span class="hljs-comment"># 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容</span><br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo postStart... &gt; /usr/share/nginx/html/index.html&quot;</span>]<br>      <span class="hljs-attr">preStop:</span><br>        <span class="hljs-attr">exec:</span> <span class="hljs-comment"># 在容器停止之前停止nginx服务</span><br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/usr/sbin/nginx&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;quit&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建容器</span><br>[root@master ~]# kubectl create -f pod-hook-exec.yaml<br>pod/pod-hook-exec created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br>[root@master ~]# kubectl get pods pod-hook-exec -n dev -o wide<br>NAME            READY   STATUS    RESTARTS   AGE   IP              NODE     NOMINATED NODE   READINESS GATES<br>pod-hook-exec   1/1     Running   0          31s   10.244.140.80   node02   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问pod</span><br>[root@master ~]# curl 10.244.140.80:80<br>postStart...<br></code></pre></td></tr></table></figure><h3 id="3-5-容器探测"><a href="#3-5-容器探测" class="headerlink" title="3.5 容器探测"></a>3.5 容器探测</h3><h4 id="3-5-1-概述"><a href="#3-5-1-概述" class="headerlink" title="3.5.1 概述"></a>3.5.1 概述</h4><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p><ul><li>liveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状况，如果不是，k8s会重启容器</li><li>readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量</li></ul><blockquote><p>livenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。</p></blockquote><p>上面两种探针目前均支持三种探测方式：</p><ul><li><p>Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">……</span><br>  <span class="hljs-attr">livenessProbe:</span><br>    <span class="hljs-attr">exec:</span><br>      <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/healthy</span><br><span class="hljs-string">……</span><br></code></pre></td></tr></table></figure></li><li><p>TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">……</span>      <br>  <span class="hljs-attr">livenessProbe:</span><br>    <span class="hljs-attr">tcpSocket:</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-string">……</span><br></code></pre></td></tr></table></figure></li><li><p>HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">……</span><br>  <span class="hljs-attr">livenessProbe:</span><br>    <span class="hljs-attr">httpGet:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment">#URI地址</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#端口号</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment">#主机地址</span><br>      <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span> <span class="hljs-comment">#支持的协议，http或者https</span><br><span class="hljs-string">……</span><br></code></pre></td></tr></table></figure></li></ul><p>下面以liveness probes为例，做几个演示：</p><h4 id="3-5-2-exec方式"><a href="#3-5-2-exec方式" class="headerlink" title="3.5.2 exec方式"></a>3.5.2 exec方式</h4><p>创建pod-liveness-exec.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-liveness-exec</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">exec:</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/cat&quot;</span>,<span class="hljs-string">&quot;/tmp/hello.txt&quot;</span>] <span class="hljs-comment"># 执行一个查看文件的命令</span><br></code></pre></td></tr></table></figure><p>创建pod，观察效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-liveness-exec.yaml<br>pod/pod-liveness-exec created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod详情</span><br>[root@master ~]# kubectl describe pods pod-liveness-exec -n dev   <br>......<br>Events:<br>  Type     Reason     Age               From               Message<br>  ----     ------     ----              ----               -------<br>  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev/pod-liveness-exec to node02<br>  Normal   Pulled     8s (x2 over 38s)  kubelet, node02    Container image &quot;nginx:1.17.1&quot; already present on machine<br>  Normal   Created    8s (x2 over 38s)  kubelet, node02    Created container nginx<br>  Normal   Started    8s (x2 over 38s)  kubelet, node02    Started container nginx<br>  Warning  Unhealthy  8s (x3 over 28s)  kubelet, node02    Liveness probe failed: /bin/cat: /tmp/hello.txt: No such file or directory<br>  Normal   Killing    8s                kubelet, node02    Container nginx failed liveness probe, will be restarted<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">观察上面的信息就会发现nginx容器启动之后就进行了就绪性探测</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">探测失败后，容器就会尝试重启（重试策略）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">之后在观察pod信息，就可以看到RESTARTS一直在增长</span><br>[root@master ~]# kubectl get pods pod-liveness-exec -n dev     <br>NAME                READY   STATUS    RESTARTS   AGE<br>pod-liveness-exec   1/1     Running   5          3m13s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果将文件修改成一个存在的文件，那么就绪性探测成功则不会一直重启</span><br></code></pre></td></tr></table></figure><h4 id="3-5-3-TCPSocket"><a href="#3-5-3-TCPSocket" class="headerlink" title="3.5.3 TCPSocket"></a>3.5.3 TCPSocket</h4><p>创建pod-liveness-tcpsocket.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-liveness-tcpsocket</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">tcpSocket:</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 尝试访问8080端口</span><br></code></pre></td></tr></table></figure><p>创建pod，观察效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-liveness-tcpsocket.yaml<br>pod/pod-liveness-tcpsocket created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod详情</span><br>[root@master ~]# kubectl describe pod pod-liveness-tcpsocket -n dev<br>Events:<br>  Type     Reason     Age               From               Message<br>  ----     ------     ----              ----               -------<br>  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev/pod-liveness-tcpsocket to node01<br>  Normal   Pulled     5s (x3 over 62s)  kubelet, node01    Container image &quot;nginx:1.17.1&quot; already present on machine<br>  Normal   Created    5s (x3 over 62s)  kubelet, node01    Created container nginx<br>  Normal   Started    5s (x3 over 62s)  kubelet, node01    Started container nginx<br>  Warning  Unhealthy  5s (x6 over 55s)  kubelet, node01    Liveness probe failed: dial tcp 10.244.196.146:8080: connect: connection refused<br>  Normal   Killing    5s (x2 over 35s)  kubelet, node01    Container nginx failed liveness probe, will be restarted<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">观察上面的信息，发现尝试访问8080端口，但是失败了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再观察pod信息，可以看到RESTARTS一直在增长</span><br>[root@master ~]# kubectl get pods pod-liveness-tcpsocket -n dev        <br>NAME                     READY   STATUS             RESTARTS   AGE<br>pod-liveness-tcpsocket   0/1     CrashLoopBackOff   4          2m54s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以修改成一个可以访问的端口，比如80，结果就正常了......</span><br></code></pre></td></tr></table></figure><h4 id="3-5-4-HTTPGet"><a href="#3-5-4-HTTPGet" class="headerlink" title="3.5.4 HTTPGet"></a>3.5.4 HTTPGet</h4><p>创建pod-liveness-httpget.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-liveness-httpget</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">httpGet:</span>  <span class="hljs-comment"># 其实就是访问http://127.0.0.1:80/hello  </span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span> <span class="hljs-comment">#支持的协议，http或者https</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#端口号</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/hello</span> <span class="hljs-comment">#URI地址</span><br></code></pre></td></tr></table></figure><p>创建pod，观察效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-liveness-httpget.yaml<br>pod/pod-liveness-httpget created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod详情</span><br>[root@master ~]# kubectl describe pods pod-liveness-httpget -n dev<br>......<br>Events:<br>  Type     Reason     Age               From               Message<br>  ----     ------     ----              ----               -------<br>  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev/pod-liveness-httpget to node02<br>  Normal   Pulled     2s (x2 over 25s)  kubelet, node02    Container image &quot;nginx:1.17.1&quot; already present on machine<br>  Normal   Created    2s (x2 over 25s)  kubelet, node02    Created container nginx<br>  Normal   Started    2s (x2 over 25s)  kubelet, node02    Started container nginx<br>  Warning  Unhealthy  2s (x3 over 22s)  kubelet, node02    Liveness probe failed: HTTP probe failed with statuscode: 404<br>  Normal   Killing    2s                kubelet, node02    Container nginx failed liveness probe, will be restarted<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">观察上面信息，尝试访问路径，但是未找到,出现404错误</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span><br>[root@master ~]# kubectl get pods pod-liveness-httpget -n dev<br>NAME                   READY   STATUS    RESTARTS   AGE<br>pod-liveness-httpget   1/1     Running   3          98s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以修改成一个可以访问的路径path，比如/，再试，结果就正常了......</span><br></code></pre></td></tr></table></figure><h4 id="3-5-5-容器探测的补充"><a href="#3-5-5-容器探测的补充" class="headerlink" title="3.5.5 容器探测的补充"></a>3.5.5 容器探测的补充</h4><p>上面已经使用了livenessProbe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl explain pod.spec.containers.livenessProbe<br>FIELDS:<br>   exec &lt;Object&gt;  <br>   tcpSocket    &lt;Object&gt;<br>   httpGet      &lt;Object&gt;<br>   initialDelaySeconds  &lt;integer&gt;  # 容器启动后等待多少秒执行第一次探测<br>   timeoutSeconds       &lt;integer&gt;  # 探测超时时间。默认1秒，最小1秒<br>   periodSeconds        &lt;integer&gt;  # 执行探测的频率。默认是10秒，最小1秒<br>   failureThreshold     &lt;integer&gt;  # 连续探测失败多少次才被认定为失败。默认是3。最小值是1<br>   successThreshold     &lt;integer&gt;  # 连续探测成功多少次才被认定为成功。默认是1<br></code></pre></td></tr></table></figure><h3 id="3-6-重启策略"><a href="#3-6-重启策略" class="headerlink" title="3.6 重启策略"></a>3.6 重启策略</h3><p>一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：</p><ul><li>Always：容器失效时，自动重启该容器，这也是默认值。</li><li>OnFailure ： 容器终止运行且退出码不为0时重启。</li><li>Never： 不论状态为何，都不重启该容器。</li></ul><p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p><p>创建pod-restartpolicy.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-restartpolicy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">httpGet:</span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/hello</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span> <span class="hljs-comment"># 设置重启策略为Never</span><br></code></pre></td></tr></table></figure><p>运行Pod测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建Pod</span><br>[root@master ~]# kubectl create -f pod-restartpolicy.yaml<br>pod/pod-restartpolicy created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod详情，发现nginx容器失败</span><br>[root@master ~]# kubectl describe pods pod-restartpolicy -n dev<br>......<br>Events:<br>  Type     Reason     Age                From               Message<br>  ----     ------     ----               ----               -------<br>  Normal   Scheduled  &lt;unknown&gt;          default-scheduler  Successfully assigned dev/pod-restartpolicy to node01<br>  Normal   Pulled     59s                kubelet, node01    Container image &quot;nginx:1.17.1&quot; already present on machine<br>  Normal   Created    59s                kubelet, node01    Created container nginx<br>  Normal   Started    59s                kubelet, node01    Started container nginx<br>  Warning  Unhealthy  36s (x3 over 56s)  kubelet, node01    Liveness probe failed: HTTP probe failed with statuscode: 404<br>  Normal   Killing    36s                kubelet, node01    Stopping container nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">观察pod的重启次数，发现一直是0，并未重启</span><br>[root@master ~]# kubectl get pods pod-restartpolicy -n dev -w<br>NAME                READY   STATUS      RESTARTS   AGE<br>pod-restartpolicy   0/1     Completed   0          39s<br></code></pre></td></tr></table></figure><h2 id="4-Pod的调度"><a href="#4-Pod的调度" class="headerlink" title="4. Pod的调度"></a>4. Pod的调度</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做呢？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：</p><ul><li>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出</li><li>定向调度：NodeName、NodeSelector</li><li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li><li>污点（容忍）调度：Taints、Toleration</li></ul><h3 id="4-2-定向调度"><a href="#4-2-定向调度" class="headerlink" title="4.2 定向调度"></a>4.2 定向调度</h3><h4 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h4><p>定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。</p><h4 id="4-2-2-NodeName"><a href="#4-2-2-NodeName" class="headerlink" title="4.2.2 NodeName"></a>4.2.2 NodeName</h4><p>NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。</p><p>接下来，实验一下：创建一个pod-nodename.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-nodename</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">node01</span> <span class="hljs-comment"># 指定调度到node1节点上</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-nodename.yaml<br>pod/pod-nodename created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod调度到NODE属性，确实是调度到了node1节点上</span><br>[root@master ~]# kubectl get pod pod-nodename -n dev -o wide<br>NAME           READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES<br>pod-nodename   1/1     Running   0          11s   10.244.196.148   node01   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除pod，修改nodeName的值为node3（并没有node3节点）</span><br>[root@master ~]# kubectl delete -f pod-nodename.yaml<br>pod &quot;pod-nodename&quot; deleted<br>[root@master ~]# vim pod-nodename.yaml                      <br>[root@master ~]# kubectl create -f pod-nodename.yaml<br>pod/pod-nodename created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行</span><br>[root@master ~]# kubectl get pod pod-nodename -n dev -o wide<br>NAME           READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES<br>pod-nodename   0/1     Pending   0          13s   &lt;none&gt;   node03   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><h4 id="4-2-3-NodeSelector"><a href="#4-2-3-NodeSelector" class="headerlink" title="4.2.3 NodeSelector"></a>4.2.3 NodeSelector</h4><p>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束。</p><p>首先分别为node节点添加标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl label nodes node01 nodeenv=pro<br>node/node01 labeled<br>[root@master ~]# kubectl label nodes node02 nodeenv=test<br>node/node02 labeled<br></code></pre></td></tr></table></figure><p>创建一个pod-nodeselector.yaml文件，并使用它创建Pod</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-nodeselector</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">nodeSelector:</span> <br>    <span class="hljs-attr">nodeenv:</span> <span class="hljs-string">pro</span> <span class="hljs-comment"># 指定调度到具有nodeenv=pro标签的节点上</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl create -f pod-nodeselector.yaml<br>pod/pod-nodeselector created<br>[root@master ~]# kubectl get pods pod-nodeselector -n dev -o wide<br>NAME               READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES<br>pod-nodeselector   1/1     Running   0          12s   10.244.196.149   node01   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><h3 id="4-3-亲和性调度"><a href="#4-3-亲和性调度" class="headerlink" title="4.3 亲和性调度"></a>4.3 亲和性调度</h3><h4 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h4><p>使用定向调度，如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用Node列表也不行，这就限制了它的使用场景。</p><p>基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。</p><p>Affinity主要分为三类：</p><ul><li>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题</li><li>podAffinity(pod亲和性) : 以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题</li><li>podAntiAffinity(pod反亲和性) : 以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</li></ul><blockquote><p>关于亲和性(反亲和性)使用场景的说明：</p><p><strong>亲和性</strong>：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。</p><p><strong>反亲和性</strong>：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。</p></blockquote><h4 id="4-3-2-nodeAffinity"><a href="#4-3-2-nodeAffinity" class="headerlink" title="4.3.2 nodeAffinity"></a>4.3.2 nodeAffinity</h4><p>首先来看一下<code>NodeAffinity</code>的可配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">pod.spec.affinity.nodeAffinity</span><br>  <span class="hljs-string">requiredDuringSchedulingIgnoredDuringExecution</span>  <span class="hljs-string">Node节点必须满足指定的所有规则才可以，相当于硬限制</span><br>    <span class="hljs-string">nodeSelectorTerms</span>  <span class="hljs-string">节点选择列表</span><br>      <span class="hljs-string">matchFields</span>   <span class="hljs-string">按节点字段列出的节点选择器要求列表</span><br>      <span class="hljs-string">matchExpressions</span>   <span class="hljs-string">按节点标签列出的节点选择器要求列表(推荐)</span><br>        <span class="hljs-string">key</span>    <span class="hljs-string">键</span><br>        <span class="hljs-string">values</span> <span class="hljs-string">值</span><br>        <span class="hljs-string">operator</span> <span class="hljs-string">关系符</span> <span class="hljs-string">支持Exists,</span> <span class="hljs-string">DoesNotExist,</span> <span class="hljs-string">In,</span> <span class="hljs-string">NotIn,</span> <span class="hljs-string">Gt,</span> <span class="hljs-string">Lt</span><br>  <span class="hljs-string">preferredDuringSchedulingIgnoredDuringExecution</span> <span class="hljs-string">优先调度到满足指定的规则的Node，相当于软限制</span> <span class="hljs-string">(倾向)</span><br>    <span class="hljs-string">preference</span>   <span class="hljs-string">一个节点选择器项，与相应的权重相关联</span><br>      <span class="hljs-string">matchFields</span>   <span class="hljs-string">按节点字段列出的节点选择器要求列表</span><br>      <span class="hljs-string">matchExpressions</span>   <span class="hljs-string">按节点标签列出的节点选择器要求列表(推荐)</span><br>        <span class="hljs-string">key</span>    <span class="hljs-string">键</span><br>        <span class="hljs-string">values</span> <span class="hljs-string">值</span><br>        <span class="hljs-string">operator</span> <span class="hljs-string">关系符</span> <span class="hljs-string">支持In,</span> <span class="hljs-string">NotIn,</span> <span class="hljs-string">Exists,</span> <span class="hljs-string">DoesNotExist,</span> <span class="hljs-string">Gt,</span> <span class="hljs-string">Lt</span><br><span class="hljs-string">weight</span> <span class="hljs-string">倾向权重，在范围1-100。</span><br></code></pre></td></tr></table></figure><p>关系符的使用说明：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">nodeenv</span>              <span class="hljs-comment"># 匹配存在标签的key为nodeenv的节点</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">nodeenv</span>              <span class="hljs-comment"># 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>    <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">nodeenv</span>              <span class="hljs-comment"># 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">Gt</span><br>    <span class="hljs-attr">values:</span> <span class="hljs-string">&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><p>接下来首先演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p><p>创建pod-nodeaffinity-required.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-nodeaffinity-required</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">affinity:</span>  <span class="hljs-comment">#亲和性设置</span><br>    <span class="hljs-attr">nodeAffinity:</span> <span class="hljs-comment">#设置node亲和性</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬限制</span><br>        <span class="hljs-attr">nodeSelectorTerms:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">nodeenv</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-nodeaffinity-required.yaml <br>pod/pod-nodeaffinity-required created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod状态</span><br>[root@master ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide<br>NAME                        READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES<br>pod-nodeaffinity-required   0/1     Pending   0          14s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod详情</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发现调度失败，提示node选择失败</span><br>[root@master ~]# kubectl describe pods pod-nodeaffinity-required -n dev<br>Events:<br>  Type     Reason            Age        From               Message<br>  ----     ------            ----       ----               -------<br>  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;t match node selector.<br>  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;t match node selector.<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接下来，停止pod</span><br>[root@master ~]# kubectl delete -f pod-nodeaffinity-required.yaml<br>pod &quot;pod-nodeaffinity-required&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件，将values: [<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]------&gt; [<span class="hljs-string">&quot;pro&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]</span><br>[root@k8s-master01 ~]# vim pod-nodeaffinity-required.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次启动</span><br>[root@master ~]# kubectl create -f pod-nodeaffinity-required.yaml <br>pod/pod-nodeaffinity-required created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时查看，发现调度成功，运行在node01上</span><br>[root@master ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide<br>NAME                        READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES<br>pod-nodeaffinity-required   1/1     Running   0          22s   10.244.196.150   node01   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>接下来再演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p><p>创建pod-nodeaffinity-preferred.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-nodeaffinity-preferred</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">affinity:</span>  <span class="hljs-comment">#亲和性设置</span><br>    <span class="hljs-attr">nodeAffinity:</span> <span class="hljs-comment">#设置node亲和性</span><br>      <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 软限制</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">preference:</span><br>          <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">nodeenv</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-nodeaffinity-preferred.yaml<br>pod/pod-nodeaffinity-preferred created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod状态，运行成功</span><br>[root@master ~]# kubectl get pods pod-nodeaffinity-preferred -n dev -o wide<br>NAME                         READY   STATUS    RESTARTS   AGE   IP              NODE     NOMINATED NODE   READINESS GATES<br>pod-nodeaffinity-preferred   1/1     Running   0          12s   10.244.140.83   node02   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>NodeAffinity的注意事项：</p><ul><li><p>如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都满足，Pod才能运行在指定的Node上。</p></li><li><p>如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可。</p></li><li><p>如果一个nodeSelectorTerms中有多个matchExpressions，则一个节点必须满足所有的才能匹配成功。</p></li><li><p>如果一个Pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的nodeAffinity的要求，则系统将忽略此变化。</p></li></ul><h4 id="4-3-3-PodAffinity"><a href="#4-3-3-PodAffinity" class="headerlink" title="4.3.3 PodAffinity"></a>4.3.3 PodAffinity</h4><p>PodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能。</p><p>首先来看一下<code>PodAffinity</code>的可配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">pod.spec.affinity.podAffinity</span><br>  <span class="hljs-string">requiredDuringSchedulingIgnoredDuringExecution</span>  <span class="hljs-string">硬限制</span><br>    <span class="hljs-string">namespaces</span>       <span class="hljs-string">指定参照pod的namespace</span><br>    <span class="hljs-string">topologyKey</span>      <span class="hljs-string">指定调度作用域</span><br>    <span class="hljs-string">labelSelector</span>    <span class="hljs-string">标签选择器</span><br>      <span class="hljs-string">matchExpressions</span>  <span class="hljs-string">按节点标签列出的节点选择器要求列表(推荐)</span><br>        <span class="hljs-string">key</span>    <span class="hljs-string">键</span><br>        <span class="hljs-string">values</span> <span class="hljs-string">值</span><br>        <span class="hljs-string">operator</span> <span class="hljs-string">关系符</span> <span class="hljs-string">支持In,</span> <span class="hljs-string">NotIn,</span> <span class="hljs-string">Exists,</span> <span class="hljs-string">DoesNotExist.</span><br>      <span class="hljs-string">matchLabels</span>    <span class="hljs-string">指多个matchExpressions映射的内容</span><br>  <span class="hljs-string">preferredDuringSchedulingIgnoredDuringExecution</span> <span class="hljs-string">软限制</span><br>    <span class="hljs-string">podAffinityTerm</span>  <span class="hljs-string">选项</span><br>      <span class="hljs-string">namespaces</span>      <br>      <span class="hljs-string">topologyKey</span><br>      <span class="hljs-string">labelSelector</span><br>        <span class="hljs-string">matchExpressions</span>  <br>          <span class="hljs-string">key</span>    <span class="hljs-string">键</span><br>          <span class="hljs-string">values</span> <span class="hljs-string">值</span><br>          <span class="hljs-string">operator</span><br>        <span class="hljs-string">matchLabels</span> <br>    <span class="hljs-string">weight</span> <span class="hljs-string">倾向权重，在范围1-100</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">topologyKey用于指定调度时作用域,例如:</span><br>    <span class="hljs-string">如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围</span><br><span class="hljs-string">如果指定为beta.kubernetes.io/os,则以Node节点的操作系统类型来区分</span><br></code></pre></td></tr></table></figure><p>接下来，演示下<code>requiredDuringSchedulingIgnoredDuringExecution</code>,</p><p>首先创建一个参照Pod，pod-podaffinity-target.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-podaffinity-target</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">podenv:</span> <span class="hljs-string">pro</span> <span class="hljs-comment">#设置标签</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">node01</span> <span class="hljs-comment"># 将目标pod名确指定到node1上</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动目标pod</span><br>[root@master ~]# kubectl create -f pod-podaffinity-target.yaml<br>pod/pod-podaffinity-target created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod状况</span><br>[root@master ~]# kubectl get pods pod-podaffinity-target -n dev -o wide<br>NAME                     READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES<br>pod-podaffinity-target   1/1     Running   0          10s   10.244.196.151   node01   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>创建pod-podaffinity-required.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-podaffinity-required</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">affinity:</span>  <span class="hljs-comment">#亲和性设置</span><br>    <span class="hljs-attr">podAffinity:</span> <span class="hljs-comment">#设置pod亲和性</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬限制</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">podenv</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]<br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br></code></pre></td></tr></table></figure><p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;xxx或者nodeenv&#x3D;yyy的pod在同一Node上，显然现在没有这样pod，接下来，运行测试一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动pod</span><br>[root@master ~]# kubectl create -f pod-podaffinity-required.yaml<br>pod/pod-podaffinity-required created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod状态，发现未运行</span><br>[root@master ~]# kubectl get pods pod-podaffinity-required -n dev -o wide<br>NAME                       READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES<br>pod-podaffinity-required   0/1     Pending   0          14s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看详细信息</span><br>[root@master ~]# kubectl describe pods pod-podaffinity-required -n dev<br>......<br>Events:<br>  Type     Reason            Age        From               Message<br>  ----     ------            ----       ----               -------<br>  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io/master: &#125;, that the pod didn&#x27;t tolerate, 2 node(s) didn&#x27;t match pod affinity rules, 2 node(s) didn&#x27;t match pod affinity/anti-affinity.<br>  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io/master: &#125;, that the pod didn&#x27;t tolerate, 2 node(s) didn&#x27;t match pod affinity rules, 2 node(s) didn&#x27;t match pod affinity/anti-affinity.<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来修改  values: [<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]-----&gt;values:[<span class="hljs-string">&quot;pro&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">意思是：新Pod必须要与拥有标签nodeenv=pro或者nodeenv=yyy的pod在同一Node上</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新创建pod查看效果，发现pod运行正常</span><br>[root@master ~]# kubectl get pods pod-podaffinity-required -n dev -o wide<br>NAME                       READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES<br>pod-podaffinity-required   1/1     Running   0          26s   10.244.196.152   node01   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><h4 id="4-3-4-PodAntiAffinity"><a href="#4-3-4-PodAntiAffinity" class="headerlink" title="4.3.4 PodAntiAffinity"></a>4.3.4 PodAntiAffinity</h4><p>PodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod不在一个区域中的功能。</p><p>它的配置方式和选项跟PodAffinty是一样的，这里不再做详细解释，直接做一个测试案例。</p><p>继续使用上个案例中目标pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pods -n dev -o wide --show-labels<br>NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    LABELS<br>pod-podaffinity-required 1/1     Running   0          3m29s   10.244.1.38   node1   &lt;none&gt;     <br>pod-podaffinity-target   1/1     Running   0          9m25s   10.244.1.37   node1   podenv=pro<br></code></pre></td></tr></table></figure><p>创建pod-podantiaffinity-required.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-podantiaffinity-required</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">affinity:</span>  <span class="hljs-comment">#亲和性设置</span><br>    <span class="hljs-attr">podAntiAffinity:</span> <span class="hljs-comment">#设置pod亲和性</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬限制</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># 匹配podenv的值在[&quot;pro&quot;]中的标签</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">podenv</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;pro&quot;</span>]<br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br></code></pre></td></tr></table></figure><p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;pro的pod不在同一Node上，运行测试一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod</span><br>[root@master ~]# kubectl create -f pod-podantiaffinity-required.yaml<br>pod/pod-podantiaffinity-required created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发现调度到了node02上</span><br>[root@master ~]# kubectl get pods pod-podantiaffinity-required -n dev -o wide<br>NAME                           READY   STATUS    RESTARTS   AGE   IP              NODE     NOMINATED NODE   READINESS GATES<br>pod-podantiaffinity-required   1/1     Running   0          13s   10.244.140.84   node02   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><h3 id="4-4-污点和容忍"><a href="#4-4-污点和容忍" class="headerlink" title="4.4 污点和容忍"></a>4.4 污点和容忍</h3><h4 id="4-4-1-污点"><a href="#4-4-1-污点" class="headerlink" title="4.4.1 污点"></a>4.4.1 污点</h4><p><strong>污点（Taints）</strong></p><p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加<strong>污点</strong>属性，来决定是否允许Pod调度过来。</p><p>Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。</p><p>污点的格式为：<code>key=value:effect</code>, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p><ul><li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li><li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li><li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li></ul><img src="/2021/08/19/Kubernetes-Pod%E8%AF%A6%E8%A7%A3/image-20200605021831545-1629427747448.png" class="" title="image-20200605021831545"><p>使用kubectl设置和去除污点的命令示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置污点</span><br>kubectl taint nodes node01 key=value:effect<br><span class="hljs-meta prompt_"># </span><span class="language-bash">去除污点</span><br>kubectl taint nodes node01 key:effect-<br><span class="hljs-meta prompt_"># </span><span class="language-bash">去除所有污点</span><br>kubectl taint nodes node01 key-<br></code></pre></td></tr></table></figure><p>接下来，演示下污点的效果：</p><ol><li>准备节点node1（为了演示效果更加明显，暂时停止node2节点）</li><li>为node1节点设置一个污点: <code>tag=heima:PreferNoSchedule</code>；然后创建pod1( pod1 可以 )</li><li>修改为node1节点设置一个污点: <code>tag=heima:NoSchedule</code>；然后创建pod2( pod1 正常 pod2 失败 )</li><li>修改为node1节点设置一个污点: <code>tag=heima:NoExecute</code>；然后创建pod3 ( 3个pod都失败 )</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">为node01设置污点(PreferNoSchedule)</span><br>[root@master ~]# kubectl taint nodes node01 tag=dongys:PreferNoSchedule<br>node/node01 tainted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod1</span><br>[root@master ~]# kubectl run taint1 --image=nginx:1.17.1 -n dev<br>pod/taint1 created<br>[root@master ~]# kubectl get pods -n dev<br>NAME     READY   STATUS    RESTARTS   AGE<br>taint1   1/1     Running   0          5s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为node01设置污点(取消PreferNoSchedule，设置NoSchedule)</span><br>[root@master ~]# kubectl taint nodes node01 tag:PreferNoSchedule-<br>node/node01 untainted<br>[root@master ~]# kubectl taint nodes node01 tag=dongys:NoSchedule<br>node/node01 tainted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时pod1照常运行</span><br>[root@master ~]# kubectl get pods -n dev<br>NAME     READY   STATUS    RESTARTS   AGE<br>taint1   1/1     Running   0          2m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod2</span><br>[root@master ~]# kubectl run taint2 --image=nginx:1.17.1 -n dev<br>pod/taint2 created<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod2状态</span><br>[root@master ~]# kubectl get pods taint2 -n dev -o wide<br>NAME     READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES<br>taint2   0/1     Pending   0          5s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod2详情</span><br>[root@master ~]# kubectl describe pod taint2 -n dev<br>......<br>Events:<br>  Type     Reason            Age        From               Message<br>  ----     ------            ----       ----               -------<br>  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 1 node(s) had taint &#123;node-role.kubernetes.io/master: &#125;, that the pod didn&#x27;t tolerate, 1 node(s) had taint &#123;node.kubernetes.io/unreachable: &#125;, that the pod didn&#x27;t tolerate, 1 node(s) had taint &#123;tag: dongys&#125;, that the pod didn&#x27;t tolerate.<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为node1设置污点(取消NoSchedule，设置NoExecute)</span><br>[root@master ~]# kubectl taint nodes node01 tag:NoSchedule-<br>node/node01 untainted<br>[root@master ~]# kubectl taint nodes node01 tag=dongys:NoExecute<br>node/node01 tainted<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看pod，此时已经没有pod在运行</span><br>[root@master ~]# kubectl get pods -n dev<br>No resources found in dev namespace.<br></code></pre></td></tr></table></figure><p><strong>使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看master详情</span><br>[root@master ~]# kubectl describe nodes master<br>......<br>Taints:             node-role.kubernetes.io/master:NoSchedule<br>......<br></code></pre></td></tr></table></figure><h4 id="4-4-2-容忍"><a href="#4-4-2-容忍" class="headerlink" title="4.4.2 容忍"></a>4.4.2 容忍</h4><p>我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong>。</p><p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝Pod调度上去，Pod通过容忍忽略拒绝。</p><p>下面先通过一个案例看下效果：</p><ol><li>此时node1节点上打上了<code>NoExecute</code>的污点，此时pod是调度不上去的</li><li>可以通过给pod添加容忍，然后将其调度上去</li></ol><p>创建pod-toleration.yaml,内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-toleration</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">tolerations:</span>      <span class="hljs-comment"># 添加容忍</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>        <span class="hljs-comment"># 要容忍的污点的key</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span> <span class="hljs-comment"># 操作符</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;dongys&quot;</span>    <span class="hljs-comment"># 容忍的污点的value</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span>   <span class="hljs-comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加容忍之后的pod</span><br>[root@master ~]# kubectl create -f pod-toleration.yaml<br>pod/pod-toleration created<br>[root@master ~]# kubectl get pods pod-toleration -n dev<br>NAME             READY   STATUS    RESTARTS   AGE<br>pod-toleration   1/1     Running   0          8s<br></code></pre></td></tr></table></figure><p>容忍的详细配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">explain</span> <span class="hljs-string">pod.spec.tolerations</span><br><span class="hljs-string">......</span><br><span class="hljs-attr">FIELDS:</span><br>  <span class="hljs-string">key</span>       <span class="hljs-comment"># 对应着要容忍的污点的键，空意味着匹配所有的键</span><br>  <span class="hljs-string">value</span>     <span class="hljs-comment"># 对应着要容忍的污点的值</span><br>  <span class="hljs-string">operator</span>  <span class="hljs-comment"># key-value的运算符，支持Equal和Exists（默认）</span><br>  <span class="hljs-string">effect</span>    <span class="hljs-comment"># 对应污点的effect，空意味着匹配所有影响</span><br>  <span class="hljs-string">tolerationSeconds</span>   <span class="hljs-comment"># 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</span><br></code></pre></td></tr></table></figure><p>当operator为Equal的时候，如果Node节点有多个Taint，那么Pod每个Taint都需要容忍才能部署上去。</p><p>当operator为Exists的时候，有如下的三种写法：</p><ul><li><p>容忍指定的污点，污点带有指定的effect：</p></li><li><p>容忍指定的污点，不考虑具体的effect：</p></li><li><p>容忍一切污点（慎用）：</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span> <span class="hljs-comment"># 容忍</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span> <span class="hljs-comment"># 要容忍的污点的key</span><br><span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span> <span class="hljs-comment"># 操作符</span><br><span class="hljs-attr">effect:</span> <span class="hljs-string">NoExecute</span> <span class="hljs-comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span><br><span class="hljs-attr">tolerations:</span> <span class="hljs-comment"># 容忍</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span> <span class="hljs-comment"># 要容忍的污点的key</span><br><span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span> <span class="hljs-comment"># 操作符</span><br><span class="hljs-attr">tolerations:</span> <span class="hljs-comment"># 容忍</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span> <span class="hljs-comment"># 操作符</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-实战入门</title>
    <link href="/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/"/>
    <url>/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-实战入门"><a href="#Kubernetes-实战入门" class="headerlink" title="Kubernetes-实战入门"></a>Kubernetes-实战入门</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>介绍如何在Kubernetes集群中部署一个Nginx服务，并且能够实现对其访问</p><h2 id="2-Namespace"><a href="#2-Namespace" class="headerlink" title="2. Namespace"></a>2. Namespace</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Namespace 是 Kubernetes 系统中一种非常重要的资源，它的主要作用是用来实现<strong>多套系统的资源隔离</strong>或者<strong>多租户的资源隔离</strong>。</p><p>默认情况下，Kubernetes 集群中的所有Pod都是可以相互访问的，但是在实际应用中，可能不想让两个 Pod 之间进行互相的访问，那么此时就可以将两个 Pod 划分到不同的 Namespace 下。Kubernetes 通过将集群内部的资源分配到不同的 Namespace 中，可以形成逻辑上的组，以方便<strong>不同组的资源进行隔离使用和管理</strong>。</p><p>可以通过 Kubernetes 的授权机制，将不同的 Namespace 交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合 Kubernetes 的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。</p><img src="/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/image-20200407100850484.png" class="" title="image-20200407100850484"><p>Kubernetes 集群在启动时，默认创建的 namespace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get ns<br></code></pre></td></tr></table></figure><img src="/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/image-20210819093706629.png" class="" title="image-20210819093706629"><ul><li><p>default：所有未指定的 Namespace 的对象都会被分配在 default 命名空间。</p></li><li><p>kube-node-lease：集群节点之间的心跳维护，v1.13开始引入。</p></li><li><p>kube-public：此命名空间的资源可以被所有人访问（包括未认证用户）。</p></li><li><p>kube-system：所有由 kubernetes 系统创建的资源都处于这个命名空间。</p></li></ul><h3 id="2-2-具体操作"><a href="#2-2-具体操作" class="headerlink" title="2.2 具体操作"></a>2.2 具体操作</h3><p><strong>查看</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1 查看所有的ns  命令：kubectl get ns</span><br>[root@master ~]# kubectl get ns<br>NAME              STATUS   AGE<br>default           Active   20h<br>dev               Active   11h<br>kube-node-lease   Active   20h<br>kube-public       Active   20h<br>kube-system       Active   20h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2 查看指定ns  命令：kubectl get ns ns名称</span><br>[root@master ~]# kubectl get ns default<br>NAME      STATUS   AGE<br>default   Active   20h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3 指定输出格式  命令：kubectl get ns ns名称  -o 格式参数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">kubernetes支持的格式有很多，比较常见的是wide、json、yaml</span><br>[root@master ~]# kubectl get ns default -o yaml<br>apiVersion: v1<br>kind: Namespace<br>metadata:<br>  creationTimestamp: &quot;2021-08-18T05:13:25Z&quot;<br>  managedFields:<br>  - apiVersion: v1<br>    fieldsType: FieldsV1<br>    fieldsV1:<br>      f:status:<br>        f:phase: &#123;&#125;<br>    manager: kube-apiserver<br>    operation: Update<br>    time: &quot;2021-08-18T05:13:25Z&quot;<br>  name: default<br>  resourceVersion: &quot;152&quot;<br>  selfLink: /api/v1/namespaces/default<br>  uid: b4e03afe-dcdd-41a8-891f-d2a7333d6be1<br>spec:<br>  finalizers:<br>  - kubernetes<br>status:<br>  phase: Active<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4 查看ns详情  命令：kubectl describe ns ns名称</span><br>[root@master ~]# kubectl describe ns default<br>Name:         default<br>Labels:       &lt;none&gt;<br>Annotations:  &lt;none&gt;<br>Status:       Active<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ResourceQuota 针对namespace做的资源限制</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">LimitRange针对namespace中的每个组件做的资源限制</span><br>No resource quota.<br>No LimitRange resource.<br></code></pre></td></tr></table></figure><p><strong>创建</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建namespace</span><br>[root@master ~]# kubectl create ns dev<br>namespace/dev created<br></code></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除namespace</span><br>[root@master ~]# kubectl delete ns dev<br>namespace &quot;dev&quot; deleted<br></code></pre></td></tr></table></figure><p><strong>配置方式</strong></p><p>首先准备一个yaml文件：ns-dev.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>然后就可以执行对应的创建和删除命令了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建</span><br>kubectl create -f ns-dev.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除</span><br>kubectl delete -f ns-dev.yaml<br></code></pre></td></tr></table></figure><h2 id="3-Pod"><a href="#3-Pod" class="headerlink" title="3. Pod"></a>3. Pod</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>Pod 是 Kubernetes 集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于 Pod 中。</p><p>Pod 可以认为是容器的封装，一个 Pod 中可以存在一个或多个容器</p><img src="/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/image-20200407121501907.png" class="" title="image-20200407121501907"><p>Kubernetes 在集群启动之后，集群中的各个组件也是以 Pod 方式运行的，可以通过下面的命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods -n kube-system<br></code></pre></td></tr></table></figure><img src="/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/image-20210819095430743.png" class="" title="image-20210819095430743"><p>其中<code>etcd-master、kube-apiserver-master、kube-controller-manager-master、kube-scheduler-master</code>就是master的几个核心组件</p><h3 id="3-2-具体操作"><a href="#3-2-具体操作" class="headerlink" title="3.2 具体操作"></a>3.2 具体操作</h3><p><strong>创建并运行</strong></p><p>Kubernetes 没有提供单独运行Pod的命令，都是通过 Pod 控制器来实现的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令格式： kubectl run (pod控制器名称) [参数]</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">--image  指定Pod的镜像</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--port   指定端口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--namespace  指定namespace</span><br>[root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --namespace dev <br>deployment.apps/nginx created<br></code></pre></td></tr></table></figure><p><strong>查看pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod基本信息</span><br>[root@master ~]# kubectl get pods -n dev<br>NAME    READY   STATUS    RESTARTS   AGE<br>nginx   1/1     Running   0          4m41s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Pod的详细信息</span><br>[root@master ~]# kubectl describe pod nginx -n dev<br>Name:         nginx<br>Namespace:    dev<br>Priority:     0<br>Node:         node01/192.168.249.101<br>Start Time:   Thu, 19 Aug 2021 09:59:48 +0800<br>Labels:       run=nginx<br>Annotations:  cni.projectcalico.org/podIP: 10.244.196.133/32<br>              cni.projectcalico.org/podIPs: 10.244.196.133/32<br>Status:       Running<br>IP:           10.244.196.133<br>IPs:<br>  IP:  10.244.196.133<br>Containers:<br>  nginx:<br>    Container ID:   docker://978b27ca2750f7feb07d4a6d9cec7197c14ff683efe687ee33cf69fcc2c0c5c4<br>    Image:          nginx:1.17.1<br>    Image ID:       docker-pullable://nginx@sha256:b4b9b3eee194703fc2fa8afa5b7510c77ae70cfba567af1376a573a967c03dbb<br>    Port:           80/TCP<br>    Host Port:      0/TCP<br>    State:          Running<br>      Started:      Thu, 19 Aug 2021 09:59:49 +0800<br>    Ready:          True<br>    Restart Count:  0<br>    Environment:    &lt;none&gt;<br>    Mounts:<br>      /var/run/secrets/kubernetes.io/serviceaccount from default-token-54tz8 (ro)<br>Conditions:<br>  Type              Status<br>  Initialized       True <br>  Ready             True <br>  ContainersReady   True <br>  PodScheduled      True <br>Volumes:<br>  default-token-54tz8:<br>    Type:        Secret (a volume populated by a Secret)<br>    SecretName:  default-token-54tz8<br>    Optional:    false<br>QoS Class:       BestEffort<br>Node-Selectors:  &lt;none&gt;<br>Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s<br>                 node.kubernetes.io/unreachable:NoExecute for 300s<br>Events:<br>  Type    Reason     Age    From               Message<br>  ----    ------     ----   ----               -------<br>  Normal  Scheduled  5m21s  default-scheduler  Successfully assigned dev/nginx to node01<br>  Normal  Pulled     5m20s  kubelet, node01    Container image &quot;nginx:1.17.1&quot; already present on machine<br>  Normal  Created    5m20s  kubelet, node01    Created container nginx<br>  Normal  Started    5m20s  kubelet, node01    Started container nginx<br></code></pre></td></tr></table></figure><p><strong>访问pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取podIP</span><br>[root@master ~]# kubectl get pod -n dev -o wide<br>NAME    READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES<br>nginx   1/1     Running   0          10m   10.244.196.133   node01   &lt;none&gt;           &lt;none&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">访问pod</span><br>[root@master ~]# curl 10.244.140.69:80<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>    body &#123;<br>        width: 35em;<br>        margin: 0 auto;<br>        font-family: Tahoma, Verdana, Arial, sans-serif;<br>    &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>删除指定Pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定Pod</span><br>[root@master ~]# kubectl delete pod nginx -n dev<br>pod &quot;nginx&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时，显示删除Pod成功，但是再查询，发现又新产生了一个</span> <br>[root@master ~]# kubectl get pods -n dev<br>NAME    READY   STATUS    RESTARTS   AGE<br>nginx   1/1     Running   0          21s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时要想删除Pod，必须删除Pod控制器</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">先来查询一下当前namespace下的Pod控制器</span><br>[root@master ~]# kubectl get deploy -n  dev<br>NAME    READY   UP-TO-DATE   AVAILABLE   AGE<br>nginx   1/1     1            1           9m7s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来，删除此PodPod控制器</span><br>[root@master ~]# kubectl delete deploy nginx -n dev<br>deployment.apps &quot;nginx&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">稍等片刻，再查询Pod，发现Pod被删除了</span><br>[root@master ~]# kubectl get pods -n dev<br>No resources found in dev namespace.<br></code></pre></td></tr></table></figure><p><strong>配置操作</strong></p><p>创建一个pod-nginx.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><p>然后就可以执行对应的创建和删除命令了：</p><p>创建：kubectl create -f pod-nginx.yaml</p><p>删除：kubectl delete -f pod-nginx.yaml</p><h2 id="4-Label"><a href="#4-Label" class="headerlink" title="4. Label"></a>4. Label</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>Label 是 Kubernetes 的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p><p>Label 的特点：</p><ul><li><p>一个 Label 会以 key&#x2F;value 键值对的形式附加到各个对象上，如Nod、Pod、Service等</p></li><li><p>一个资源对象可以定义任意数量的 Label，同意给 Label 也可以被添加到任意数量的资源对象上</p></li><li><p>Label 通常在资源对象定义时确定，当然也可以在对象创建后动态的添加或删除</p></li></ul><p>可以通过 Label 实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置和部署等管理工作</p><p>一些常用的Label标签示例如下：</p><ul><li><p>版本标签：“version”:”release”,”version”:”stable”</p></li><li><p>环境标签：“environment”:”dev”,“environment”:”test”,“environment”:”pro”</p></li><li><p>架构标签：“tier”:”frontend”,”tier”:”backend”</p></li></ul><p>标签定义完毕之后，还要考虑到标签的选择，这就要用到Label Selector，即：</p><ul><li>Label 用于给某个资源对象定义标识。</li><li>Label Selector 用于查询和筛选拥有某些标签的资源对象。</li></ul><p>当前有两种Label Selector：</p><ul><li><p>基于等式的Label Selector。</p><ul><li>name&#x3D;slave：选择所有包含Label中的key&#x3D;“name”并且value&#x3D;“slave”的对象。</li><li>env!&#x3D;production：选择所有包含Label中的key&#x3D;“name”并且value!&#x3D;“production”的对象。</li></ul></li><li><p>基于集合的Label Selector。</p><ul><li>name in (master,slave)：选择所有包含Label中的key&#x3D;“name”并且value&#x3D;“master”或value&#x3D;“slave”的对象。</li><li>name not in (master,slave)：选择所有包含Label中的key&#x3D;“name”并且value!&#x3D;“master”和value!&#x3D;“slave”的对象。</li></ul></li><li><p>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号（,）进行分隔即可。</p><ul><li>name&#x3D;salve,env!&#x3D;production。</li><li>name not in (master,slave),env!&#x3D;production。</li></ul></li></ul><h3 id="4-2-具体操作"><a href="#4-2-具体操作" class="headerlink" title="4.2 具体操作"></a>4.2 具体操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">为pod资源打标签</span><br>[root@master ~]# kubectl label pod nginx -n dev version=1.0<br>pod/nginx labeled<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看标签</span><br>[root@master ~]# kubectl get pod -n dev --show-labels      <br>NAME    READY   STATUS    RESTARTS   AGE   LABELS<br>nginx   1/1     Running   0          95s   version=1.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为pod资源更新标签</span><br>[root@master ~]# kubectl label pod nginx -n dev version=2.0 --overwrite<br>pod/nginx labeled<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看标签</span><br>[root@master ~]# kubectl get pod -n dev --show-labels                  <br>NAME    READY   STATUS    RESTARTS   AGE     LABELS<br>nginx   1/1     Running   0          2m53s   version=2.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">筛选标签</span><br>[root@master ~]# kubectl get pod -n dev -l version=2.0 --show-labels<br>NAME    READY   STATUS    RESTARTS   AGE     LABELS<br>nginx   1/1     Running   0          4m10s   version=2.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除标签</span><br>[root@master ~]# kubectl label pod nginx version- -n dev<br>pod/nginx labeled<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看标签</span><br>[root@master ~]# kubectl get pod -n dev --show-labels               <br>NAME    READY   STATUS    RESTARTS   AGE     LABELS<br>nginx   1/1     Running   0          4m50s   &lt;none&gt;<br></code></pre></td></tr></table></figure><p><strong>配置方式</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.0&quot;</span> <br>    <span class="hljs-attr">env:</span> <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><p>执行对应的更新命令：kubectl apply -f pod-nginx.yaml</p><h2 id="5-Deployment"><a href="#5-Deployment" class="headerlink" title="5. Deployment"></a>5. Deployment</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。</p><p>Pod控制器用于Pod的管理，确保Pod资源符合预期的状态，当Pod的资源出现故障的时候，会尝试进行重启或重建Pod。</p><p>在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。</p><img src="/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/image-20200408193950807.png" class="" title="image-20200408193950807"><h3 id="5-2-具体操作"><a href="#5-2-具体操作" class="headerlink" title="5.2 具体操作"></a>5.2 具体操作</h3><p><strong>命令操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在指定的命名空间下创建指定名称的deployment</span><br>[root@master ~]# kubectl create deployment nginx --image=nginx:1.17.1 -n dev<br>deployment.apps/nginx created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">根据指定的deployment创建pod</span><br>[root@master ~]# kubectl scale deployment nginx --replicas=3 -n dev<br>deployment.apps/nginx scaled<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定命名空间下的pod</span><br>[root@master ~]# kubectl get pods -n dev<br>NAME                     READY   STATUS    RESTARTS   AGE<br>nginx-59975f44cf-2ddqk   1/1     Running   0          2m1s<br>nginx-59975f44cf-hx9mj   1/1     Running   0          12s<br>nginx-59975f44cf-wkvmg   1/1     Running   0          12s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看deployment的信息</span><br>[root@master ~]# kubectl get deploy -n dev<br>NAME    READY   UP-TO-DATE   AVAILABLE   AGE<br>nginx   3/3     3            3           33m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">UP-TO-DATE：成功升级的副本数量</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">AVAILABLE：可用副本的数量</span><br>[root@master ~]# kubectl get deploy -n dev -o wide<br>NAME    READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR<br>nginx   3/3     3            3           34m   nginx        nginx:1.17.1   app=nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看deployment的详细信息</span><br>[root@master ~]# kubectl describe deploy -n dev<br>Name:                   nginx<br>Namespace:              dev<br>CreationTimestamp:      Thu, 19 Aug 2021 11:44:38 +0800<br>Labels:                 app=nginx<br>Annotations:            deployment.kubernetes.io/revision: 1<br>Selector:               app=nginx<br>Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable<br>StrategyType:           RollingUpdate<br>MinReadySeconds:        0<br>RollingUpdateStrategy:  25% max unavailable, 25% max surge<br>Pod Template:<br>  Labels:  app=nginx<br>  Containers:<br>   nginx:<br>    Image:        nginx:1.17.1<br>    Port:         &lt;none&gt;<br>    Host Port:    &lt;none&gt;<br>    Environment:  &lt;none&gt;<br>    Mounts:       &lt;none&gt;<br>  Volumes:        &lt;none&gt;<br>Conditions:<br>  Type           Status  Reason<br>  ----           ------  ------<br>  Progressing    True    NewReplicaSetAvailable<br>  Available      True    MinimumReplicasAvailable<br>OldReplicaSets:  &lt;none&gt;<br>NewReplicaSet:   nginx-59975f44cf (3/3 replicas created)<br>Events:<br>  Type    Reason             Age   From                   Message<br>  ----    ------             ----  ----                   -------<br>  Normal  ScalingReplicaSet  35m   deployment-controller  Scaled up replica set nginx-59975f44cf to 1<br>  Normal  ScalingReplicaSet  33m   deployment-controller  Scaled up replica set nginx-59975f44cf to 3<br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除</span><br>[root@master ~]# kubectl delete deploy nginx -n dev<br>deployment.apps &quot;nginx&quot; deleted<br></code></pre></td></tr></table></figure><p><strong>配置操作</strong></p><p>配置一个deploy-nginx.yaml，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: nginx<br>  namespace: dev<br>spec:<br>  replicas: 3<br>  selector:<br>    matchLabels:<br>      run: nginx<br>  template:<br>    metadata:<br>      labels:<br>        run: nginx<br>    spec:<br>      containers:<br>      - image: nginx:latest<br>        name: nginx<br>        ports:<br>        - containerPort: 80<br>          protocol: TCP<br></code></pre></td></tr></table></figure><p>然后就可以执行对应的创建和删除命令了：</p><p>创建：kubectl create -f deploy-nginx.yaml</p><p>删除：kubectl delete -f deploy-nginx.yaml</p><h2 id="6-Service"><a href="#6-Service" class="headerlink" title="6. Service"></a>6. Service</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>我们已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务，虽然每个Pod都会分配一个单独的Pod的IP地址，但是却存在如下的问题：</p><ul><li><p>Pod的IP会随着Pod的重建产生变化。</p></li><li><p>Pod的IP仅仅是集群内部可见的虚拟的IP，外部无法访问。</p></li></ul><p>这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。</p><p>Service可以看作是一组同类Pod<strong>对外的访问接口</strong>。借助Service，应用可以方便地实现服务发现和负载均衡。</p><img src="/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/image-20200408194716912.png" class="" title="image-20200408194716912"><h3 id="6-2-具体操作"><a href="#6-2-具体操作" class="headerlink" title="6.2 具体操作"></a>6.2 具体操作</h3><h4 id="6-2-1-创建集群内部可访问的Service"><a href="#6-2-1-创建集群内部可访问的Service" class="headerlink" title="6.2.1 创建集群内部可访问的Service"></a>6.2.1 创建集群内部可访问的Service</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">暴露Service</span><br>[root@master ~]# kubectl expose deployment nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev<br>service/svc-nginx1 exposed<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Service</span><br>[root@master ~]# kubectl get service -n dev<br>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>svc-nginx1   ClusterIP   10.98.54.168   &lt;none&gt;        80/TCP    46s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里产生了一个ClusterIP，这就是service的IP，在service的生命周期中，IP是不会变得</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以通过这个IP访问当前service对应的pod（只能在集群内部访问）</span><br>[root@master ~]# curl 10.98.54.168:80<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>    body &#123;<br>        width: 35em;<br>        margin: 0 auto;<br>        font-family: Tahoma, Verdana, Arial, sans-serif;<br>    &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="6-2-2-创建集群外部也可以访问的Service"><a href="#6-2-2-创建集群外部也可以访问的Service" class="headerlink" title="6.2.2 创建集群外部也可以访问的Service"></a>6.2.2 创建集群外部也可以访问的Service</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">上面创建的Service的<span class="hljs-built_in">type</span>类型为ClusterIP，这个ip地址只用集群内部可访问</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果需要创建外部也可以访问的Service，需要修改<span class="hljs-built_in">type</span>为NodePort</span><br>[root@master ~]# kubectl expose deployment nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev<br>service/svc-nginx2 exposed<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:32353/TCP）</span><br>[root@master ~]# kubectl get svc -n dev<br>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE<br>svc-nginx1   ClusterIP   10.98.54.168    &lt;none&gt;        80/TCP         4m41s<br>svc-nginx2   NodePort    10.111.231.79   &lt;none&gt;        80:32353/TCP   15s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来就可以通过集群外的主机访问 节点IP:32353访问服务了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例如在的电脑主机上通过浏览器访问下面的地址</span><br>192.168.249.100:32353<br></code></pre></td></tr></table></figure><img src="/2021/08/19/Kubernetes-%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/image-20210819125132621.png" class="" title="image-20210819125132621"><h4 id="6-2-3-删除Service"><a href="#6-2-3-删除Service" class="headerlink" title="6.2.3 删除Service"></a>6.2.3 删除Service</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl delete svc svc-nginx2 -n dev<br>service &quot;svc-nginx2&quot; deleted<br>[root@master ~]# kubectl get svc -n dev              <br>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>svc-nginx1   ClusterIP   10.98.54.168   &lt;none&gt;        80/TCP    7m12s<br></code></pre></td></tr></table></figure><h4 id="6-2-4-配置方式"><a href="#6-2-4-配置方式" class="headerlink" title="6.2.4 配置方式"></a>6.2.4 配置方式</h4><p>创建一个svc-nginx.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">svc-nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.109</span><span class="hljs-number">.179</span><span class="hljs-number">.231</span> <span class="hljs-comment">#固定svc的内网ip</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br></code></pre></td></tr></table></figure><p>然后就可以执行对应的创建和删除命令了：</p><p>创建：kubectl create -f svc-nginx.yaml</p><p>删除：kubectl delete -f svc-nginx.yaml</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-资源管理</title>
    <link href="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <url>/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-资源管理"><a href="#Kubernetes-资源管理" class="headerlink" title="Kubernetes-资源管理"></a>Kubernetes-资源管理</h1><h2 id="1-资源管理介绍"><a href="#1-资源管理介绍" class="headerlink" title="1. 资源管理介绍"></a>1. 资源管理介绍</h2><p>在 Kubernetes 中，所有的内容都抽象为资源，用户需要通过操作资源来管理 Kubernetes。</p><blockquote><p>Kubernetes 的本质就是一个集群系统，用户可以在集群中部署各种服务。所谓的部署服务，其实就是在 Kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p><p>Kubernetes 的最小管理单元是 Pod 而不是容器，所以只能将容器放在 Pod 中，而 Kubernetes 一般也不会直接管理 Pod，而是通过 Pod 控制器来管理Pod。</p><p>Pod 提供服务之后，就需要考虑如何访问 Pod 中的服务，Kubernetes 提供了 Service 资源实现这个功能。</p><p>当然，如果 Pod 中程序的数据需要持久化，Kubernetes 还提供了各种存储系统。</p></blockquote><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20200406225334627.png" class="" title="image-20200406225334627"><p>学习kubernets的核心，就是学习如何对集群中的 <strong>Pod、Pod 控制器、Service、存储</strong>等各种资源进行操作。</p><h2 id="2-YAML介绍"><a href="#2-YAML介绍" class="headerlink" title="2. YAML介绍"></a>2. YAML介绍</h2><h3 id="2-1-YAML语法介绍"><a href="#2-1-YAML语法介绍" class="headerlink" title="2.1 YAML语法介绍"></a>2.1 YAML语法介绍</h3><ul><li><p>YAML是一个类似于XML、JSON的标记性语言。它强调的是以“数据”为中心，并不是以标记语言为重点。因而YAML本身的定义比较简单，号称是“一种人性化的数据格式语言”。</p></li><li><p>YAML的语法比较简单，主要有下面的几个：</p><ul><li>大小写敏感。</li><li>使用缩进表示层级关系。</li><li>缩进不允许使用tab，只允许空格（低版本限制）。</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可。</li><li>‘#’表示注释。</li></ul></li><li><p>YAML支持以下几种数据类型：</p><ul><li>常量：单个的、不能再分的值。</li><li>对象：键值对的集合，又称为映射&#x2F;哈希&#x2F;字典。</li><li>数组：一组按次序排列的值，又称为序列&#x2F;列表。</li></ul></li></ul><h3 id="2-2-YAML语法实例"><a href="#2-2-YAML语法实例" class="headerlink" title="2.2 YAML语法实例"></a>2.2 YAML语法实例</h3><h4 id="2-2-1-YAML常量"><a href="#2-2-1-YAML常量" class="headerlink" title="2.2.1 YAML常量"></a>2.2.1 YAML常量</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#常量，就是指的是一个简单的值，字符串、布尔值、整数、浮点数、NUll、时间、日期</span><br><span class="hljs-comment"># 布尔类型</span><br><span class="hljs-attr">c1:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 整型</span><br><span class="hljs-attr">c2:</span> <span class="hljs-number">123456</span><br><span class="hljs-comment"># 浮点类型</span><br><span class="hljs-attr">c3:</span> <span class="hljs-number">3.14</span><br><span class="hljs-comment"># null类型</span><br><span class="hljs-attr">c4:</span> <span class="hljs-string">~</span> <span class="hljs-comment"># 使用~表示null</span><br><span class="hljs-comment"># 日期类型</span><br><span class="hljs-attr">c5:</span> <span class="hljs-number">2020-11-11</span> <span class="hljs-comment"># 日期类型必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="hljs-comment"># 时间类型</span><br><span class="hljs-attr">c6:</span> <span class="hljs-number">2020-11-11T15:02:31+08</span><span class="hljs-number">.00</span> <span class="hljs-comment"># 时间类型使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br><span class="hljs-comment"># 字符串类型</span><br><span class="hljs-attr">c7:</span> <span class="hljs-string">haha</span> <span class="hljs-comment"># 简单写法，直接写值，如果字符串中间有特殊符号，必须使用双引号或单引号包裹</span><br><span class="hljs-attr">c8:</span> <span class="hljs-string">line1</span><br>    <span class="hljs-string">line2</span> <span class="hljs-comment"># 字符串过多的情况可以折成多行，每一行都会转换成一个空格</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-对象"><a href="#2-2-2-对象" class="headerlink" title="2.2.2 对象"></a>2.2.2 对象</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 对象</span><br><span class="hljs-comment"># 形式一（推荐）：</span><br><span class="hljs-attr">dongys:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">dongys</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-comment"># 形式二（了解）：</span><br><span class="hljs-attr">dongys:</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">dongys</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">18</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-数组"><a href="#2-2-3-数组" class="headerlink" title="2.2.3 数组"></a>2.2.3 数组</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 数组</span><br><span class="hljs-comment"># 形式一（推荐）：</span><br><span class="hljs-attr">address:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">江苏</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">北京</span><br><span class="hljs-comment"># 形式二（了解）：</span><br><span class="hljs-attr">address:</span> [<span class="hljs-string">江苏</span>,<span class="hljs-string">上海</span>]<br></code></pre></td></tr></table></figure><h2 id="3-资源管理方式"><a href="#3-资源管理方式" class="headerlink" title="3. 资源管理方式"></a>3. 资源管理方式</h2><ul><li><p>命令式对象管理：直接使用命令去操作 Kubernetes 资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl run nginx-pod --image=nginx:1.17.1 --port=80<br></code></pre></td></tr></table></figure></li><li><p>命令式对象配置：通过命令配置和配置文件去操作 Kubernetes 资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create/patch -f nginx-pod.yaml<br></code></pre></td></tr></table></figure></li><li><p>声明式对象配置：通过 apply 命令和配置文件去操作 Kubernetes 资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f nginx-pod.yaml<br></code></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="left">类型</th><th align="left">操作对象</th><th align="left">适用环境</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">命令式对象管理</td><td align="left">对象</td><td align="left">测试</td><td align="left">简单</td><td align="left">只能操作活动对象，无法审计、跟踪</td></tr><tr><td align="left">命令式对象配置</td><td align="left">文件</td><td align="left">开发</td><td align="left">可以审计、跟踪</td><td align="left">项目大时，配置文件多，操作麻烦</td></tr><tr><td align="left">声明式对象配置</td><td align="left">目录</td><td align="left">开发</td><td align="left">支持目录操作</td><td align="left">意外情况下难以调试</td></tr></tbody></table><h3 id="3-1-命令式对象管理"><a href="#3-1-命令式对象管理" class="headerlink" title="3.1 命令式对象管理"></a>3.1 命令式对象管理</h3><h4 id="3-2-1-kubectl命令"><a href="#3-2-1-kubectl命令" class="headerlink" title="3.2.1 kubectl命令"></a>3.2.1 kubectl命令</h4><p>kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署。</p><p>kubectl命令的语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl [command] [type] [name] [flags]<br></code></pre></td></tr></table></figure><ul><li><p>command：指定要对资源执行的操作，比如create、get、delete。</p></li><li><p>type：指定资源的类型，比如deployment、pod、service。</p></li><li><p>name：指定资源的名称，名称大小写敏感。</p></li><li><p>flags：指定额外的可选参数。</p></li></ul><p>示例：查看所有的pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods<br></code></pre></td></tr></table></figure><p>示例：查看某个pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pod pod_name<br></code></pre></td></tr></table></figure><p>示例：查看某个pod，以yaml格式展示结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pod pod_name -o yaml<br></code></pre></td></tr></table></figure><h4 id="3-2-2-操作（command）"><a href="#3-2-2-操作（command）" class="headerlink" title="3.2.2 操作（command）"></a>3.2.2 操作（command）</h4><p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl --help<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818163234093.png" class="" title="image-20210818163234093"><p>经常使用的操作如下所示：</p><ul><li><p>基本命令</p><table><thead><tr><th align="left">命令</th><th align="left">翻译</th><th align="left">命令作用</th></tr></thead><tbody><tr><td align="left">create</td><td align="left">创建</td><td align="left">创建一个资源</td></tr><tr><td align="left">edit</td><td align="left">编辑</td><td align="left">编辑一个资源</td></tr><tr><td align="left">get</td><td align="left">获取</td><td align="left">获取一个资源</td></tr><tr><td align="left">patch</td><td align="left">更新</td><td align="left">更新一个资源</td></tr><tr><td align="left">delete</td><td align="left">删除</td><td align="left">删除一个资源</td></tr><tr><td align="left">explain</td><td align="left">解释</td><td align="left">展示资源文档</td></tr></tbody></table></li><li><p>运行和调试</p><table><thead><tr><th>命令</th><th>翻译</th><th>命令作用</th></tr></thead><tbody><tr><td>run</td><td>运行</td><td>在集群中运行一个指定的镜像</td></tr><tr><td>expose</td><td>暴露</td><td>暴露资源为Service</td></tr><tr><td>describe</td><td>描述</td><td>显示资源内部信息</td></tr><tr><td>logs</td><td>日志</td><td>输出容器在Pod中的日志</td></tr><tr><td>attach</td><td>缠绕</td><td>进入运行中的容器</td></tr><tr><td>exec</td><td>执行</td><td>执行容器中的一个命令</td></tr><tr><td>cp</td><td>复制</td><td>在Pod内外复制文件</td></tr><tr><td>rollout</td><td>首次展示</td><td>管理资源的发布</td></tr><tr><td>scale</td><td>规模</td><td>扩（缩）容Pod的数量</td></tr><tr><td>autoscale</td><td>自动调整</td><td>自动调整Pod的数量</td></tr></tbody></table></li><li><p>高级命令</p><table><thead><tr><th>命令</th><th>翻译</th><th>命令作用</th></tr></thead><tbody><tr><td>apply</td><td>应用</td><td>通过文件对资源进行配置</td></tr><tr><td>label</td><td>标签</td><td>更新资源上的标签</td></tr></tbody></table></li><li><p>其他命令</p><table><thead><tr><th>命令</th><th>翻译</th><th>命令作用</th></tr></thead><tbody><tr><td>cluster-info</td><td>集群信息</td><td>显示集群信息</td></tr><tr><td>version</td><td>版本</td><td>显示当前Client和Server的版本</td></tr></tbody></table></li></ul><h4 id="3-2-3-资源类型（type）"><a href="#3-2-3-资源类型（type）" class="headerlink" title="3.2.3 资源类型（type）"></a>3.2.3 资源类型（type）</h4><p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl api-resources<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818181958733.png" class="" title="image-20210818181958733"><p>经常使用的资源如下所示：</p><ul><li><p>集群级别资源</p><table><thead><tr><th>资源名称</th><th>缩写</th><th>资源作用</th></tr></thead><tbody><tr><td>nodes</td><td>no</td><td>集群组成部分</td></tr><tr><td>namespaces</td><td>ns</td><td>隔离Pod</td></tr></tbody></table></li><li><p>Pod 资源</p><table><thead><tr><th>资源名称</th><th>缩写</th><th>资源作用</th></tr></thead><tbody><tr><td>Pods</td><td>po</td><td>装载容器</td></tr></tbody></table></li><li><p>Pod 资源控制器</p><table><thead><tr><th>资源名称</th><th>缩写</th><th>资源作用</th></tr></thead><tbody><tr><td>replicationcontrollers</td><td>rc</td><td>控制Pod资源</td></tr><tr><td>replicasets</td><td>rs</td><td>控制Pod资源</td></tr><tr><td>deployments</td><td>deploy</td><td>控制Pod资源</td></tr><tr><td>daemonsets</td><td>ds</td><td>控制Pod资源</td></tr><tr><td>jobs</td><td></td><td>控制Pod资源</td></tr><tr><td>cronjobs</td><td>cj</td><td>控制Pod资源</td></tr><tr><td>horizontalpodautoscalers</td><td>hpa</td><td>控制Pod资源</td></tr><tr><td>statefulsets</td><td>sts</td><td>控制Pod资源</td></tr></tbody></table></li><li><p>服务发现资源</p><table><thead><tr><th>资源名称</th><th>缩写</th><th>资源作用</th></tr></thead><tbody><tr><td>services</td><td>svc</td><td>统一Pod对外接口</td></tr><tr><td>ingress</td><td>ing</td><td>统一Pod对外接口</td></tr></tbody></table></li><li><p>存储资源</p><table><thead><tr><th>资源名称</th><th>缩写</th><th>资源作用</th></tr></thead><tbody><tr><td>volumeattachments</td><td></td><td>存储</td></tr><tr><td>persistentvolumes</td><td>pv</td><td>存储</td></tr><tr><td>persistentvolumeclaims</td><td>pvc</td><td>存储</td></tr></tbody></table></li><li><p>配置资源</p><table><thead><tr><th>资源名称</th><th>缩写</th><th>资源作用</th></tr></thead><tbody><tr><td>configmaps</td><td>cm</td><td>配置</td></tr><tr><td>secrets</td><td></td><td>配置</td></tr></tbody></table></li></ul><h4 id="3-2-4-应用示例"><a href="#3-2-4-应用示例" class="headerlink" title="3.2.4 应用示例"></a>3.2.4 应用示例</h4><ol><li>创建一个 namespace</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create namespace dev<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818182555681.png" class="" title="image-20210818182555681"><ol start="2"><li>获取 namespace</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get namespace<br>kubectl get ns<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818182655865.png" class="" title="image-20210818182655865"><ol start="3"><li>在刚才创建的namespace下创建并运行一个 Nginx 的 Pod</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl run nginx --image=nginx:1.17.1 -n dev<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818182809787.png" class="" title="image-20210818182809787"><ol start="4"><li>查看名为dev的namespace下的所有 Pod，如果不加-n，默认就是default的namespace</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods -n dev<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818182904844.png" class="" title="image-20210818182904844"><ol start="5"><li>删除指定 namespace 下的指定 Pod</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete pod nginx -n dev<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818214345656.png" class="" title="image-20210818214345656"><ol start="6"><li>删除指定的namespace</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete namespace dev<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818214426512.png" class="" title="image-20210818214426512"><h3 id="3-2-命令式对象配置"><a href="#3-2-命令式对象配置" class="headerlink" title="3.2 命令式对象配置"></a>3.2 命令式对象配置</h3><p>命令式对象配置：通过命令配置和配置文件去操作kubernetes的资源。</p><h4 id="3-2-1-应用示例"><a href="#3-2-1-应用示例" class="headerlink" title="3.2.1 应用示例"></a>3.2.1 应用示例</h4><ol><li>创建一个nginxpod.yaml，内容如下：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginxpod</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-containers</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br></code></pre></td></tr></table></figure><ol start="2"><li>执行create命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create -f nginxpod.yaml<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818214741680.png" class="" title="image-20210818214741680"><ol start="3"><li>执行get命令查看资源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get -f nginxpod.yaml<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818214820470.png" class="" title="image-20210818214820470"><ol start="4"><li>执行delete命令删除资源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete -f nginxpod.yaml<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818215050442.png" class="" title="image-20210818215050442"><p>命令式对象配置的方式操作资源，可以简单的认为：命令+yaml配置文件（里面是命令需要的各种参数）</p><h3 id="3-3-声明式对象配置"><a href="#3-3-声明式对象配置" class="headerlink" title="3.3 声明式对象配置"></a>3.3 声明式对象配置</h3><ul><li><p>声明式对象配置：通过apply命令和配置文件去操作kubernetes的资源。</p></li><li><p>声明式对象配置和命令式对象配置类似，只不过它只有一个apply命令。</p></li><li><p>apply相当于create和patch。</p></li></ul><h4 id="3-3-1-应用示例"><a href="#3-3-1-应用示例" class="headerlink" title="3.3.1 应用示例"></a>3.3.1 应用示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f nginxpod.yaml<br></code></pre></td></tr></table></figure><p>首次执行，发现创建了资源，第二次执行，发现资源没有变动</p><img src="/2021/08/18/Kubernetes-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/image-20210818215357480.png" class="" title="image-20210818215357480"><h4 id="3-3-2-总结"><a href="#3-3-2-总结" class="headerlink" title="3.3.2 总结"></a>3.3.2 总结</h4><ul><li><p>声明式对象配置就是使用apply描述一个资源的最终状态（在yaml中定义状态）。</p></li><li><p>使用apply操作资源：</p><ul><li>如果资源不存在，就创建，相当于kubectl create。</li><li>如果资源存在，就更新，相当于kubectl patch。</li></ul></li></ul><h3 id="3-4-扩展：kubectl可以在Node上运行"><a href="#3-4-扩展：kubectl可以在Node上运行" class="headerlink" title="3.4 扩展：kubectl可以在Node上运行"></a>3.4 扩展：kubectl可以在Node上运行</h3><p>kubectl的运行需要进行配置，它的配置文件是$HOME&#x2F;.kube，如果想要在Node节点上运行此命令，需要将Master节点的.kube文件夹复制到Node节点上，即在Master节点上执行下面的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r $HOME/.kube node01:$HOME<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-集群搭建</title>
    <link href="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-集群搭建"><a href="#Kubernetes-集群搭建" class="headerlink" title="Kubernetes-集群搭建"></a>Kubernetes-集群搭建</h1><h2 id="1-环境规划"><a href="#1-环境规划" class="headerlink" title="1. 环境规划"></a>1. 环境规划</h2><h3 id="1-1-集群类型"><a href="#1-1-集群类型" class="headerlink" title="1.1 集群类型"></a>1.1 集群类型</h3><ul><li><p>Kubernetes集群大致分为两类：一主多从和多主多从。</p></li><li><p>一主多从：一个Master节点和多台Node节点，搭建简单，但是有单机故障风险，适合用于测试环境。</p></li><li><p>多主多从：多台Master和多台Node节点，搭建麻烦，安全性高，适合用于生产环境。</p></li></ul><img src="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20200404094800622.png" class="" title="image-20200404094800622"><p>为了测试方便，本次搭建的是一主多从类型的集群</p><h3 id="1-2-安装方式"><a href="#1-2-安装方式" class="headerlink" title="1.2 安装方式"></a>1.2 安装方式</h3><ul><li>kubernetes有多种部署方式，目前主流的方式有kubeadm、minikube、二进制包。</li><li>minikube：一个用于快速搭建单节点的kubernetes工具。</li><li>kubeadm：一个用于快速搭建kubernetes集群的工具。</li><li>二进制包：从官网上下载每个组件的二进制包，依次去安装，此方式对于理解kubernetes组件更加有效。</li></ul><p>我们需要安装kubernetes的集群环境，但是又不想过于麻烦，所以选择kubeadm方式。</p><h3 id="1-3-主机规划"><a href="#1-3-主机规划" class="headerlink" title="1.3 主机规划"></a>1.3 主机规划</h3><table><thead><tr><th>角色</th><th>IP地址</th><th>操作系统</th><th>配置</th></tr></thead><tbody><tr><td>Master</td><td>192.168.249.100</td><td>CentOS7.8+，基础设施服务器</td><td>2核CPU，2G内存，50G硬盘</td></tr><tr><td>Node1</td><td>192.168.249.101</td><td>CentOS7.8+，基础设施服务器</td><td>2核CPU，2G内存，50G硬盘</td></tr><tr><td>Node2</td><td>192.168.249.102</td><td>CentOS7.8+，基础设施服务器</td><td>2核CPU，2G内存，50G硬盘</td></tr></tbody></table><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><h3 id="2-1-前言"><a href="#2-1-前言" class="headerlink" title="2.1 前言"></a>2.1 前言</h3><p>本次环境搭建需要三台CentOS服务器（一主二从），然后在每台服务器中分别安装Docker（18.06.3）、kubeadm（1.18.0）、kubectl（1.18.0）和kubelet（1.18.0）。</p><h3 id="2-2-环境初始化"><a href="#2-2-环境初始化" class="headerlink" title="2.2 环境初始化"></a>2.2 环境初始化</h3><h4 id="2-2-1-检查操作系统的版本"><a href="#2-2-1-检查操作系统的版本" class="headerlink" title="2.2.1 检查操作系统的版本"></a>2.2.1 检查操作系统的版本</h4><p>检查操作系统的版本（要求操作系统的版本至少在7.5以上）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/redhat-release<br></code></pre></td></tr></table></figure><h4 id="2-2-2-关闭防火墙"><a href="#2-2-2-关闭防火墙" class="headerlink" title="2.2.2 关闭防火墙"></a>2.2.2 关闭防火墙</h4><p>关闭并禁用防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop firewalld &amp;&amp; systemctl disable firewalld<br></code></pre></td></tr></table></figure><h4 id="2-2-3-设置主机名"><a href="#2-2-3-设置主机名" class="headerlink" title="2.2.3 设置主机名"></a>2.2.3 设置主机名</h4><p>设置主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hostnamectl set-hostname &lt;hostname&gt;<br></code></pre></td></tr></table></figure><p>分别设置三台机器的主机名：master、node1、node02</p><h4 id="2-2-4-主机名解析"><a href="#2-2-4-主机名解析" class="headerlink" title="2.2.4 主机名解析"></a>2.2.4 主机名解析</h4><p>为了方便后面集群节点间的直接调用，需要配置一下主机名解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF&gt;&gt; /etc/hosts<br>192.168.249.100 master<br>192.168.249.101 node01<br>192.168.249.102 node02<br>EOF<br></code></pre></td></tr></table></figure><p>配置其他两台机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /etc/hosts root@192.168.249.101:/etc/hosts <br>scp /etc/hosts root@192.168.249.102:/etc/hosts <br></code></pre></td></tr></table></figure><h4 id="2-2-5-时间同步"><a href="#2-2-5-时间同步" class="headerlink" title="2.2.5 时间同步"></a>2.2.5 时间同步</h4><p>kubernetes要求集群中的节点时间必须精确一致，所以在每个节点上添加时间同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install ntpdate -y<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ntpdate time.windows.com<br></code></pre></td></tr></table></figure><h4 id="2-2-6-关闭selinux"><a href="#2-2-6-关闭selinux" class="headerlink" title="2.2.6 关闭selinux"></a>2.2.6 关闭selinux</h4><p>selinux是linux系统下的一个安全服务，如果不关闭，会产生许多bug</p><p>查看selinux是否开启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">getenforce<br></code></pre></td></tr></table></figure><p>永久关闭selinux，需要重启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config<br></code></pre></td></tr></table></figure><h4 id="2-2-7-关闭swap分区"><a href="#2-2-7-关闭swap分区" class="headerlink" title="2.2.7 关闭swap分区"></a>2.2.7 关闭swap分区</h4><p>永久关闭swap分区，需要重启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab<br></code></pre></td></tr></table></figure><h4 id="2-2-8-修改linux内核参数"><a href="#2-2-8-修改linux内核参数" class="headerlink" title="2.2.8 修改linux内核参数"></a>2.2.8 修改linux内核参数</h4><p>在每个节点上将桥接的IPv4流量传递到iptables的链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF<br>net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>net.ipv4.ip_forward = 1<br>vm.swappiness = 0<br>EOF<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加载br_netfilter模块</span><br>modprobe br_netfilter<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否加载</span><br>lsmod | grep br_netfilter<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生效</span><br>sysctl --system<br></code></pre></td></tr></table></figure><h4 id="2-2-9-开启ipvs"><a href="#2-2-9-开启ipvs" class="headerlink" title="2.2.9 开启ipvs"></a>2.2.9 开启ipvs</h4><p>在kubernetes中service有两种代理模型，一种是基于iptables，另一种是基于ipvs的。ipvs的性能要高于iptables的，但是如果要使用它，需要手动载入ipvs模块。</p><p>在每个节点安装ipset和ipvsadm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install ipset ipvsadm<br></code></pre></td></tr></table></figure><p>在所有节点执行如下脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>modprobe -- ip_vs<br>modprobe -- ip_vs_rr<br>modprobe -- ip_vs_wrr<br>modprobe -- ip_vs_sh<br>modprobe -- nf_conntrack_ipv4<br>EOF<br></code></pre></td></tr></table></figure><p>授权、运行、检查是否加载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4<br></code></pre></td></tr></table></figure><p>检查是否加载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsmod | grep -e ipvs -e nf_conntrack_ipv4<br></code></pre></td></tr></table></figure><h4 id="2-2-10-重启三台机器"><a href="#2-2-10-重启三台机器" class="headerlink" title="2.2.10 重启三台机器"></a>2.2.10 重启三台机器</h4><p>重启三台Linux机器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">reboot<br></code></pre></td></tr></table></figure><h3 id="2-3-安装Docker"><a href="#2-3-安装Docker" class="headerlink" title="2.3 安装Docker"></a>2.3 安装Docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置阿里镜像</span><br>wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装docker</span><br>yum -y install docker-ce-18.06.3.ce-3.el7<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启docker</span><br>systemctl enable docker &amp;&amp; systemctl start docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看版本</span><br>docker version<br></code></pre></td></tr></table></figure><p>设置docker镜像加速器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置文件</span><br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;], <br>  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;], <br>  &quot;live-restore&quot;: true,<br>  &quot;log-driver&quot;:&quot;json-file&quot;,<br>  &quot;log-opts&quot;: &#123;&quot;max-size&quot;:&quot;500m&quot;, &quot;max-file&quot;:&quot;3&quot;&#125;<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启docker</span><br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="2-4-安装kubernetes组件"><a href="#2-4-安装kubernetes组件" class="headerlink" title="2.4 安装kubernetes组件"></a>2.4 安装kubernetes组件</h3><p>由于kubernetes的镜像源在国外，非常慢，这里切换成国内的阿里云镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF<br>[kubernetes]<br>name=Kubernetes<br>baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64<br>enabled=1<br>gpgcheck=0<br>repo_gpgcheck=0<br>gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg<br>EOF<br></code></pre></td></tr></table></figure><p>指定版本安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0<br></code></pre></td></tr></table></figure><p>为了实现Docker使用的cgroup drvier和kubelet使用的cgroup drver一致，修改”&#x2F;etc&#x2F;sysconfig&#x2F;kubelet”文件的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysconfig/kubelet<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改</span><br>KUBELET_EXTRA_ARGS=&quot;--cgroup-driver=systemd&quot;<br>KUBE_PROXY_MODE=&quot;ipvs&quot;<br></code></pre></td></tr></table></figure><p>设置为开机自启动，由于没有生成配置文件，集群初始化后自动启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable kubelet<br></code></pre></td></tr></table></figure><h3 id="2-5-部署k8s的Master节点"><a href="#2-5-部署k8s的Master节点" class="headerlink" title="2.5 部署k8s的Master节点"></a>2.5 部署k8s的Master节点</h3><p>部署k8s的Master节点（192.168.249.100）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里需要指定阿里云镜像仓库地址</span><br>kubeadm init \<br>  --apiserver-advertise-address=192.168.249.100 \<br>  --image-repository registry.aliyuncs.com/google_containers \<br>  --kubernetes-version v1.18.0 \<br>  --service-cidr=10.96.0.0/12 \<br>  --pod-network-cidr=10.244.0.0/16<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20210818123448505.png" class="" title="image-20210818123448505"><p>根据提示信息，在Master节点上使用kubectl工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config<br></code></pre></td></tr></table></figure><h3 id="2-6-部署k8s的Node节点"><a href="#2-6-部署k8s的Node节点" class="headerlink" title="2.6 部署k8s的Node节点"></a>2.6 部署k8s的Node节点</h3><p>根据提示，在另外两台node节点上添加如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm join 192.168.249.100:6443 --token m59k69.kslw8zpffscnprnv \<br>    --discovery-token-ca-cert-hash sha256:4ca0238fcdd5cb98336bbcc327a3c1a8c71d90c56d2be6d4c90a0591363c48d6<br></code></pre></td></tr></table></figure><p>出现如下界面标识添加成功</p><img src="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20210818131456741.png" class="" title="image-20210818131456741"><p>默认的token有效期为24小时，当过期之后，该token就不能用了，这时可以使用如下的命令创建token：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm token create --print-join-command<br></code></pre></td></tr></table></figure><h3 id="2-7-部署CNI网络插件"><a href="#2-7-部署CNI网络插件" class="headerlink" title="2.7 部署CNI网络插件"></a>2.7 部署CNI网络插件</h3><p>根据提示，在Master节点上使用kubectl工具查看节点状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get nodes<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20210818132103168.png" class="" title="image-20210818132103168"><p>由于并没有网络环境，节点状态都是NotReady</p><p>kubernetes支持多种网络插件，比如flannel、calico、canal等，任选一种即可，本次选择flannel</p><p>在Master节点上获取flannel配置文件(可能会失败，如果失败，请下载到本地，然后安装)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<br></code></pre></td></tr></table></figure><p>需要将<code>kubel-flannel.yaml</code>中的<code>quay.io</code>改成镜像地址<code>quay.mirrors.ustc.edu.cn</code></p><p>使用配置文件启动flannel：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f kube-flannel.yml<br></code></pre></td></tr></table></figure><p>再次在Master节点使用kubectl工具查看节点状态：</p><img src="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20210818143224610.png" class="" title="image-20210818143224610"><p>查看集群健康状况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get cs<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20210818143302386.png" class="" title="image-20210818143302386"><h2 id="3-集群测试"><a href="#3-集群测试" class="headerlink" title="3. 集群测试"></a>3. 集群测试</h2><p>在Kubernetes集群中部署一个Nginx程序，测试下集群是否正常工作。</p><p>部署Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create deployment nginx --image=nginx:1.14-alpine<br></code></pre></td></tr></table></figure><p>暴露端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl expose deployment nginx --port=80 --type=NodePort<br></code></pre></td></tr></table></figure><p>查看服务状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pods,svc<br></code></pre></td></tr></table></figure><img src="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20210818143510147.png" class="" title="image-20210818143510147"><img src="/2021/08/18/Kubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/image-20210818143527956.png" class="" title="image-20210818143527956">]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes-介绍</title>
    <link href="/2021/08/18/Kubernetes-%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/08/18/Kubernetes-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-介绍"><a href="#Kubernetes-介绍" class="headerlink" title="Kubernetes-介绍"></a>Kubernetes-介绍</h1><h2 id="1-应用部署方式演变"><a href="#1-应用部署方式演变" class="headerlink" title="1. 应用部署方式演变"></a>1. 应用部署方式演变</h2><p>在部署应用程序的方式上，主要经历了三个时代：</p><ul><li><p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p><blockquote><p>优点：简单，不需要其它技术的参与</p><p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p></blockquote></li></ul><ul><li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p><blockquote><p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p><p>缺点：增加了操作系统，浪费了部分资源</p></blockquote></li><li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p><blockquote><p>优点：</p><p>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p><p>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p><p>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p></blockquote></li></ul><img src="/2021/08/18/Kubernetes-%E4%BB%8B%E7%BB%8D/image-20200505183738289.png" class="" title="image-20200505183738289"><p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p><ul><li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li><li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li></ul><p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p><ul><li><strong>Swarm</strong>：Docker自己的容器编排工具</li><li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li><li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li></ul><img src="/2021/08/18/Kubernetes-%E4%BB%8B%E7%BB%8D/image-20200524150339551.png" class="" title="image-20200524150339551"><h2 id="2-Kubernetes介绍"><a href="#2-Kubernetes介绍" class="headerlink" title="2. Kubernetes介绍"></a>2. Kubernetes介绍</h2><img src="/2021/08/18/Kubernetes-%E4%BB%8B%E7%BB%8D/image-20200406232838722.png" class="" title="image-20200406232838722"><p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p><p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p><ul><li><p><strong>服务发现和负载均衡</strong></p><p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p></li><li><p><strong>存储编排</strong></p><p>Kubernetes 允许自动挂载选择的存储系统，路本地存储、公共云提供商等。</p></li><li><p><strong>自动部署和回滚</strong></p><p>可以使用 Kubernetes 描述已部署的所需状态，它可以以受控的速率将实际状态更改为期望状态。例如，可以自动化 Kubernetes 来为你的部署创建新容器，删除现有容器并将它们的所有资源用于新容器。</p></li><li><p><strong>自动完成装箱计算</strong></p><p>Kubernetes 允许指定每个容器所需 CPU 和内存。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p></li><li><p><strong>自我修复</strong></p><p>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p></li><li><p><strong>密钥与配置管理</strong></p><p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><h2 id="3-Kubernetes架构"><a href="#3-Kubernetes架构" class="headerlink" title="3. Kubernetes架构"></a>3. Kubernetes架构</h2><h3 id="C-x2F-S架构"><a href="#C-x2F-S架构" class="headerlink" title="C&#x2F;S架构"></a>C&#x2F;S架构</h3><p>从更高层来看，K8S 整体上遵循 C&#x2F;S 架构，从这个角度来看，可用下面的图来表示其结构：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                               +-------------+                              <br>                               |<span class="hljs-string">             </span>|<span class="hljs-string">                              </span><br><span class="hljs-string">                               </span>|<span class="hljs-string">             </span>|<span class="hljs-string">               +---------------+</span><br><span class="hljs-string">                               </span>|<span class="hljs-string">             </span>|<span class="hljs-string">       +-----&gt; </span>|<span class="hljs-string">     Node 1    </span>|<br>                               |<span class="hljs-string"> Kubernetes  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">       +---------------+</span><br><span class="hljs-string">+-----------------+            </span>|<span class="hljs-string">   Server    </span>|<span class="hljs-string">       </span>|<span class="hljs-string">                      </span><br><span class="hljs-string"></span>|<span class="hljs-string">       CLI       </span>|<span class="hljs-string">            </span>|<span class="hljs-string">             </span>|<span class="hljs-string">       </span>|<span class="hljs-string">       +---------------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">    (Kubectl)    </span>|<span class="hljs-string">-----------&gt;</span>|<span class="hljs-string"> ( Master )  </span>|<span class="hljs-string">&lt;------+-----&gt; </span>|<span class="hljs-string">     Node 2    </span>|<br>|<span class="hljs-string">                 </span>|<span class="hljs-string">            </span>|<span class="hljs-string">             </span>|<span class="hljs-string">       </span>|<span class="hljs-string">       +---------------+</span><br><span class="hljs-string">+-----------------+            </span>|<span class="hljs-string">             </span>|<span class="hljs-string">       </span>|<span class="hljs-string">       </span><br><span class="hljs-string">                               </span>|<span class="hljs-string">             </span>|<span class="hljs-string">       </span>|<span class="hljs-string">       +---------------+</span><br><span class="hljs-string">                               </span>|<span class="hljs-string">             </span>|<span class="hljs-string">       +-----&gt; </span>|<span class="hljs-string">     Node 3    </span>|<br>                               |<span class="hljs-string">             </span>|<span class="hljs-string">               +---------------+</span><br><span class="hljs-string">                               +-------------+               </span><br></code></pre></td></tr></table></figure><p>左侧是一个官方提供的名为 <code>kubectl</code> 的 CLI （Command Line Interface）工具，用于使用 K8S 开放的 API 来管理集群和操作对象等。</p><p>右侧则是 K8S 集群的后端服务及开放出的 API 等。根据上一节的内容，我们知道 Node 是用于工作的机器，而 Master 是一种角色（Role），表示在这个 Node 上包含着管理集群的一些必要组件。</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Master 是整个 K8S 集群的“大脑”，与大脑类似，它有几个重要的功能：</p><ul><li>接收：外部的请求和集群内部的通知反馈</li><li>发布：对集群整体的调度和管理</li><li>存储：存储</li></ul><p>这些功能，也通过一些组件来共同完成，通常情况下，我们将其称为 control plane 。如下图所示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+----------------------------------------------------------+          <br>|<span class="hljs-string"> Master                                                   </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">              +-------------------------+                 </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">     +-------&gt;</span>|<span class="hljs-string">        API Server       </span>|<span class="hljs-string">&lt;--------+       </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">     </span>|<span class="hljs-string">        </span>|<span class="hljs-string">                         </span>|<span class="hljs-string">         </span>|<span class="hljs-string">       </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">     v        +-------------------------+         v       </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">   +----------------+     ^      +--------------------+   </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">                </span>|<span class="hljs-string">     </span>|<span class="hljs-string">      </span>|<span class="hljs-string">                    </span>|<span class="hljs-string">   </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">   Scheduler    </span>|<span class="hljs-string">     </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> Controller Manager </span>|<span class="hljs-string">   </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">                </span>|<span class="hljs-string">     </span>|<span class="hljs-string">      </span>|<span class="hljs-string">                    </span>|<span class="hljs-string">   </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string">   +----------------+     v      +--------------------+   </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string"> +------------------------------------------------------+ </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string">                                                      </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string">                Cluster state store                   </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string">                                                      </span>|<span class="hljs-string"> </span>|<span class="hljs-string">          </span><br><span class="hljs-string"></span>|<span class="hljs-string"> +------------------------------------------------------+ </span>|<span class="hljs-string">          </span><br><span class="hljs-string">+----------------------------------------------------------+          </span><br></code></pre></td></tr></table></figure><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node 是 Kubernetes 中的工作节点</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+--------------------------------------------------------+       <br>|<span class="hljs-string"> +---------------------+        +---------------------+ </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string">      kubelet        </span>|<span class="hljs-string">        </span>|<span class="hljs-string">     kube-proxy      </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">        </span>|<span class="hljs-string">                     </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> +---------------------+        +---------------------+ </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> +----------------------------------------------------+ </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> Container Runtime (Docker)                         </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +---------------------+    +---------------------+ </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">Pod                  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">Pod                  </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +-----+ +-----+     </span>|<span class="hljs-string">    </span>|<span class="hljs-string">+-----++-----++-----+</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">C1   </span>|<span class="hljs-string"> </span>|<span class="hljs-string">C2   </span>|<span class="hljs-string">     </span>|<span class="hljs-string">    </span>||<span class="hljs-string">C1   </span>||<span class="hljs-string">C2   </span>||<span class="hljs-string">C3   </span>||<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     </span>|<span class="hljs-string">    </span>||<span class="hljs-string">     </span>||<span class="hljs-string">     </span>||<span class="hljs-string">     </span>||<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +-----+ +-----+     </span>|<span class="hljs-string">    </span>|<span class="hljs-string">+-----++-----++-----+</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +---------------------+    +---------------------+ </span>|<span class="hljs-string"> </span>|<span class="hljs-string">       </span><br><span class="hljs-string"></span>|<span class="hljs-string"> +----------------------------------------------------+ </span>|<span class="hljs-string">       </span><br><span class="hljs-string">+--------------------------------------------------------+  </span><br></code></pre></td></tr></table></figure><h2 id="4-Kubernetes组件"><a href="#4-Kubernetes组件" class="headerlink" title="4. Kubernetes组件"></a>4. Kubernetes组件</h2><p>一个kubernetes集群主要是由**控制节点(master)<strong>、</strong>工作节点(node)**构成，每个节点上都会安装不同的组件。</p><p><strong>master：集群的控制平面，负责集群的决策 ( 管理 )</strong></p><blockquote><p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p><p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p><p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p><p><strong>Cluster state store</strong> ：存储集群所有需持久化的状态，并且提供 watch 的功能支持，目前 Kubernetes 的存储层选择是 etcd</p></blockquote><p><strong>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</strong></p><blockquote><p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p><p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p><p><strong>Docker</strong> : 负责节点上容器的各种操作</p></blockquote><img src="/2021/08/18/Kubernetes-%E4%BB%8B%E7%BB%8D/image-20200406184656917.png" class="" title="image-20200406184656917"><p>下面，以部署一个 nginx 服务来说明 kubernetes 系统各个组件调用关系：</p><ol><li><p>首先要明确，一旦 kubernetes 环境启动之后，master 和 node 都会将自身的信息存储到 etcd 数据库中</p></li><li><p>一个 nginx 服务的安装请求会首先被发送到 master 节点的 apiServer 组件</p></li><li><p>apiServer 组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p><p>在此时，它会从 etcd 中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知 apiServer</p></li><li><p>apiServer 调用 controller-manager 去调度 Node 节点安装 nginx 服务</p></li><li><p>kubelet 接收到指令后，会通知 docker，然后由 docker 来启动一个 nginx 的pod</p><p>pod 是 kubernetes 的最小操作单元，容器必须跑在 pod 中至此，</p></li><li><p>一个 nginx 服务就运行了，如果需要访问 nginx，就需要通过 kube-proxy 来对 pod 产生访问的代理</p></li></ol><p>这样，外界用户就可以访问集群中的 nginx 服务了</p><h3 id="5-Kubernetes概念"><a href="#5-Kubernetes概念" class="headerlink" title="5. Kubernetes概念"></a>5. Kubernetes概念</h3><p><strong>Master</strong>：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p><p><strong>Node</strong>：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p><p><strong>Pod</strong>：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p><p><strong>Controller</strong>：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p><p><strong>Service</strong>：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p><p><strong>Label</strong>：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p><p><strong>NameSpace</strong>：命名空间，用来隔离pod的运行环境</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty源码-Pipline</title>
    <link href="/2021/08/17/Netty%E6%BA%90%E7%A0%81-Pipline/"/>
    <url>/2021/08/17/Netty%E6%BA%90%E7%A0%81-Pipline/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty源码-Pipline"><a href="#Netty源码-Pipline" class="headerlink" title="Netty源码-Pipline"></a>Netty源码-Pipline</h1><p><code>ChannelPipeline</code>数据管道是<code>ChannelHandler</code>数据处理器的容器，负责<code>ChannelHandler</code>的管理和事件的拦截与调度</p><p><code>channelPipeline</code>数据结构是双向链表,每一个节点都是<code>channelContext</code>,<code>channelContext</code>里面维护了对应的<code>handler</code>和<code>pipeline</code>的引用</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在<code>Channel</code>初始化时会调用到<code>AbstractChannel</code>的构造方法，<code>Pipeline</code>的初始化动作是在<code>AbstractChannel</code>构造方法中完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> &#123;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>    id = newId();<br>    unsafe = newUnsafe();<br>    pipeline = newChannelPipeline();<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的入口,<code>AbstractChannel</code>的<code>pipeline = newChannelPipeline();</code> 跟进去,看到他的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> DefaultChannelPipeline <span class="hljs-title function_">newChannelPipeline</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPipeline</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">DefaultChannelPipeline</span><span class="hljs-params">(Channel channel)</span> &#123;<br>    <span class="hljs-built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>);<br>    <span class="hljs-comment">// 把当前的Channel 保存起来</span><br>    succeededFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SucceededChannelFuture</span>(channel, <span class="hljs-literal">null</span>);<br>    voidPromise =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoidChannelPromise</span>(channel, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 设置尾节点</span><br>    tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TailContext</span>(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 设置头头节点</span><br>    head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeadContext</span>(<span class="hljs-built_in">this</span>);<br>    head.next = tail;<br>    tail.prev = head;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DefaultChannelPipeline</code>是<code>channelPipeline</code>的默认实现，我们看一下下面的 <code>Channel</code>、<code>ChannelContext</code>、<code>ChannelPipeline</code>的继承体系图</p><img src="/2021/08/17/Netty%E6%BA%90%E7%A0%81-Pipline/1496926-20190720112751462-390044516.png" class="" title="pipeline和context的关系图"><p>在<code>newChannelPipeline()</code>中调用了<code>DefaultChannelPipeline</code>的构造方法，<code>DefaultChannelPipeline</code>构造方法主要完成了三件事。首先将与之关联的Channel保存在属性Channel中，然后实例化了两个对象(一个是<code>TailContext</code>实例tail，一个是<code>HeadContext</code>实例head)，然后将head和tail相互指向，构成了一个双向链表。</p><img src="/2021/08/17/Netty%E6%BA%90%E7%A0%81-Pipline/ChannelPipeline%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="" title="ChannelPipeline数据结构"><p>下图是<code>HeaderContext</code>和<code>TailContext</code>的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeadContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractChannelHandlerContext</span><br>            <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelOutboundHandler</span>, ChannelInboundHandler &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br>    HeadContext(DefaultChannelPipeline pipeline) &#123;<br>        <span class="hljs-built_in">super</span>(pipeline, <span class="hljs-literal">null</span>, HEAD_NAME, HeadContext.class);<br>        unsafe = pipeline.channel().unsafe();<br>        setAddComplete();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TailContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractChannelHandlerContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelInboundHandler</span> &#123;<br><br>    TailContext(DefaultChannelPipeline pipeline) &#123;<br>        <span class="hljs-built_in">super</span>(pipeline, <span class="hljs-literal">null</span>, TAIL_NAME, TailContext.class);<br>        setAddComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个tail节点是<code>inbound</code>类型的处理器，header是<code>Inbound</code>类型的处理器, 同时也是出站处理器</p><p>对Netty来说用发送过来的数据，要就从header节点开始往后传播。 因为是双向链表，直接找后一个inbound类型的节点，于是数据msg就从header之后的第一个结点往后传播，如果一直到最后，都只是传播数据而没有任何处理就会传播到tail节点，因为tail也是inbound类型的,，t<strong>ail节点会替我们释放掉这个msg，防止内存泄露</strong></p><p>当然如果我们自己使用了msg，而没往后传播，也没有释放，内存泄露是早晚的时，这就是为啥tail是Inbound类型的，header节点和它相反</p><p><strong><code>DefaultChannelPipeline</code>、<code>ChannelHandlerContext</code>、<code>ChannelHandler</code>的关系</strong></p><p><code>DefaultChannelPipeline</code>中的每个节点是一个<code>ChannelHandlerContext</code>对象(一个<code>ChannelPipeline</code>中可以有多个<code>ChannelHandler</code>实例，而每一个<code>ChannelHandler</code>实例与<code>ChannelPipeline</code>之间的桥梁就是<code>ChannelHandlerContext</code>实例)</p><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><h3 id="ChannelInitializer-的添加"><a href="#ChannelInitializer-的添加" class="headerlink" title="ChannelInitializer 的添加"></a>ChannelInitializer 的添加</h3><p>最开始的时候<code>ChannelPipeline </code>中含有两个<code>ChannelHandlerContext</code>，但是这个Pipeline 并不能实现什么特殊的功能，因为我们还没有给它添加自定义的<code>ChannelHandler</code>。通常来说，我们在初始化<code>Bootstrap</code>，会添加我们自定义的<code>ChannelHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>bootstrap.group(group)<br>.channel(NioSocketChannel.class)<br>.option(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>　　<span class="hljs-meta">@Override</span><br>　　<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>　　　　<span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>　　　　pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatClientHandler</span>(nickName));<br>　　&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在调用handler 时，传入了<code>ChannelInitializer </code>对象，它提供了一个<code>initChannel()</code>方法给我我们初始化<code>ChannelHandler</code>。最后将这个匿名的Handler保存到<code>AbstractBootstrap</code>中。</p><p>通过代码跟踪，我们发现<code>ChannelInitializer </code>是在<code>Bootstrap.init()</code>方法中添加到<code>ChannelPipeline </code>中的，其代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> channel.pipeline();<br>        p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelHandler</span>[]&#123;<span class="hljs-built_in">this</span>.config.handler()&#125;);<br> 　　　　。。。。。。<br>&#125;<br><span class="hljs-comment">//AbstractBootstrapConfig</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelHandler <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>　　<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.bootstrap.handler();<br>&#125;<br><span class="hljs-comment">//AbstractBootstrap</span><br><span class="hljs-keyword">final</span> ChannelHandler <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.handler;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Bootstrap.init()</code>方法中会调用<code>p.addLast()</code>方法，将<code>ChannelInitializer </code>插入到链表的末端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">addLast</span><span class="hljs-params">(ChannelHandler... handlers)</span> &#123;<br>    <span class="hljs-keyword">return</span> addLast(<span class="hljs-literal">null</span>, handlers);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">addLast</span><span class="hljs-params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> &#123;<br>    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;handlers&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (ChannelHandler h: handlers) &#123;<br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        addLast(executor, <span class="hljs-literal">null</span>, h);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;<br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 1.禁止非Sharable的handler重复添加到不同的pipeline中</span><br>        checkMultiplicity(handler);<br><br>        <span class="hljs-comment">// 2.创建节点 =&gt; DefaultChannelHandlerContext</span><br>        newCtx = newContext(group, filterName(name, handler), handler);<br><br>        <span class="hljs-comment">// 3.添加节点</span><br>        addLast0(newCtx);<br><br>        <span class="hljs-comment">// 如果channel没有与eventloop绑定</span><br>        <span class="hljs-comment">// 则创建一个任务 这个任务会在channel被register的时候调用</span><br>        <span class="hljs-keyword">if</span> (!registered) &#123;<br>            newCtx.setAddPending();<br>            callHandlerCallbackLater(newCtx, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4.回调用户方法</span><br>        <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> newCtx.executor();<br>        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;<br>            newCtx.setAddPending();<br>            executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    callHandlerAdded0(newCtx);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>    callHandlerAdded0(newCtx);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>addLast()</code>方法中，首先检查<code>ChannelHandler </code>的名字是否是重复，如果不重复，则调用<code>newContex()</code>方法为这个handler创建一个对应的<code>DefaultChannelHandlerContext</code>实例，并与之关联起来(Context 中有一个handler 属性保存着对应的Handler 实例)。为了添加一个handler到pipeline 中，必须把此handler 包装成<code>ChannelHandlerContext</code>。因此在上面的代码中我们可以看到新实例化了一个newCtx 对象，并将handler 作为参数传递到构造方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;<br>    <span class="hljs-built_in">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler));<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;handler&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>DefaultChannelHandlerContext </code>的构造器中，调用了两个很有意思的方法：<code>isInbound()</code>与<code>isOutbound()</code></p><p>当一个handler 实现了<code>ChannelInboundHandler </code>接口，则<code>isInbound </code>返回true；类似地，当一个handler 实现了<code>ChannelOutboundHandler </code>接口，则<code>isOutbound </code>就返回true。而这两个boolean 变量会传递到父类<code>AbstractChannelHandlerContext </code>中，并初始化父类的两个字段：<code>inbound </code>与<code>outbound</code></p><p><code>ChannelInitializer </code>仅仅实现了<code>ChannelInboundHandler </code>接口，因此这里实例化的<code>DefaultChannelHandlerContext</code>的inbound为true，outbound为false。当<code>Context</code>创建完成后，执行<code>addLast0()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast0</span><span class="hljs-params">(AbstractChannelHandlerContext newCtx)</span> &#123;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.tail.prev;<br>    newCtx.prev = prev;<br>    newCtx.next = <span class="hljs-built_in">this</span>.tail;<br>    prev.next = newCtx;<br>    <span class="hljs-built_in">this</span>.tail.prev = newCtx;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加完成后，此时双向链表<code>ContextHead&lt;--&gt;ChannelInitializer&lt;--&gt;ContextTail</code></p><h3 id="自定义ChannelHandler的添加"><a href="#自定义ChannelHandler的添加" class="headerlink" title="自定义ChannelHandler的添加"></a>自定义ChannelHandler的添加</h3><p>自定义的<code>ChannelHandler</code>在<code>ChannelInitializer</code>被调用时添加，因此需要探究<code>ChannelInitializer</code>在哪里被调用</p><p>回顾<code>Channel</code>的注册过程：</p><ol><li>首先在<code>AbstractBootstrap </code>的<code>initAndRegister()</code>中，通过<code>group().register(channel)</code>，调用<code>MultithreadEventLoopGroup .register()</code>方法。</li><li>在<code>MultithreadEventLoopGroup.register()</code>中调用<code>next()</code>获取一个可用的<code>SingleThreadEventLoop</code>，然后调用它的<code>register()</code>方法。</li><li>在<code>SingleThreadEventLoop.register()</code>方法中，通过<code>channel.unsafe().register(this, promise)</code>方法获取<code>channel</code>的<code>unsafe()</code>底层IO 操作对象，然后调用它的<code>register()</code>。</li><li>在<code>AbstractUnsafe.register()</code>方法中，调用<code>register0()</code>方法注册<code>Channel</code>对象。</li><li>在<code>AbstractUnsafe.register0()</code>方法中，调用<code>AbstractNioChannel.doRegister()</code>方法。</li><li><code>AbstractNioChannel.doRegister()</code>方法调用<code>javaChannel().register(eventLoop().selector, 0, this)</code>将<code>Channel</code>对应的Java NIO 的<code>SockerChannel</code>对象注册到一个<code>eventLoop</code>的<code>Selector</code>中，并且将当前<code>Channel</code>作为<code>attachment</code>。</li></ol><p>而我们自定义<code>ChannelHandler</code>的添加过程，发生在<code>AbstractUnsafe.register0()</code>方法中，在这个方法中调用了<code>pipeline.fireChannelRegistered()</code>方法，其代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">firstRegistration</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.neverRegistered;<br>        AbstractChannel.<span class="hljs-built_in">this</span>.doRegister();<br>        <span class="hljs-built_in">this</span>.neverRegistered = <span class="hljs-literal">false</span>;<br>        AbstractChannel.<span class="hljs-built_in">this</span>.registered = <span class="hljs-literal">true</span>;<br>        AbstractChannel.<span class="hljs-built_in">this</span>.pipeline.invokeHandlerAddedIfNeeded();<br>        <span class="hljs-built_in">this</span>.safeSetSuccess(promise);<br>        AbstractChannel.<span class="hljs-built_in">this</span>.pipeline.fireChannelRegistered();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">fireChannelRegistered</span><span class="hljs-params">()</span> &#123;<br>        AbstractChannelHandlerContext.invokeChannelRegistered(<span class="hljs-built_in">this</span>.head);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看<code>AbstractChannelHandlerContext</code>的<code>invokeChannelRegistered()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelRegistered</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;<br>    <span class="hljs-comment">// 从head开始遍历双向链表</span><br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeChannelRegistered();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                next.invokeChannelRegistered();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从head 开始遍历Pipeline 的双向链表，然后<code>findContextInbound()</code>找到第一个属性<code>inbound</code>为true 的<code>ChannelHandlerContext</code>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    DefaultChannelPipeline.<span class="hljs-built_in">this</span>.invokeHandlerAddedIfNeeded();<br>    ctx.fireChannelRegistered();<br>&#125;<br><span class="hljs-keyword">public</span> ChannelHandlerContext <span class="hljs-title function_">fireChannelRegistered</span><span class="hljs-params">()</span> &#123;<br>    invokeChannelRegistered(<span class="hljs-built_in">this</span>.findContextInbound());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当获取到inbound 的Context 后，就调用它的<code>invokeChannelRegistered()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelRegistered</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelInboundHandler)<span class="hljs-built_in">this</span>.handler()).channelRegistered(<span class="hljs-built_in">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var2) &#123;<br>            <span class="hljs-built_in">this</span>.notifyHandlerException(var2);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.fireChannelRegistered();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>handler()</code>返回的对象其实就是一开始我们实例化的<code>ChannelInitializer</code>对象，并接着调用了<code>ChannelInitializer</code>的<code>channelRegistered()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;C <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Channel</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>　　<span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(C ch)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (initChannel(ctx)) &#123;<br>            ctx.pipeline().fireChannelRegistered();<br>            removeState(ctx);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.fireChannelRegistered();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (initMap.add(ctx)) &#123; <span class="hljs-comment">// Guard against re-entrance.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                initChannel((C) ctx.channel());<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>                exceptionCaught(ctx, cause);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ctx.pipeline();<br>                <span class="hljs-keyword">if</span> (pipeline.context(<span class="hljs-built_in">this</span>) != <span class="hljs-literal">null</span>) &#123;<br>                    pipeline.remove(<span class="hljs-built_in">this</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>initChannel((C) ctx.channel())</code>就是我们在初始化<code>Bootstrap</code>时，调用<code>handler</code>方法传入的匿名内部类所实现的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>    pipeline.addLast(<span class="hljs-string">&quot;handler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClient</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用这个方法之后, 我们自定义的<code>ChannelHandler</code>就插入到了<code>Pipeline</code></p><p>此时双向链表：<code>ContextHead&lt;--&gt;ChannelInitializer&lt;--&gt;MyHandler&lt;--&gt;ContextTail</code></p><p>当添加完成自定义的<code>ChannelHandler</code>后，在finally代码块会删除自定义的<code>ChannelInitializer</code>，也就是<code>remove(ctx)</code>最终调用<code>ctx.pipeline().remove(this)</code></p><p>此时双向链表：<code>ContextHead&lt;--&gt;MyHandler&lt;--&gt;ContextTail</code></p><p>Context节点添加完毕回调Handler方法<code>callHandlerAdded0()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callHandlerAdded0</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ctx.handler().handlerAdded(ctx);<br>        ctx.setAddComplete();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler可以重写<code>handlerAdded</code>方法在Handler被添加成功后 执行部分操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;...&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 节点被添加完毕之后回调到此</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，设置该节点的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddComplete</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldState</span> <span class="hljs-operator">=</span> handlerState;<br>        <span class="hljs-keyword">if</span> (oldState == REMOVE_COMPLETE || HANDLER_STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, oldState, ADD_COMPLETE)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用CAS修改节点的状态至REMOVE_COMPLETE(说明该节点已经被移除)或者ADD_COMPLETE(说明节点已被添加)</p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>Netty有个最大的特性之一就是Handler可插拔做到动态编织Pipeline，比如在首次建立连接的时候需要通过进行权限认证，在认证通过之后就可以将此Context移除，下次Pipeline在传播事件的时候就就不会调用到权限认证处理器</p><p>下面是权限认证Handler最简单的实现，第一个数据包传来的是认证信息，如果校验通过就删除此Handler，否则直接关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (verify(authDataPacket)) &#123;<br>            ctx.pipeline().remove(<span class="hljs-built_in">this</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(ByteBuf byteBuf)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点就在ctx.pipeline().remove(this)这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">remove</span><span class="hljs-params">(ChannelHandler handler)</span> &#123;<br>    remove(getContextOrDie(handler));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>remove操作可以分为如下三个步骤</p><ol><li>找到待删除的节点</li><li>调整双向链表指针删除节点</li><li>Context节点删除完毕回调Handler方法</li></ol><h3 id="找到待删除的节点"><a href="#找到待删除的节点" class="headerlink" title="找到待删除的节点"></a>找到待删除的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title function_">getContextOrDie</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> (AbstractChannelHandlerContext) context(name);<br>    <span class="hljs-keyword">if</span> (ctx == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> ctx;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelHandlerContext <span class="hljs-title function_">context</span><span class="hljs-params">(ChannelHandler handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;handler&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        <span class="hljs-keyword">if</span> (ctx == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ctx.handler() == handler) &#123;<br>            <span class="hljs-keyword">return</span> ctx;<br>        &#125;<br><br>        ctx = ctx.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过遍历链表方式根据Handler找到对应的Context节点(判断依据 &#x3D;&gt; Context的Handler和当前Handler相同)</p><h3 id="调整双向链表指针删除节点"><a href="#调整双向链表指针删除节点" class="headerlink" title="调整双向链表指针删除节点"></a>调整双向链表指针删除节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-comment">// 头结点和为节点不能删除</span><br>    <span class="hljs-keyword">assert</span> ctx != head &amp;&amp; ctx != tail;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 调整双向链表指针删除节点</span><br>        remove0(ctx);<br><br>        <span class="hljs-comment">// 如果channel没有与eventloop绑定</span><br>        <span class="hljs-comment">// 则创建一个任务 这个任务会在channel被register的时候调用</span><br>        <span class="hljs-keyword">if</span> (!registered) &#123;<br>            callHandlerCallbackLater(ctx, <span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span> ctx;<br>        &#125;<br><br>        <span class="hljs-comment">// 回调用户函数</span><br>        <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> ctx.executor();<br>        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;<br>            executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    callHandlerRemoved0(ctx);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">return</span> ctx;<br>        &#125;<br>    &#125;<br>    callHandlerRemoved0(ctx);<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除节点是通过remove0方法实现的，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove0</span><span class="hljs-params">(AbstractChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ctx.prev;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> ctx.next;<br>    prev.next = next;<br>    next.prev = prev;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Context节点删除完毕回调Handler方法"><a href="#Context节点删除完毕回调Handler方法" class="headerlink" title="Context节点删除完毕回调Handler方法"></a>Context节点删除完毕回调Handler方法</h3><p>回调用户方法逻辑在<code>callHandlerRemoved0()</code>方法中完成，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callHandlerRemoved0</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ctx.handler().handlerRemoved(ctx);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ctx.setRemoved();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        fireExceptionCaught(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelPipelineException</span>(ctx.handler().getClass().getName() + <span class="hljs-string">&quot;.handlerRemoved() has thrown an exception.&quot;</span>, t));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler可以重写<code>handlerRemoved</code>方法在Handler被删除成功后 执行部分操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;...&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 节点被删除完毕之后回调到此</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后将该节点的状态设置为removed</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRemoved</span><span class="hljs-params">()</span> &#123;<br>    handlerState = REMOVE_COMPLETE;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此Pipeline添加节点的删除就完成了，其他的removeXXX方法原理类似</p><h2 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h2><p><code>AbstractChannelHandlerContext</code>中有<code>inbound</code>和<code>outbound</code>两个boolean 变量，分别用于标识Context 所对应的handler的类型，即：</p><ol><li><code>inbound</code>为true 是,表示其对应的<code>ChannelHandler</code>是<code>ChannelInboundHandler</code>的子类。</li><li><code>outbound</code>为true 时，表示对应的<code>ChannelHandler</code>是<code>ChannelOutboundHandler</code>的子类。</li></ol><p>Netty 中的传播事件可以分为两种：Inbound 事件和Outbound 事件。如下是从Netty 官网针对这两个事件的说明：</p><img src="/2021/08/17/Netty%E6%BA%90%E7%A0%81-Pipline/image-20210817215001322.png" class="" title="image-20210817215001322"><p>从上图可以看出，<code>inbound</code>事件和<code>outbound</code>事件的流向是不一样的，<code>inbound</code>事件的流行是从下至上，而<code>outbound</code>刚好相反，是从上到下。并且<code>inbound</code>的传递方式是通过调用相应的<code>ChannelHandlerContext.fireIN_EVT()</code>方法，而<code>outbound</code>方法的的传递方式是通过调用<code>ChannelHandlerContext.OUT_EVT()</code>方法。例如：<code>ChannelHandlerContext</code>的<code>fireChannelRegistered()</code>调用会发送一个<code>ChannelRegistered</code>的<code>inbound</code>给下一个<code>ChannelHandlerContext</code>，而<code>ChannelHandlerContext</code>的<code>bind()</code>方法调用时会发送一个<code>bind</code>的<code>outbound</code>事件给下一个<code>ChannelHandlerContext</code>。</p><p><strong>Inbound 事件传播方法有</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChannelInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelUnregistered</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext var1, Object var2)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext var1, Object var2)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelWritabilityChanged</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>Outbound 事件传播方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChannelOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(ChannelHandlerContext var1, SocketAddress var2, ChannelPromise var3)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(ChannelHandlerContext var1, SocketAddress var2, SocketAddress var3, ChannelPromise var4)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">disconnect</span><span class="hljs-params">(ChannelHandlerContext var1, ChannelPromise var2)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ChannelHandlerContext var1, ChannelPromise var2)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deregister</span><span class="hljs-params">(ChannelHandlerContext var1, ChannelPromise var2)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext var1, Object var2, ChannelPromise var3)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>inbound 类似于是事件回调（响应请求的事件），而outbound 类似于主动触发（发起请求的事件）</p><p>如果我们捕获了一个事件，并且想让这个事件继续传递下去，那么需要调用Context 对应的传播方法 fireXXX</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>　　<span class="hljs-meta">@Override</span><br>　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>　　　　System.out.println(<span class="hljs-string">&quot;连接成功&quot;</span>);<br>　　　　ctx.fireChannelActive();<br>　　&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="outbound事件传播方式"><a href="#outbound事件传播方式" class="headerlink" title="outbound事件传播方式"></a>outbound事件传播方式</h3><p><code>Outbound</code>事件都是请求事件(request event)，即请求某件事情的发生，然后通过<code>Outbound</code>事件进行通知。<code>Outbound</code>事件的传播方向是<code>tail -&gt; customContext -&gt; head</code>。</p><p>我们接下来以<code>connect</code>事件为例，分析一下<code>Outbound</code>事件的传播机制。首先，当用户调用了<code>Bootstrap.connect()</code>方法时，就会触发一个<code>Connect</code>请求事件，我们就发现<code>AbstractChannel.connect()</code>其实由调用了<code>DefaultChannelPipeline.connect()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">connect</span><span class="hljs-params">(SocketAddress remoteAddress)</span> &#123;<br>    <span class="hljs-keyword">return</span> pipeline.connect(remoteAddress);<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>pipeline.connect()</code>方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">connect</span><span class="hljs-params">(SocketAddress remoteAddress)</span> &#123;<br>    <span class="hljs-keyword">return</span> tail.connect(remoteAddress);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，当<code>outbound</code>事件(这里是connect 事件)传递到<code>Pipeline</code>后，它其实是以tail 为起点开始传播的。而<code>tail.connect()</code>其实调用的是<code>AbstractChannelHandlerContext.connect()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> findContextOutbound(MASK_CONNECT);<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeConnect(remoteAddress, localAddress, promise);<span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>findContextOutbound()</code>的作用是以当前<code>Context</code>为起点，向<code>Pipeline</code>中的<code>Context</code>双向链表的前端寻找第一个<code>outbound</code>属性为true 的<code>Context</code>（即关联<code>ChannelOutboundHandler</code>的<code>Context</code>），然后返回。<code>findContextOutbound()</code>方法代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title function_">findContextOutbound</span><span class="hljs-params">(<span class="hljs-type">int</span> mask)</span> &#123;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        ctx = ctx.prev;<br>    &#125; <span class="hljs-keyword">while</span> ((ctx.executionMask &amp; mask) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们找到了一个<code>outbound</code>的<code>Context</code>后，就调用它的<code>invokeConnect()</code>方法，这个方法中会调用<code>Context</code>其关联的<code>ChannelHandler</code>的<code>connect()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeConnect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelOutboundHandler) handler()).connect(<span class="hljs-built_in">this</span>, remoteAddress, localAddress, promise);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            notifyOutboundHandlerException(t, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        connect(remoteAddress, localAddress, promise);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用户没有重写<code>ChannelHandler</code>的<code>connect()</code>方法，那么会调用<code>ChannelOutboundHandlerAdapter</code>的<code>connect()</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ctx.connect(remoteAddress, localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ChannelOutboundHandlerAdapter</code>的<code>connect()</code>仅仅调用了<code>ctx.connect()</code>，而这个调用又回到了：<code>Context.connect -&gt; Connect.findContextOutbound -&gt; next.invokeConnect -&gt; handler.connect -&gt; Context.connect</code>这样的循环中，直到<code>connect</code>事件传递到<code>DefaultChannelPipeline</code>的双向链表的头节点，即head 中</p><p>head 实现了<code>ChannelOutboundHandler</code>，因此它的<code>outbound</code>属性是true。因为head 本身既是一个<code>ChannelHandlerContext</code>，又实现了<code>ChannelOutboundHandler</code>接口，因此当<code>connect()</code>消息传递到head 后，会将消息转递到对应的<code>ChannelHandler</code>中处理，而head 的<code>handler()</code>方法返回的就是head 本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelHandler <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此最终<code>connect()</code>事件是在head 中被处理。head 的<code>connect()</code>事件处理逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(</span><br><span class="hljs-params">    ChannelHandlerContext ctx,</span><br><span class="hljs-params">    SocketAddress remoteAddress, SocketAddress localAddress,</span><br><span class="hljs-params">    ChannelPromise promise)</span> &#123;<br>    unsafe.connect(remoteAddress, localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="inbound事件传播方式"><a href="#inbound事件传播方式" class="headerlink" title="inbound事件传播方式"></a>inbound事件传播方式</h3><p><code>Inbound</code>事件和<code>Outbound</code>事件的处理过程是类似的，只是传播方向不同。<code>Inbound</code>事件是一个通知事件,即某件事已经发生了,然后通过<code>Inbound</code>事件进行通知。<code>Inbound</code>通常发生在<code>Channel</code>的状态的改变或IO 事件就绪。</p><p><code>Inbound</code>的特点是它传播方向是<code>head -&gt; customContext -&gt; tail</code>。接下来分析<code>connect()</code>事件后会发生什么<code>Inbound</code>事件，并最终找到<code>Outbound</code>和<code>Inbound</code>事件之间的联系。当<code>connect()</code>这个<code>Outbound</code>传播到<code>unsafe</code>后，其实是在<code>AbstractNioUnsafe</code>的<code>connect()</code>方法中进行处理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">wasActive</span> <span class="hljs-operator">=</span> isActive();<br>    <span class="hljs-keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;<br>        fulfillConnectPromise(promise, wasActive);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>AbstractNioUnsafe</code>的<code>connect()</code>方法中，首先调用<code>doConnect()</code>方法进行实际上的Socket 连接，当连接上后会调用<code>fulfillConnectPromise()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fulfillConnectPromise</span><span class="hljs-params">(ChannelPromise promise, <span class="hljs-type">boolean</span> wasActive)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!wasActive &amp;&amp; active) &#123;<br>        pipeline().fireChannelActive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>fulfillConnectPromise()</code>中，会通过调用<code>pipeline().fireChannelActive()</code>方法将通道激活的消息(即Socket 连接成功)发送出去。而这里，当调用<code>pipeline.fireXXX</code> 后，就是<code>Inbound</code>事件的起点。因此当调用<code>pipeline().fireChannelActive()</code>后，就产生了一个<code>ChannelActive Inbound</code>事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">fireChannelActive</span><span class="hljs-params">()</span> &#123;<br>    AbstractChannelHandlerContext.invokeChannelActive(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在<code>fireChannelActive()</code>方法中，调用的是<code>head.invokeChannelActive()</code>，因此可以证明<code>Inbound</code>事件在<code>Pipeline</code>中传输的起点是head</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelActive</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeChannelActive();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                next.invokeChannelActive();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来的调用流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelActive</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelInboundHandler)<span class="hljs-built_in">this</span>.handler()).channelActive(<span class="hljs-built_in">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var2) &#123;<br>            <span class="hljs-built_in">this</span>.notifyHandlerException(var2);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.fireChannelActive();<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ctx.fireChannelActive();<br>    <span class="hljs-built_in">this</span>.readIfIsAutoRead();<br>&#125;<br><span class="hljs-keyword">public</span> ChannelHandlerContext <span class="hljs-title function_">fireChannelActive</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.findContextInbound();<br>    invokeChannelActive(next);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>首先调用<code>findContextInbound()</code>，从Pipeline 的双向链表中中找到第一个属性<code>inbound</code>为true 的<code>Context</code>，然后将其返回。</li><li>调用<code>Context</code>的<code>invokeChannelActive()</code>方法.</li></ol><p><code>invokeChannelActive()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelActive</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ((ChannelInboundHandler) handler()).channelActive(<span class="hljs-built_in">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            notifyHandlerException(t);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fireChannelActive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果用户没有重写<code>channelActive() </code>方法，那就会调用<code>ChannelInboundHandlerAdapter</code>的<code>channelActive()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ctx.fireChannelActive();<br>&#125;<br></code></pre></td></tr></table></figure><p>同样地, 在<code>ChannelInboundHandlerAdapte</code>的<code>channelActive()</code>中，仅仅调用了<code>ctx.fireChannelActive()</code>方法，因此就会进入<code>Context.fireChannelActive() -&gt; Connect.findContextInbound() -&gt; nextContext.invokeChannelActive() -&gt;nextHandler.channelActive() -&gt; nextContext.fireChannelActive()</code>这样的循环中。</p><p>同理，tail 本身既实现了<code>ChannelInboundHandler</code>接口，又实现了<code>ChannelHandlerContext</code>接口，因此当<code>channelActive()</code>消息传递到tail 后，会将消息转递到对应的<code>ChannelHandler</code>中处理，而tail 的<code>handler()</code>返回的就是tail 本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelHandler <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此<code>channelActive Inbound</code>事件最终是在tail 中处理的，我们看一下它的处理方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TailContext</code>的<code>channelActive()</code>方法是空的。其实<code>TailContext</code>的<code>Inbound</code>处理方法的实现都是空的。可见，如果是<code>Inbound</code>,当用户没有实现自定义的处理器时，那么默认是不处理的。</p><h3 id="事件传播机制总结"><a href="#事件传播机制总结" class="headerlink" title="事件传播机制总结"></a>事件传播机制总结</h3><p><strong>Outbound 事件总结:</strong></p><p>Outbound 事件是请求事件（由connect()发起一个请求，并最终由unsafe 处理这个请求）。</p><p>Outbound 事件的发起者是<code>Channel</code>。</p><p>Outbound 事件的处理者是<code>unsafe</code>。</p><p>Outbound 事件在<code>Pipeline</code>中的传输方向是<code>tail -&gt; head</code>。</p><p>在<code>ChannelHandler</code>中处理事件时，如果这个<code>Handler</code>不是最后一个<code>Handler</code>，则需要调用ctx 的方法（如：<code>ctx.connect()</code>方法)将此事件继续传播下去。如果不这样做，那么此事件的传播会提前终止。</p><p>Outbound 事件流：<code>Context.OUT_EVT() -&gt; Connect.findContextOutbound() -&gt; nextContext.invokeOUT_EVT()-&gt; nextHandler.OUT_EVT() -&gt; nextContext.OUT_EVT()</code></p><p><strong>Inbound 事件总结:</strong></p><p>Inbound 事件是通知事件，当某件事情已经就绪后，通知上层。</p><p>Inbound 事件发起者是<code>unsafe</code>。</p><p>Inbound 事件的处理者是<code>Channel</code>，如果用户没有实现自定义的处理方法，那么<code>Inbound</code>事件默认的处理者是<code>TailContext</code>，并且其处理方法是空实现。<code>Inbound</code>事件在<code>Pipeline</code>中传输方向是<code>head -&gt; tail</code>。</p><p>在<code>ChannelHandler</code>中处理事件时，如果这个<code>Handler</code>不是最后一个<code>Handler</code>，则需要调用<code>ctx.fireIN_EVT()</code>事件（如：<code>ctx.fireChannelActive()</code>方法）将此事件继续传播下去。如果不这样做，那么此事件的传播会提前终止。</p><p>Outbound 事件流：<code>Context.fireIN_EVT() -&gt; Connect.findContextInbound() -&gt; nextContext.invokeIN_EVT() -&gt;nextHandler.IN_EVT() -&gt; nextContext.fireIN_EVT()</code></p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty源码-新连接接入</title>
    <link href="/2021/08/15/Netty%E6%BA%90%E7%A0%81-%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5/"/>
    <url>/2021/08/15/Netty%E6%BA%90%E7%A0%81-%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty源码-新连接接入"><a href="#Netty源码-新连接接入" class="headerlink" title="Netty源码-新连接接入"></a>Netty源码-新连接接入</h1><h2 id="新连接建立-Accept事件"><a href="#新连接建立-Accept事件" class="headerlink" title="新连接建立(Accept事件)"></a>新连接建立(Accept事件)</h2><p>NIO中处理Accept事件主要有以下六步</p><ol><li><p>selector.select()阻塞线程，直到事件发生</p></li><li><p>遍历selectionKeys</p></li><li><p>获取一个key，判断事件类型是否为Accept</p></li></ol><hr><ol start="4"><li><p>创建SocketChannel，设置为非阻塞</p></li><li><p>将SocketChannel注册到selector中</p></li><li><p>关注selectionKeys的read事件</p></li></ol><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞直到事件发生</span><br>selector.select();<br><br>Iterator&lt;SelectionKey&gt; iter = selector.selectionKeys().iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;    <br>    <span class="hljs-comment">// 拿到一个事件</span><br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>    <br>    <span class="hljs-comment">// 如果是 accept 事件</span><br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <br>        <span class="hljs-comment">// 执行accept，获得SocketChannel</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>        channel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <br>        <span class="hljs-comment">// 将SocketChannel注册到selector中，并关注read事件</span><br>        channel.register(selector, SelectionKey.OP_READ);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前三步在<code>NioEventLoop</code>中已经分析过，服务端读取到<code>IO</code>事件(新连接接入事件)后，会调用<code>processSelectedKey</code>方法对事件进行处理，此处以新连接接入事件为例它最后会调用底层的<code>unsafe</code>进行<code>read</code>操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>    unsafe.read();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-title function_">eventLoop</span><span class="hljs-params">()</span>.inEventLoop();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> pipeline();<br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.<span class="hljs-type">Handle</span> <span class="hljs-variable">allocHandle</span> <span class="hljs-operator">=</span> unsafe().recvBufAllocHandle();<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// doReadMessages中执行了accept获得了SocketChannel</span><br>        <span class="hljs-comment">// 并创建NioSocketChannel作为消息放入readBuf</span><br>        <span class="hljs-comment">// readBuf是一个ArrayList用来缓存消息</span><br>        <span class="hljs-comment">// private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">localRead</span> <span class="hljs-operator">=</span> doReadMessages(readBuf);<br>        <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;<br>            closed = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// localRead值为1，就一条消息，即接收一个客户端连接</span><br>        allocHandle.incMessagesRead(localRead);<br>    &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> readBuf.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>        readPending = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 触发read事件，让pipeline上的handler处理</span><br>        <span class="hljs-comment">// ServerBootstrapAcceptor.channelRead</span><br>        pipeline.fireChannelRead(readBuf.get(i));<br>    &#125;<br>    readBuf.clear();<br>    pipeline.fireChannelReadComplete();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两个主要的方法:</p><ol><li><code>doReadMessages</code></li><li><code>pipeline.fireChannelRead</code></li></ol><h2 id="doReadMessages"><a href="#doReadMessages" class="headerlink" title="doReadMessages"></a>doReadMessages</h2><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 处理accpet事件，获得SocketChannel</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> SocketUtils.accept(javaChannel());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 创建了NioSocketChannel，作为消息放在了readBuf中</span><br>            buf.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioSocketChannel</span>(<span class="hljs-built_in">this</span>, ch));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>       ...<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法主要作用是通过<code>JDK</code>底层的<code>API</code>获取到<code>SocketChannel</code>，然后包装成<code>Netty</code>的<code>NioSocketChannel</code>。<code>NioSocketChannel</code>与服务端启动时创建的<code>NioServerSocketChannel</code>最主要的区别在于它们关注的事件不同，<code>NioSocketChannel</code>的构造方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioSocketChannel</span><span class="hljs-params">(Channel parent, SocketChannel socket)</span> &#123;<br>    <span class="hljs-built_in">super</span>(parent, socket);<br>    config = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioSocketChannelConfig</span>(<span class="hljs-built_in">this</span>, socket.socket());<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractNioByteChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch)</span> &#123;<br>    <span class="hljs-built_in">super</span>(parent, ch, SelectionKey.OP_READ);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们看到一个<code>SelectionKey.OP_READ</code>，说明这个<code>Channel</code>关心读事件而服务端的<code>Channel</code>关心<code>ACCEPT</code>事件。接下来调用父类<code>AbstractNioChannel</code>构造，后续过程与服务端启动流程一致此处不再赘述</p><h2 id="pipeline-fireChannelRead"><a href="#pipeline-fireChannelRead" class="headerlink" title="pipeline.fireChannelRead"></a>pipeline.fireChannelRead</h2><p>服务端在启动的过程中会往<code>Pipeline</code>中添加一个<code>ServerBootstrapAcceptor</code>(连接处理器)，所以到这里服务端<code>Channel</code>对应的<code>Pipeline</code>的数据结构为:<code>Head⇋ServerBootstrapAcceptor⇋Tail</code>，因此在调用<code>pipeline.fireChannelRead</code>时会依次触发这三个节点上的<code>channelRead</code>方法，<code>ServerBootstrapAcceptor</code>的<code>channelRead</code>方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>    <span class="hljs-comment">// 这时的msg是NioSocketChannel</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (Channel) msg;<br>    <span class="hljs-comment">// NioSocketChannel添加childHandler，即初始化器</span><br>    child.pipeline().addLast(childHandler);<br>    <span class="hljs-comment">// 设置选项</span><br>    setChannelOptions(child, childOptions, logger);<br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程</span><br>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    forceClose(child, future.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        forceClose(child, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先获取我们之前实例化的<code>NioSocketChannel</code>，然后将我们设置的<code>chlidHandler</code>添加到<code>NioSocketChannel</code>对应的<code>Pipeline</code>中(这里的<code>chlidHandler</code>对应用户通过<code>.childHandler()</code>设置的<code>Handler</code>)，代码执行到这里<code>NioSocketChannel</code>中<code>Pipeline</code>对应的数据结构为: <code>Head⇋ChannelInitializer⇋Tail</code>，接着设置对应的<code>attr</code>和<code>option</code>，然后进入到<code>childGroup.register(child)</code>(这里的<code>childGroup</code>就是<code>WorkerGroup</code>)，接下来我们进入<code>NioEventLoopGroup</code>的<code>register</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span> &#123;<br>    <span class="hljs-keyword">return</span> next().register(channel);<br>&#125;<br><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span> &#123;<br>    <span class="hljs-keyword">return</span> register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(channel, <span class="hljs-built_in">this</span>));<br>&#125;<br><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    ObjectUtil.checkNotNull(promise, <span class="hljs-string">&quot;promise&quot;</span>);<br>    promise.channel().unsafe().register(<span class="hljs-built_in">this</span>, promise);<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码和服务端启动的时候像<code>BossGroup</code>注册<code>NioServerSocketChannel</code>是类似的，通过<code>next()</code>方法获取到<code>NioEventLoop</code>然后将<code>Channel</code>注册到该<code>NioEventLoop</code>上(即将该<code>Channel</code>与<code>NioEventLoop</code>的<code>Selector</code>进行绑定)。注册的逻辑最终是交给<code>Unsafe</code>对象完成的，我们继续跟进<code>Unsafe</code>的<code>register</code>方法代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    ...<br>    AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = eventLoop;<br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这行代码完成的是nio boss -&gt; nio worker线程的切换</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">// 真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于是在<code>Boss</code>线程中执行的<code>IO</code>操作所以不会是跟<code>Worker</code>线程是同一个线程，故<code>eventLoop.inEventLoop()</code>返回<code>false</code>，最后会通过<code>eventLoop.execute</code>的方式去执行注册任务。在<code>Reactor</code>线程模型中我们讲到在调用<code>execute</code>的时候，如果是首次添加任务那这个<code>NioEventLoop</code>线程会被启动，所以从此<code>Worker</code>线程开始执行，接下来看下具体的注册逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ... <br>        <span class="hljs-comment">// 该方法将SocketChannel注册到Selector中</span><br>        doRegister();<br>        <span class="hljs-comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        <span class="hljs-comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span><br>        safeSetSuccess(promise);<br>        pipeline.fireChannelRegistered();<br>        <br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 触发pipeline上active事件</span><br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和服务端启动过程一样，先是调用<code>doRegister()</code>执行真正的注册过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">selected</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            selectionKey = javaChannel().register(eventLoop().selector, <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            <span class="hljs-comment">//...</span><br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该<code>Channel</code>绑定到<code>NioEventLoop</code>对应的<code>Selector</code>上去，后续该<code>Channel</code>的事件轮询、事件处理、异步<code>Task</code>执行都由此线程负责，绑定完<code>Reactor</code>线程之后调用<code>pipeline.invokeHandlerAddedIfNeeded()</code>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeHandlerAddedIfNeeded</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">assert</span> channel.eventLoop().inEventLoop();<br><span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>    firstRegistration = <span class="hljs-literal">false</span>;<br>    callHandlerAddedForAllHandlers();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>往下跟<code>callHandlerAddedForAllHandlers</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callHandlerAddedForAllHandlers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> PendingHandlerCallback pendingHandlerCallbackHead;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">assert</span> !registered;<br><br>        registered = <span class="hljs-literal">true</span>;<br><br>        pendingHandlerCallbackHead = <span class="hljs-built_in">this</span>.pendingHandlerCallbackHead;<br><br>        <span class="hljs-built_in">this</span>.pendingHandlerCallbackHead = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">PendingHandlerCallback</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> pendingHandlerCallbackHead;<br>    <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span>) &#123;<br>        task.execute();<br>        task = task.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有个对象叫<code>pendingHandlerCallbackHead</code>，它是在<code>callHandlerCallbackLater</code>方法中被初始化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callHandlerCallbackLater</span><span class="hljs-params">(AbstractChannelHandlerContext ctx, <span class="hljs-type">boolean</span> added)</span> &#123;<br>    <span class="hljs-keyword">assert</span> !registered;<br><br>    <span class="hljs-type">PendingHandlerCallback</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> added ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingHandlerAddedTask</span>(ctx) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingHandlerRemovedTask</span>(ctx);<br>    <span class="hljs-type">PendingHandlerCallback</span> <span class="hljs-variable">pending</span> <span class="hljs-operator">=</span> pendingHandlerCallbackHead;<br>    <span class="hljs-keyword">if</span> (pending == <span class="hljs-literal">null</span>) &#123;<br>        pendingHandlerCallbackHead = task;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Find the tail of the linked-list.</span><br>        <span class="hljs-keyword">while</span> (pending.next != <span class="hljs-literal">null</span>) &#123;<br>            pending = pending.next;<br>        &#125;<br>        pending.next = task;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Channel</code>注册到之前添加或删除<code>Handler</code>时没有<code>EventExecutor</code>可执行<code>HandlerAdd</code>或<code>HandlerRemove</code>事件，所以<code>Netty</code>为此事件生成一个相应任务等注册完成后在调用执行任务。添加或删除任务可能会有很多个，所以<code>DefaultChannelPipeline</code>使用一个链表存储，链表头部为先前的字段<code>pendingHandlerCallbackHead</code></p><p>接下来我们继续分析<code>task.execute</code>方法， 它主要是完成<code>NioSocketChannel</code>对应的<code>Pipeline</code>的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// ...</span><br>    callHandlerAdded0(ctx);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上对<code>pendingHandlerCallbackHead</code>的分析，这里会调用<code>ChannelInitializer</code>的<code>handlerAdded</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (ctx.channel().isRegistered()) &#123;<br>        initChannel(ctx);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="hljs-literal">null</span>) &#123; <br>        <span class="hljs-keyword">try</span> &#123;<br>            initChannel((C) ctx.channel());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>            exceptionCaught(ctx, cause);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            remove(ctx);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ChannelInitializer</code>的<code>initChannel</code>主要完成两个功能以下两个功能</p><ul><li>调用<code>initChannel((C) ctx.channel())</code>进入用户自定义的代码完成<code>Pipeline</code>的初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>     &#125;<br> &#125;)<br></code></pre></td></tr></table></figure><ul><li>在<code>finally</code>中调用<code>remove</code>方法将<code>ChannelInitializer</code>删除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ctx.pipeline();<br>        <span class="hljs-keyword">if</span> (pipeline.context(<span class="hljs-built_in">this</span>) != <span class="hljs-literal">null</span>) &#123;<br>            pipeline.remove(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        initMap.remove(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行该方法前<code>NioSocketChannel</code>对应的<code>Pipeline</code>的数据结构为:<code>head⇋ChannelInitializer⇋tail</code>，执行该方法后<code>ChannelInitializer</code>被删除，<code>NioSocketChannel</code>对应的<code>Pipeline</code>的数据结构为:<code>head⇋自定义的HandlerContext⇋tail</code>。到目前为止我们完成了新连接的注册、<code>pipeline</code>的绑定，但是新连接注册的时候的感兴趣事件还是0还无法进行读写操作，新连接对读事件的绑定是在<code>pipeline.fireChannelActive</code>方法中完成的，它最后会调用到<code>AbstractNioChannel</code>的<code>doBeginRead</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> selectionKey.interestOps();<br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面<code>register0()</code>方法的时候向<code>selector</code>注册的事件代码是0，而<code>readInterestOp</code>对应的事件代码是<code>SelectionKey.OP_READ</code>，所以本段代码的用处是将<code>SelectionKey.OP_READ</code>事件注册到<code>Selector</code>中去，<code>fireChannelActive</code>的执行逻辑在服务端启动过程中有详细描述，至此已完成客户端新连接接入的操作</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty源码-NioEventLoop</title>
    <link href="/2021/08/09/Netty%E6%BA%90%E7%A0%81-NioEventLoop/"/>
    <url>/2021/08/09/Netty%E6%BA%90%E7%A0%81-NioEventLoop/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty源码-NioEventLoop"><a href="#Netty源码-NioEventLoop" class="headerlink" title="Netty源码-NioEventLoop"></a>Netty源码-NioEventLoop</h1><h2 id="NioEventLoopGroup的创建"><a href="#NioEventLoopGroup的创建" class="headerlink" title="NioEventLoopGroup的创建"></a>NioEventLoopGroup的创建</h2><p><code>NioEventLoopGroup</code>在客户端&#x2F;服务端初始化时创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br></code></pre></td></tr></table></figure><img src="/2021/08/09/Netty%E6%BA%90%E7%A0%81-NioEventLoop/image-20210809105651905.png" class="" title="image-20210809105651905"><p>顶层接口是<code>Executor</code>可知<code>EventLoopGroup</code>支持执行一个异步任务，<code>ScheduledExecutorService</code>看名字可知子类将支持任务的调度执行，接下来我们继续跟进<code>EventLoopGroup</code>的构造方法，通过调用链发现它最终将调用到<code>MultithreadEventLoopGroup</code>的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor,</span><br><span class="hljs-params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));<br>        &#125;<br><span class="hljs-comment">// 创建线程执行器ThreadPerTaskExecutor</span><br>        <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>            executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br>        &#125;<br><span class="hljs-comment">// 创建NioEventLoop数组</span><br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 初始化NioEventLoop数组</span><br>                children[i] = newChild(executor, args);<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 异常处理，关闭所有线程</span><br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                        children[j].shutdownGracefully();<br>                    &#125;<br><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                        <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> children[j];<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;<br>                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;<br>                            <span class="hljs-comment">// Let the caller handle the interruption.</span><br>                            Thread.currentThread().interrupt();<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">// 初始化线程选择器</span><br>        chooser = chooserFactory.newChooser(children);<br><span class="hljs-comment">// 终结监听器</span><br>        <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureListener</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>                    terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;<br>            e.terminationFuture().addListener(terminationListener);<br>        &#125;<br><br>        Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);<br>        Collections.addAll(childrenSet, children);<br>        readonlyChildren = Collections.unmodifiableSet(childrenSet);<br>    &#125;<br></code></pre></td></tr></table></figure><p>此处传递进来的<code>executor</code>为<code>null</code>，所以<code>MultithreadEventExecutorGroup</code>构造方法主要完成如下功能</p><ul><li>创建线程执行器<code>ThreadPerTaskExecutor</code></li><li>创建<code>NioEventLoop</code>数组</li><li>初始化<code>NioEventLoop</code>数组</li><li>初始化线程选择器</li></ul><h3 id="创建线程执行器"><a href="#创建线程执行器" class="headerlink" title="创建线程执行器"></a>创建线程执行器</h3><p>线程执行器通过调用<code>ThreadPerTaskExecutor</code>构造函数进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br></code></pre></td></tr></table></figure><p>在调用构造函数时传递的参数<code>ThreadFactory</code>为<code>DefaultThreadFactory</code>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory threadFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPerTaskExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">if</span> (threadFactory == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;threadFactory&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        threadFactory.newThread(command).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>execute()</code>方法的作用是新建线程并执行任务，<code>Netty</code>中的默认<code>NIO</code>线程都是由<code>DefaultThreadFactory</code>创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (t.isDaemon() != daemon) &#123;<br>                t.setDaemon(daemon);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (t.getPriority() != priority) &#123;<br>                t.setPriority(priority);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            <span class="hljs-comment">// Doesn&#x27;t matter even if failed to set.</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建线程的线程名<code>prefix + nextId.incrementAndGet()</code>到底是什么？跟踪代码发现<code>prefix</code>的规则是<code>poolName</code>和<code>poolId</code>(自增)通过<code>-</code>连接起来的(此处的<code>poolName</code>为<code>nioEventLoopGroup</code>)。所以<code>Netty</code>新建<code>NIO</code>线程默认名称为<code>nioEventLoopGroup-nioEventLoopGroupId-自增ID</code>，如<code>nioEventLoopGroup-2-1</code></p><h3 id="创建NioEventLoop数组"><a href="#创建NioEventLoop数组" class="headerlink" title="创建NioEventLoop数组"></a>创建<code>NioEventLoop</code>数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br></code></pre></td></tr></table></figure><p>关于<code>nThreads</code>如果用户显示指定<code>nThreads</code>数量那就按照用户指定的设置，否则这个值将是<code>CPU</code>核数的两倍。由于我们在创建<code>NioEventLoopGroup</code>时未传递任何参数，所以此处的<code>nThreads</code>为2倍的<code>CPU</code>核数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<br>        <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor, Object... args)</span> &#123;<br>    <span class="hljs-built_in">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>children</code>是<code>EventExecutor</code>数组，但是这里数组中的每个元素其实都是<code>NioEventLoop</code>实例</p><h3 id="初始化NioEventLoop数组"><a href="#初始化NioEventLoop数组" class="headerlink" title="初始化NioEventLoop数组"></a>初始化<code>NioEventLoop</code>数组</h3><p><code>children</code>数组的初始化是在以下代码中完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">children[i] = newChild(executor, args);<br></code></pre></td></tr></table></figure><p>我们跟进<code>newChild()</code>它最后调用的是<code>NioEventLoopGroup</code>的<code>newChild</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> EventLoop <span class="hljs-title function_">newChild</span><span class="hljs-params">(Executor executor, Object... args)</span> t hrows Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoop</span>(<span class="hljs-built_in">this</span>, executor, (SelectorProvider) args[<span class="hljs-number">0</span>], ((SelectStrategyFactory) args[<span class="hljs-number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="hljs-number">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>newChild</code>方法最后调用了<code>NioEventLoop</code>的构造方法，<code>NioEventLoop</code>的构造方法代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,<br>             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,<br>             EventLoopTaskQueueFactory queueFactory) &#123;<br>    <span class="hljs-built_in">super</span>(parent, executor, <span class="hljs-literal">false</span>, newTaskQueue(queueFactory), newTaskQueue(queueFactory),<br>            rejectedExecutionHandler);<br>    <span class="hljs-keyword">if</span> (selectorProvider == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;selectorProvider&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (strategy == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;selectStrategy&quot;</span>);<br>    &#125;<br>    provider = selectorProvider;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectorTuple</span> <span class="hljs-variable">selectorTuple</span> <span class="hljs-operator">=</span> openSelector();<br>    selector = selectorTuple.selector;<br>    unwrappedSelector = selectorTuple.unwrappedSelector;<br>    selectStrategy = strategy;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里打开了一个<code>Selector</code>，也就是说每一个<code>NioEventLoop</code>都与一个<code>Selector</code>绑定</p><h3 id="初始化线程选择器"><a href="#初始化线程选择器" class="headerlink" title="初始化线程选择器"></a>初始化线程选择器</h3><p>初始化线程选择器在如下代码中完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">chooser = chooserFactory.newChooser(children);<br></code></pre></td></tr></table></figure><p>继续跟进newChooser方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> EventExecutorChooser <span class="hljs-title function_">newChooser</span><span class="hljs-params">(EventExecutor[] executors)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isPowerOfTwo(executors.length)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span>(executors);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericEventExecutorChooser</span>(executors);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现<code>Netty</code>通过判断线程个数<code>nThreads</code>是否为2的幂次方来选择<code>chooser</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 利用2的N次方法的特点，使用&amp;比求余更快</span><br>        <span class="hljs-keyword">return</span> children[childIndex.getAndIncrement() &amp; children.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用求余方式</span><br>        <span class="hljs-keyword">return</span> children[Math.abs(childIndex.getAndIncrement() % children.length)];<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>至此完成了<code>NioEventLoopGroup</code>的创建，并在<code>NioEventLoopGroup</code>创建过程中完成<code>NioEventLoop</code>初始化工作</p><h2 id="NioEventLoop剖析"><a href="#NioEventLoop剖析" class="headerlink" title="NioEventLoop剖析"></a>NioEventLoop剖析</h2><h3 id="NioEventLoop组成"><a href="#NioEventLoop组成" class="headerlink" title="NioEventLoop组成"></a>NioEventLoop组成</h3><p><code>NioEventLoop</code>的重要组成部分有三个：<code>Selector</code>、<code>Thread</code>、<code>TaskQueue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioEventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SingleThreadEventLoop</span> &#123;<br>    ...<br>    <span class="hljs-comment">// selector中的selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">private</span> SelectedSelectionKeySet selectedKeys;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleThreadEventExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractScheduledEventExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderedEventExecutor</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">// 线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread thread;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>Selector是在NioEventLoop的构造方法中被创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;<br>    <br>        ...<br>           <br>        <span class="hljs-comment">// 初始化selector，初始化过程在openSelector中</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SelectorTuple</span> <span class="hljs-variable">selectorTuple</span> <span class="hljs-operator">=</span> openSelector();<br>        <span class="hljs-built_in">this</span>.selector = selectorTuple.selector;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title function_">openSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处等同于 Selector.open()方法</span><br>        <span class="hljs-comment">// 创建了unwrappedSelector对象</span><br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">unwrappedSelector = provider.openSelector();<br></code></pre></td></tr></table></figure><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectorTuple</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">final</span> Selector selector;<br><br>    SelectorTuple(Selector unwrappedSelector) &#123;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-built_in">this</span>.selector = unwrappedSelector;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 一般调用的是这个构造方法</span><br><span class="hljs-comment">    */</span><br>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-built_in">this</span>.selector = selector;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h3 id="两个Selector的区别"><a href="#两个Selector的区别" class="headerlink" title="两个Selector的区别"></a>两个Selector的区别</h3><p><code>NioEventLoop</code>中有<code>selector</code>和<code>unwrappedSelector</code>两个<code>Selector</code>，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li><code>selector</code>中的<code>SelectedKeys</code>是<strong>基于数组</strong>的</li><li><code>unwrappedSelector</code>中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title function_">openSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br><br>    ...<br>    <br>    <span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectedSelectionKeySet</span> <span class="hljs-variable">selectedKeySet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySet</span>();<br><br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">maybeException</span> <span class="hljs-operator">=</span> AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span><br>                <span class="hljs-type">Field</span> <span class="hljs-variable">selectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>                <span class="hljs-type">Field</span> <span class="hljs-variable">publicSelectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br><br>                ...<br><br>                <span class="hljs-comment">// 暴力反射，修改私有属性</span><br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br>                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br><br>                <span class="hljs-comment">// 替换为基于数组的selectedKeys实现</span><br>                selectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    selectedKeys = selectedKeySet;<br>    <br>    <span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySetSelector</span>(unwrappedSelector, selectedKeySet));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="NioEventLoop启动"><a href="#NioEventLoop启动" class="headerlink" title="NioEventLoop启动"></a>NioEventLoop启动</h2><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;task&quot;</span>);<br>    &#125;<br><span class="hljs-comment">// 判断当前线程是否为NIO线程</span><br>    <span class="hljs-comment">// 判断方法为 return thread == this.thread;</span><br>    <span class="hljs-comment">// this.thread即为NIO线程，首次执行任务时，其为null</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">inEventLoop</span> <span class="hljs-operator">=</span> inEventLoop();<br>    <span class="hljs-comment">// 向任务队列taskQueue中添加任务</span><br>    addTask(task);<br>    <span class="hljs-comment">// 当前线程不是NIO线程，则进入if语句</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-comment">// 启动NIO线程的核心方法</span><br>        startThread();<br>        <span class="hljs-keyword">if</span> (isShutdown()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">reject</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (removeTask(task)) &#123;<br>                    reject = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException e) &#123;<br>                <br>            &#125;<br>            <span class="hljs-keyword">if</span> (reject) &#123;<br>                reject();<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>startThread</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查看NIO线程状态是否为未启动</span><br>    <span class="hljs-comment">// 该if代码块只会执行一次</span><br>    <span class="hljs-comment">// state一开始的值就是ST_NOT_STARTED</span><br>    <span class="hljs-comment">// private volatile int state = ST_NOT_STARTED;</span><br>    <span class="hljs-keyword">if</span> (state == ST_NOT_STARTED) &#123;<br>        <span class="hljs-comment">// 通过CAS将状态更新为启动（ST_STARTED）</span><br>        <span class="hljs-keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行启动线程</span><br>                doStartThread();<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, ST_STARTED, ST_NOT_STARTED);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStartThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">assert</span> thread == <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 创建NIO线程并执行任务</span><br>    executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// thread即为NIO线程</span><br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行内部run方法</span><br>                SingleThreadEventExecutor.<span class="hljs-built_in">this</span>.run();<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <br>            <br>            ...<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    select(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br>                    <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                        selector.wakeup();<br>                    &#125;<br>                <span class="hljs-keyword">default</span>:<br>            &#125;<br>...<br>            processSelectedKeys();<br>            runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>NioEventLoop</code>执行过程大致可以分为如下三个步骤</strong></p><ol><li><p>轮询检测IO事件</p></li><li><p>处理产生IO事件</p></li><li><p>处理异步任务队列</p></li></ol><h3 id="轮询检测IO事件"><a href="#轮询检测IO事件" class="headerlink" title="轮询检测IO事件"></a>轮询检测IO事件</h3><p>轮询检测<code>IO</code>事件在以下代码中完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">select(wakenUp.getAndSet(<span class="hljs-literal">false</span>));<br><span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>    selector.wakeup();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>wakenUp</code>表示是否应该唤醒正在阻塞的<code>select</code>操作，可以看到<code>Netty</code>在进行一次新轮询之前都会将<code>wakeUp</code>设置成<code>false</code>标志新的一轮轮询的开始。接下来我们来看一下具体的<code>select</code>操作，它可以分为以下三个部分</p><ol><li><strong>定时任务截止时间快到了，中断本次轮询</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">selectCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">currentTimeNanos</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-type">long</span> <span class="hljs-variable">selectDeadLineNanos</span> <span class="hljs-operator">=</span> currentTimeNanos + delayNanos(currentTimeNanos);<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">timeoutMillis</span> <span class="hljs-operator">=</span> (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>) / <span class="hljs-number">1000000L</span>;<br>    <span class="hljs-keyword">if</span> (timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (selectCnt == <span class="hljs-number">0</span>) &#123;<br>            selector.selectNow();<br>            selectCnt = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到<code>NioEventLoop</code>中<code>Reactor</code>线程的<code>select</code>操作也是一个<code>for</code>循环，在<code>for</code>循环第一步中如果发现当前的定时任务队列中有任务的截止事件快到了<code>&lt;=0.5ms</code>就跳出循环。此外跳出之前如果发现目前为止还没有进行过<code>select</code>操作那么就会调用一次<code>selectNow()</code>，该方法会立即返回不会阻塞。<code>Netty</code>里面定时任务队列是按照延迟时间从小到大进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title function_">delayNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> currentTimeNanos)</span> &#123;<br>    ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();<br>    <span class="hljs-keyword">if</span> (scheduledTask == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> SCHEDULE_PURGE_INTERVAL;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> scheduledTask.delayNanos(currentTimeNanos);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>delayNanos</code>方法取出的是第一个定时任务的延迟时间，如果没有任务默认值为1秒</p><ol start="2"><li><strong>轮询过程中发现有任务加入或被唤醒，中断本次轮询</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 1.定时任务截至事时间快到了，中断本次轮询</span><br>    ...<br><br>    <span class="hljs-comment">// 2.轮询过程中发现有任务加入，中断本次轮询</span><br>    <span class="hljs-keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>        selector.selectNow();<br>        selectCnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>判断任务队列是否为空或者是否被唤醒，若不为空或被唤醒就执行一次非阻塞<code>select</code>操作，跳出循环立即返回</p><ol start="3"><li><strong>阻塞式select操作</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 1.定时任务截至事时间快到了，中断本次轮询</span><br>    ...<br>    <span class="hljs-comment">// 2.轮询过程中发现有任务加入，中断本次轮询</span><br>    ...<br>    <span class="hljs-comment">// 3.阻塞式select操作</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">selectedKeys</span> <span class="hljs-operator">=</span> selector.select(timeoutMillis);<br>    selectCnt ++;<br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>执行到这一步说明<code>Netty</code>任务队列里面队列为空，并且所有定时任务延迟时间还未到<code>大于0.5ms</code>，于是在这里进行一次阻塞式<code>select</code>操作，截止到第一个定时任务的截止时间。如果第一个定时任务的延迟非常长(比如一个小时)那么线程有可能一直阻塞在<code>select</code>操作，但是只要在这段时间内有新任务加入该阻塞就会被释放</p><p>外部线程调用<code>execute</code>方法添加任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123; <br>    ...<br>    <span class="hljs-comment">// inEventLoop为false</span><br>    <span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>wakeup</code>方法唤醒<code>selector</code>阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">boolean</span> inEventLoop)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>        selector.wakeup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在外部线程添加任务的时候，会调用<code>wakeup</code>方法来唤醒<code>selector.select(timeoutMillis)</code></p><p>阻塞<code>select</code>操作结束之后<code>Netty</code>又做了一系列的状态判断来决定是否中断本次轮询，中断本次轮询的条件有</p><ul><li>轮询到IO事件</li><li>oldWakenUp参数为true</li><li>任务队列里面有任务hasTasks</li><li>第一个定时任务即将要被执行</li><li>用户主动唤醒 &#x3D;&gt; wakenUp.get()</li></ul><h4 id="避免JDK空轮询BUG"><a href="#避免JDK空轮询BUG" class="headerlink" title="避免JDK空轮询BUG"></a>避免JDK空轮询BUG</h4><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        ...<br>        <span class="hljs-comment">// 可能发生空轮询，无法阻塞NIO线程</span><br>        strategy = select(curDeadlineNanos);  <br>        ...     <br>    <br>     <span class="hljs-keyword">if</span>(...) &#123;<br>...<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;<br>            <span class="hljs-comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span><br>            <span class="hljs-comment">// 并将selectCnt重置为0</span><br>            selectCnt = <span class="hljs-number">0</span>;<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么<code>selectCnt</code>的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">currentTimeNanos</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">// 1.定时任务截止事时间快到了，中断本次轮询</span><br>    ...<br>    <span class="hljs-comment">// 2.轮询过程中发现有任务加入，中断本次轮询</span><br>    ...<br>    <span class="hljs-comment">// 3.阻塞式select操作</span><br>    selector.select(timeoutMillis);<br>    <span class="hljs-comment">// 4.解决jdk的nio bug</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    <span class="hljs-keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;<br>        selectCnt = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br><br>        rebuildSelector();<br>        selector = <span class="hljs-built_in">this</span>.selector;<br>        selector.selectNow();<br>        selectCnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    currentTimeNanos = time; <br>    ...<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>通过<code>rebuildSelector</code>方法重建<code>selector</code>，将原<code>selector</code>的配置信息传给新<code>selector</code>，再用新<code>selector</code>覆盖旧<code>selector</code>。同时将<code>selectCnt</code>的值设置为0</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rebuildSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Selector</span> <span class="hljs-variable">oldSelector</span> <span class="hljs-operator">=</span> selector;<br>    <span class="hljs-keyword">final</span> Selector newSelector;<br>    newSelector = openSelector();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nChannels</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">for</span> (SelectionKey key: oldSelector.keys()) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> key.attachment();<br>                <span class="hljs-keyword">if</span> (!key.isValid() || key.channel().keyFor(newSelector) != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> key.interestOps();<br>                key.cancel();<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">newKey</span> <span class="hljs-operator">=</span> key.channel().register(newSelector, interestOps, a);<br>                <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>                    ((AbstractNioChannel) a).selectionKey = newKey;<br>                &#125;<br>                nChannels ++;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ConcurrentModificationException e) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    selector = newSelector;<br>    oldSelector.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>rebuildSelector</code>的操作其实很简单:<code>new</code>一个新的<code>selector</code>，将之前注册到老的<code>selector</code>上的<code>channel</code>重新转移到新的<code>selector</code>上。它是通过<code>openSelector()</code>方法创建一个新的<code>selector</code>然后执行一个死循环，只要执行过程中出现过一次并发修改<code>selectionKeys</code>异常就重新开始转移，具体的转移步骤为</p><ol><li>拿到有效的key</li><li>取消该key在旧的selector上的事件注册</li><li>将该key对应的channel注册到新的selector上</li><li>重新绑定channel和新的key的关系</li></ol><p>转移完成之后就可以将原有的<code>selector</code>废弃，后面所有的轮询都是在新的<code>selector</code>进行</p><h3 id="处理产生的IO事件"><a href="#处理产生的IO事件" class="headerlink" title="处理产生的IO事件"></a>处理产生的IO事件</h3><p>处理<code>IO</code>事件的过程是在<code>processSelectedKeys()</code>中完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKeys</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-literal">null</span>) &#123;<br>        processSelectedKeysOptimized();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>selectedKeys</code>是<code>SelectedSelectionKeySet</code>对象的实例，它是在<code>NioEventLoop</code>的构造方法中调用的<code>openSelector</code>时初始化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Selector NioEventLoop.openSelector() &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectedSelectionKeySet</span> <span class="hljs-variable">selectedKeySet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySet</span>();<br>    <span class="hljs-comment">// selectorImplClass -&gt; sun.nio.ch.SelectorImpl</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">selectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">publicSelectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br>    selectedKeysField.setAccessible(<span class="hljs-literal">true</span>);<br>    publicSelectedKeysField.setAccessible(<span class="hljs-literal">true</span>);<br>    selectedKeysField.set(selector, selectedKeySet);<br>    publicSelectedKeysField.set(selector, selectedKeySet);<br>    <span class="hljs-comment">//...</span><br>    selectedKeys = selectedKeySet;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过反射将<code>selectedKeys</code>与<code>sun.nio.ch.SelectorImpl</code>中的两个<code>field</code>绑定，这两个<code>field</code>其实是两个<code>HashSet</code>。<code>selector</code>在调用<code>select()</code>方法的时候如果有<code>IO</code>事件发生，就会往里面的两个<code>field</code>中塞相应的<code>selectionKey</code>，相当于往一个<code>hashSet</code>中<code>add</code>元素，<code>Netty</code>通过反射将<code>JDK</code>中的两个<code>field</code>替换掉，接下来我们看一下<code>Netty</code>自定义<code>SelectedSelectionKeySet</code>的<code>add</code>方法做了哪些优化？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectedSelectionKeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;SelectionKey&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> SelectionKey[] keysA;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> keysASize;<br>    <span class="hljs-keyword">private</span> SelectionKey[] keysB;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> keysBSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    SelectedSelectionKeySet() &#123;<br>        keysA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionKey</span>[<span class="hljs-number">1024</span>];<br>        keysB = keysA.clone();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(SelectionKey o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isA) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> keysASize;<br>            keysA[size ++] = o;<br>            keysASize = size;<br>            <span class="hljs-keyword">if</span> (size == keysA.length) &#123;<br>                doubleCapacityA();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> keysBSize;<br>            keysB[size ++] = o;<br>            keysBSize = size;<br>            <span class="hljs-keyword">if</span> (size == keysB.length) &#123;<br>                doubleCapacityB();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doubleCapacityA</span><span class="hljs-params">()</span> &#123;<br>        SelectionKey[] newKeysA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionKey</span>[keysA.length &lt;&lt; <span class="hljs-number">1</span>];<br>        System.arraycopy(keysA, <span class="hljs-number">0</span>, newKeysA, <span class="hljs-number">0</span>, keysASize);<br>        keysA = newKeysA;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doubleCapacityB</span><span class="hljs-params">()</span> &#123;<br>        SelectionKey[] newKeysB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionKey</span>[keysB.length &lt;&lt; <span class="hljs-number">1</span>];<br>        System.arraycopy(keysB, <span class="hljs-number">0</span>, newKeysB, <span class="hljs-number">0</span>, keysBSize);<br>        keysB = newKeysB;<br>    &#125;<br><br>    SelectionKey[] flip() &#123;<br>        <span class="hljs-keyword">if</span> (isA) &#123;<br>            isA = <span class="hljs-literal">false</span>;<br>            keysA[keysASize] = <span class="hljs-literal">null</span>;<br>            keysBSize = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> keysA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            isA = <span class="hljs-literal">true</span>;<br>            keysB[keysBSize] = <span class="hljs-literal">null</span>;<br>            keysASize = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> keysB;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isA) &#123;<br>            <span class="hljs-keyword">return</span> keysASize;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> keysBSize;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;SelectionKey&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类继承了<code>AbstractSet</code>说明该类可以当作一个<code>set</code>来用，但是底层使用两个数组来交替使用，在<code>add</code>方法中判断当前使用哪个数组，找到对应的数组，然后经历下面三个步骤</p><ol><li>将<code>SelectionKey</code>塞到该数组的逻辑尾部</li><li>更新该数组的逻辑长度+1</li><li>如果该数组的逻辑长度等于数组的物理长度，就将该数组扩容</li></ol><p>待程序跑过一段时间，等数组的长度足够长每次在轮询到<code>NIO</code>事件的时候，<code>Netty</code>只需要<code>O(1)</code>的时间复杂度就能将<code>SelectionKey</code>塞到<code>set</code>中去，而<code>JDK</code>底层使用的<code>hashSet</code>需要<code>O(lgn)</code>的时间复杂度，接下来我们继续跟进<code>processSelectedKeysOptimized</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKeysOptimized</span><span class="hljs-params">(SelectionKey[] selectedKeys)</span> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;; i ++) &#123;<br>         <span class="hljs-comment">// 1.取出IO事件以及对应的channel</span><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> selectedKeys[i];<br>         <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>         selectedKeys[i] = <span class="hljs-literal">null</span>;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> k.attachment();<br>         <span class="hljs-comment">// 2.处理该channel</span><br>         <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>             processSelectedKey(k, (AbstractNioChannel) a);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;<br>             processSelectedKey(k, task);<br>         &#125;<br>         <span class="hljs-comment">// 3.判断是否该再来次轮询</span><br>         <span class="hljs-keyword">if</span> (needsToSelectAgain) &#123;<br>             <span class="hljs-keyword">for</span> (;;) &#123;<br>                 i++;<br>                 <span class="hljs-keyword">if</span> (selectedKeys[i] == <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-keyword">break</span>;<br>                 &#125;<br>                 selectedKeys[i] = <span class="hljs-literal">null</span>;<br>             &#125;<br>             selectAgain();<br>             selectedKeys = <span class="hljs-built_in">this</span>.selectedKeys.flip();<br>             i = -<span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实也能体会到优化过的<code>SelectedSelectionKeySet</code>的好处，遍历的时候遍历的是数组相对<code>JDK</code>原生的<code>HashSet</code>效率有所提高。拿到当前<code>SelectionKey</code>之后将<code>selectedKeys[i]</code>置为<code>null</code>，这里解释一下这么做的理由:想象一下这种场景假设一个<code>NioEventLoop</code>平均每次轮询出<code>N</code>个<code>IO</code>事件高峰期轮询出<code>3N</code>个事件，那么<code>selectedKeys</code>的物理长度要大于等于<code>3N</code>，如果每次处理这些<code>key</code>不设置<code>selectedKeys[i]</code>为空，高峰期一过这些存在数组尾部的<code>selectedKeys[i]</code>对应的<code>SelectionKey</code>将一直无法被回收，<code>SelectionKey</code>对应的对象可能不大，但是它的<code>attachment</code>可能很大，这样一来这些元素是<code>GC Root</code>可达的很容易造成<code>GC</code>不掉，内存泄漏就发生了</p><h3 id="处理异步任务队列"><a href="#处理异步任务队列" class="headerlink" title="处理异步任务队列"></a>处理异步任务队列</h3><h4 id="用户自定义普通任务"><a href="#用户自定义普通任务" class="headerlink" title="用户自定义普通任务"></a>用户自定义普通任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们跟进<code>execute</code>方法，看重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    addTask(task);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>execute</code>方法调用<code>addTask</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTask</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!offerTask(task)) &#123;<br>        reject(task);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerTask</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> taskQueue.offer(task);<br>&#125;<br></code></pre></td></tr></table></figure><p>跟到<code>offerTask</code>方法基本上<code>task</code>就落地了，<code>Netty</code>内部使用一个<code>taskQueue</code>将<code>task</code>保存起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue;<br><br>taskQueue = newTaskQueue(<span class="hljs-built_in">this</span>.maxPendingTasks);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Queue&lt;Runnable&gt; <span class="hljs-title function_">newTaskQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPendingTasks)</span> &#123;<br>    <span class="hljs-comment">// This event loop never calls takeTask()</span><br>    <span class="hljs-keyword">return</span> PlatformDependent.newMpscQueue(maxPendingTasks);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>taskQueue</code>在<code>SingleThreadEventExecutor</code>构造方法中被初始化，我们发现<code>taskQueue</code>在<code>NioEventLoop</code>中默认实现是<code>MPSC</code>队列(<code>MPSC</code>队列即多生产者单消费者队列)，<code>Netty</code>使用<code>MPSC</code>方便的将外部线程的<code>task</code>聚集在<code>Reactor</code>线程内部用单线程来串行执行。我们可以借鉴<code>Netty</code>的任务执行模式来处理类似多线程数据上报，定时聚合的应用。本节讨论任务场景中所有代码执行都是在<code>Reactor</code>线程中的，所以所有调用<code>inEventLoop()</code>的地方都返回<code>true</code>，既然都是在<code>reactor</code>线程中执行那么其实这里的<code>MPSC</code>队列其实没有发挥真正的作用，<code>MPSC</code>大显身手的地方其实在第二种场景</p><h4 id="非当前Reactor线程调用Channel的各种方法"><a href="#非当前Reactor线程调用Channel的各种方法" class="headerlink" title="非当前Reactor线程调用Channel的各种方法"></a>非当前Reactor线程调用Channel的各种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.write(...)<br></code></pre></td></tr></table></figure><p>它会调用<code>AbstractChannelHandlerContext</code>的<code>write</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, <span class="hljs-type">boolean</span> flush, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-keyword">if</span> (flush) &#123;<br>            next.invokeWriteAndFlush(m, promise);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.invokeWrite(m, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        AbstractWriteTask task;<br>        <span class="hljs-keyword">if</span> (flush) &#123;<br>            task = WriteAndFlushTask.newInstance(next, m, promise);<br>        &#125;  <span class="hljs-keyword">else</span> &#123;<br>            task = WriteTask.newInstance(next, m, promise);<br>        &#125;<br>        safeExecute(executor, task, promise, m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>外部线程在调用<code>write</code>的时候<code>executor.inEventLoop()</code>会返回<code>false</code>，直接进入到<code>else</code>分支将<code>write</code>封装成一个<code>WriteTask</code>(这里仅仅是<code>write</code>而没有<code>flush</code>因此<code>flush</code>参数为<code>false</code>）, 然后调用<code>safeExecute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">safeExecute</span><span class="hljs-params">(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    executor.execute(runnable);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来的调用链就进入到第一种场景了，但是和第一种场景有个明显的区别就是，第一种场景的调用链的发起线程是<code>Reactor</code>线程，第二种场景的调用链的发起线程是用户线程，用户线程可能会有很多个。显然多个线程并发写<code>taskQueue</code>可能出现线程同步问题，于是这种场景下<code>Netty</code>的<code>MPSC</code>就有了用武之地</p><h4 id="用户自定义定时任务"><a href="#用户自定义定时任务" class="headerlink" title="用户自定义定时任务"></a>用户自定义定时任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>第三种场景就是定时任务逻辑了，用的最多的便是如上方法:在一定时间之后执行任务，我们跟进<code>schedule</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(<span class="hljs-built_in">this</span>, command, <span class="hljs-literal">null</span>, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>ScheduledFutureTask</code>将用户自定义任务再次包装成一个<code>Netty</code>内部的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (inEventLoop()) &#123;<br>        scheduledTaskQueue().add(task);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                scheduledTaskQueue().add(task);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br></code></pre></td></tr></table></figure><p>在执行定时任务前<code>Netty</code>会先判断当前是否在内部线程进行调用，如果是在内部线程则直接将任务添加进队列，如果是在外部线程调用<code>schedule</code>，<code>Netty</code>将添加定时任务的逻辑封装成一个普通的<code>task</code>，这个<code>task</code>的任务是添加[添加定时任务]的任务而不是添加定时任务，其实也就是第二种场景这样对<code>PriorityQueue</code>的访问就变成单线程即只有<code>Reactor</code>线程，确保线程安全</p><p><code>scheduledTaskQueue()</code>方法会返回一个优先级队列，然后调用<code>add</code>方法将定时任务加入到队列中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() &#123;<br>    <span class="hljs-keyword">if</span> (scheduledTaskQueue == <span class="hljs-literal">null</span>) &#123;<br>        scheduledTaskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;ScheduledFutureTask&lt;?&gt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">return</span> scheduledTaskQueue;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们分析一下优先级队列中定时任务的比较规则，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    ScheduledFutureTask&lt;?&gt; that = (ScheduledFutureTask&lt;?&gt;) o;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> deadlineNanos() - that.deadlineNanos();<br>    <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id &lt; that.id) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id == that.id) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个定时任务的比较是先比较任务的截止时间，截止时间相同的情况下再比较<code>ID</code>(即任务添加的顺序)，若<code>ID</code>再相同抛异常，这样在执行定时任务的时候就能保证最近截止时间的任务先执行。下面我们再来看下<code>Netty</code>是如何来保证各种定时任务的执行的，<code>Netty</code>里面的定时任务分以下三种</p><ol><li>若干时间后执行一次</li><li>每隔一段时间执行一次</li><li>每次执行结束，隔一定时间再执行一次</li></ol><h4 id="任务的调度"><a href="#任务的调度" class="headerlink" title="任务的调度"></a>任务的调度</h4><p>在了解了Netty内部的任务添加机制后，我们回到处理异步任务队列方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">runAllTasks(<span class="hljs-type">long</span> timeoutNanos);<br></code></pre></td></tr></table></figure><p>这行代码表示了尽量在一定的时间内将所有的任务都取出来<code>run</code>一遍，<code>timeoutNanos</code>表示该方法最多执行这么长时间(这里有个<code>ioRatio</code>的变量意思是<code>IO</code>任务所占的比重(默认是<code>50</code>)，也就是说<code>IO</code>任务和非<code>IO</code>任务所分配的时间是<code>1:1</code>)。因为如果<code>Reactor</code>线程在此停留的时间过长，那么将积攒许多的<code>IO</code>事件无法处理最终导致大量客户端请求阻塞，因此默认情况下<code>Netty</code>将控制内部队列的执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAllTasks</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutNanos)</span> &#123;<br>    fetchFromScheduledTaskQueue();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> pollTask();<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> ScheduledFutureTask.nanoTime() + timeoutNanos;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">runTasks</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> lastExecutionTime;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        safeExecute(task);<br>        runTasks ++;<br>        <span class="hljs-keyword">if</span> ((runTasks &amp; <span class="hljs-number">0x3F</span>) == <span class="hljs-number">0</span>) &#123;<br>            lastExecutionTime = ScheduledFutureTask.nanoTime();<br>            <span class="hljs-keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        task = pollTask();<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>            lastExecutionTime = ScheduledFutureTask.nanoTime();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    afterRunningAllTasks();<br>    <span class="hljs-built_in">this</span>.lastExecutionTime = lastExecutionTime;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码便是Reactor执行task的所有逻辑，可以拆解成下面几个步骤</p><ol><li>从<code>scheduledTaskQueue</code>转移定时任务到<code>taskQueue(mpsc queue)</code></li><li>计算本次任务循环的截止时间</li><li>执行任务</li><li>收尾</li></ol><p><strong>从<code>scheduledTaskQueue</code>转移定时任务到<code>taskQueue(mpsc queue)</code></strong></p><p>首先调用<code>fetchFromScheduledTaskQueue()</code>方法，将到期的定时任务转移到<code>mpsc queue</code>里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">fetchFromScheduledTaskQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanoTime</span> <span class="hljs-operator">=</span> AbstractScheduledEventExecutor.nanoTime();<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">scheduledTask</span>  <span class="hljs-operator">=</span> pollScheduledTask(nanoTime);<br>    <span class="hljs-keyword">while</span> (scheduledTask != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!taskQueue.offer(scheduledTask)) &#123;<br>            <span class="hljs-comment">// No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.</span><br>            scheduledTaskQueue().add((ScheduledFutureTask&lt;?&gt;) scheduledTask);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        scheduledTask  = pollScheduledTask(nanoTime);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioEventLoop</code>会维护两个任务队列(一个定时任务队列一个正常任务队列)，这里的逻辑就是把定时任务队列中已经到执行时间的任务取出来放到正常的任务队列中去，来看下<code>pollScheduledTask</code>这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Runnable <span class="hljs-title function_">pollScheduledTask</span><span class="hljs-params">(<span class="hljs-type">long</span> nanoTime)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-title function_">inEventLoop</span><span class="hljs-params">()</span>;<br><br>    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="hljs-built_in">this</span>.scheduledTaskQueue;<br>    ScheduledFutureTask&lt;?&gt; scheduledTask = scheduledTaskQueue == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : scheduledTaskQueue.peek();<br>    <span class="hljs-keyword">if</span> (scheduledTask == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (scheduledTask.deadlineNanos() &lt;= nanoTime) &#123;<br>        scheduledTaskQueue.remove();<br>        <span class="hljs-keyword">return</span> scheduledTask;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每次<code>pollScheduledTask</code>的时候，只有在当前任务的截止时间已经到了才会取出来</p><p><strong>计算本次任务循环的截止时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> pollTask();<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> ScheduledFutureTask.nanoTime() + timeoutNanos;<br><span class="hljs-type">long</span> <span class="hljs-variable">runTasks</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> lastExecutionTime;<br></code></pre></td></tr></table></figure><p>这一步将取出第一个任务用<code>Reactor</code>线程传入的超时时间<code>timeoutNanos</code>来计算出当前任务循环<code>deadline</code>，并且使用<code>runTasks</code>，<code>lastExecutionTime</code>来时刻记录任务的状态</p><p><strong>循环执行任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    safeExecute(task);<br>    runTasks ++;<br>    <span class="hljs-keyword">if</span> ((runTasks &amp; <span class="hljs-number">0x3F</span>) == <span class="hljs-number">0</span>) &#123;<br>        lastExecutionTime = ScheduledFutureTask.nanoTime();<br>        <span class="hljs-keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    task = pollTask();<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) &#123;<br>        lastExecutionTime = ScheduledFutureTask.nanoTime();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一步便是<code>Netty</code>里面执行所有任务的核心代码了。首先调用<code>safeExecute</code>来确保任务安全执行忽略任何异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">safeExecute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        task.run();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.warn(<span class="hljs-string">&quot;A task raised an exception. Task: &#123;&#125;&quot;</span>, task, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将已运行任务<code>runTasks</code>加一，每隔<code>0x3F</code>任务(每执行完<code>64</code>个任务)判断当前时间是否超过本次<code>reactor</code>任务循环的截止时间了，如果超过那就<code>break</code>掉，如果没有超过那就继续执行。可以看到<code>Netty</code>对性能的优化考虑地相当的周到，假设<code>Netty</code>任务队列里面如果有海量小任务，如果每次都要执行完任务都要判断一下是否到截止时间，那么效率是比较低下的</p><p><strong>收尾</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">afterRunningAllTasks();<br><span class="hljs-built_in">this</span>.lastExecutionTime = lastExecutionTime;<br></code></pre></td></tr></table></figure><p>收尾工作很简单，调用一下<code>afterRunningAllTasks</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterRunningAllTasks</span><span class="hljs-params">()</span> &#123;<br>    runAllTasksFrom(tailTasks);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioEventLoop</code>可以通过父类<code>SingleThreadEventLoop</code>的<code>executeAfterEventLoopIteration</code>方法向<code>tailTasks</code>中添加收尾任务，比如你想统计一下一次执行一次任务循环花了多长时间就可以调用此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeAfterEventLoopIteration</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!tailTasks.offer(task)) &#123;<br>        reject(task);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty源码-服务端启动</title>
    <link href="/2021/08/08/Netty%E6%BA%90%E7%A0%81-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8/"/>
    <url>/2021/08/08/Netty%E6%BA%90%E7%A0%81-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty源码-服务端启动"><a href="#Netty源码-服务端启动" class="headerlink" title="Netty源码-服务端启动"></a>Netty源码-服务端启动</h1><h2 id="服务端启动Demo"><a href="#服务端启动Demo" class="headerlink" title="服务端启动Demo"></a>服务端启动Demo</h2><p>以下是一个标准的Netty服务端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel channel)</span> &#123;<br>                            <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">channelPipeline</span> <span class="hljs-operator">=</span> channel.pipeline();<br>                            channelPipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>                            channelPipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                            channelPipeline.addLast(<span class="hljs-string">&quot;handler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerHandler</span>());<br>                        &#125;<br>                    &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">8888</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ServerHandler</code>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelActive&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelRegistered&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;handlerAdded&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelReadComplete&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;channelInactive&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;service receive msg:&quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当有新连接接入时，控制台打印出</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">handlerAdded</span><br><span class="hljs-attribute">channelRegistered</span><br><span class="hljs-attribute">channelActive</span><br></code></pre></td></tr></table></figure><p>但接收到新消息时，控制台打印出</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">service <span class="hljs-keyword">receive</span> <span class="hljs-symbol">msg:</span>xxx<br>channelReadComplete<br></code></pre></td></tr></table></figure><p>本文主要分析服务端的启动过程</p><h2 id="服务端启动流程"><a href="#服务端启动流程" class="headerlink" title="服务端启动流程"></a>服务端启动流程</h2><p>Netty启动流程可以简化成如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Netty中使用NioEventLoopGroup（NIO Boss线程）来封装线程和selector</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selecotr</span> <span class="hljs-operator">=</span> Selector.open();<br><br><span class="hljs-comment">// 创建NioServerSocketChannel，同时会初始化它管理的handler，以及为原生 ssc 存储 config</span><br><span class="hljs-type">NioServerSocketChannel</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioServerSocketChannel</span>();<br><br><span class="hljs-comment">// 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open(); <br><span class="hljs-comment">// 设置为非阻塞状态</span><br>serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 启动NIO Boss线程执行接下来的操作</span><br><br><span class="hljs-comment">//注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<br><br><span class="hljs-comment">// head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><br><br><span class="hljs-comment">// 绑定端口</span><br>serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">// 触发 channel active 事件，在 head 中关注 op_accept 事件</span><br>selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><h2 id="启动源码分析"><a href="#启动源码分析" class="headerlink" title="启动源码分析"></a>启动源码分析</h2><h3 id="入口方法"><a href="#入口方法" class="headerlink" title="入口方法"></a>入口方法</h3><p><code>ServerBootstrap</code>是<code>Netty</code>为方便开发者使用而设计的一个启动类，其核心代码入口在<code>io.netty.bootstrap.ServerBootstrap.bind</code>，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> &#123;<br>validate();<br><span class="hljs-keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">&quot;localAddress&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title function_">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> &#123;<br>    <span class="hljs-comment">// 负责NioServerSOcketChannel和ServerSocketChannel的创建</span><br>    <span class="hljs-comment">// ServerSocketChannel的注册工作</span><br>    <span class="hljs-comment">// init由main线程完成，register由NIO线程完成</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br><span class="hljs-comment">// 因为register操作是异步的</span><br>    <span class="hljs-comment">// 要判断主线程执行到这里时，register操作是否已经完成</span><br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> channel.newPromise();<br>        <span class="hljs-comment">// 执行doBind0绑定操作</span><br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-comment">// 如果register操作还没有执行完，就会进入这个分支</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">PendingRegistrationPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingRegistrationPromise</span>(channel);<br>        <span class="hljs-comment">// 添加监听器，NIO线程异步进行doBind0操作</span><br>        regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    <span class="hljs-comment">// 注册失败</span><br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// 注册成功</span><br>                    promise.registered();<br><span class="hljs-comment">// 执行doBind0绑定操作</span><br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li><li><strong>initAndRegister</strong>主要负责<code>NioServerSocketChannel</code>和<code>ServerSocketChannel</code>的创建（主线程中完成）与<code>ServerSocketChannel</code>注册（NIO线程中完成）工作</li><li><strong>doBind0</strong>则负责连接的创建工作</li></ul><h3 id="服务端Channel创建"><a href="#服务端Channel创建" class="headerlink" title="服务端Channel创建"></a>服务端Channel创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建channel</span><br>        channel = channelFactory.newChannel();<br>        <span class="hljs-comment">// 初始化 添加一个初始化器ChannelInitializer</span><br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 异常处理</span><br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            channel.unsafe().closeForcibly();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><span class="hljs-comment">// 注册 将原生的channel注册到selector</span><br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Channel</code>是<code>Netty</code>的核心概念之一，它是<code>Netty</code>网络通信的主体由它负责同对端进行网络通信、注册和数据操作等功能。<code>Channel</code>的创建是由<code>channelFactory.newChannel()</code>完成的，接下来跟踪<code>channelFactory</code>是在何时被初始化，我们层层回溯最终发现是在这个函数中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> B <span class="hljs-title function_">channel</span><span class="hljs-params">(Class&lt;? extends C&gt; channelClass)</span> &#123;<br>    <span class="hljs-keyword">if</span> (channelClass == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;channelClass&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> channelFactory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;C&gt;(channelClass));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Channel</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelFactory</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; clazz;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReflectiveChannelFactory</span><span class="hljs-params">(Class&lt;? extends T&gt; clazz)</span> &#123;<br>        <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;clazz&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.clazz = clazz;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newChannel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> clazz.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + clazz, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>即在<code>Netty</code>服务端启动的时候通过反射方式(调用默认构造函数)来创建一个<code>NioServerSocketChannel</code>对象，加下来我们继续跟进<code>NioServerSocketChannel</code>的默认构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioServerSocketChannel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-title function_">newSocket</span><span class="hljs-params">(SelectorProvider provider)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处相当于ServerSocketChannel.open()</span><br>        <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>        <span class="hljs-keyword">return</span> provider.openServerSocketChannel();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Failed to open a server socket.&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>newSocket(DEFAULT_SELECTOR_PROVIDER)</code>创建一条<code>server</code>端<code>channel</code>，然后进入到以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioServerSocketChannel</span><span class="hljs-params">(ServerSocketChannel channel)</span> &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-literal">null</span>, channel, SelectionKey.OP_ACCEPT);<br>    config = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioServerSocketChannelConfig</span>(<span class="hljs-built_in">this</span>, javaChannel().socket());<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法主要完成两个功能，首先是调用父类的构造方法然后初始化<code>NioServerSocketChannelConfig</code>属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractNioMessageChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch, <span class="hljs-type">int</span> readInterestOp)</span> &#123;<br>    <span class="hljs-built_in">super</span>(parent, ch, readInterestOp);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractNioChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch, <span class="hljs-type">int</span> readInterestOp)</span> &#123;<br>    <span class="hljs-built_in">super</span>(parent);<br>    <span class="hljs-built_in">this</span>.ch = ch;<br>    <span class="hljs-comment">// 设置SelectionKey.OP_ACCEPT事件</span><br>    <span class="hljs-built_in">this</span>.readInterestOp = readInterestOp;<br>    <span class="hljs-comment">// 设置ServerSocketChannel为非阻塞的</span><br>    ch.configureBlocking(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里将前面通过<code>provider.openServerSocketChannel()</code>创建出来的<code>ServerSocketChannel</code>保存到成员变量，然后调用<strong>将该<code>channel</code>为非阻塞模式</strong>，这是个标准的<code>JDK NIO</code>编程的写法。这里的<code>readInterestOp</code>即前面层层传入的<code>SelectionKey.OP_ACCEPT</code>，接下来继续跟进<code>super(parent)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> &#123;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>    id = newId();<br>    unsafe = newUnsafe();<br>    pipeline = newChannelPipeline();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>AbstractChannel</code>的构造方法中主要是初始化了<code>id</code>，<code>unsafe</code>，<code>pipeline</code>属性</p><h3 id="服务端Channel初始化"><a href="#服务端Channel初始化" class="headerlink" title="服务端Channel初始化"></a>服务端<code>Channel</code>初始化</h3><p>在创建完<code>Channel</code>，在<code>init</code>方法中对<code>Channel</code>进行初始化操作，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 给channel设置option</span><br>    <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();<br>    <span class="hljs-keyword">synchronized</span> (options) &#123;<br>        setChannelOptions(channel, options, logger);<br>    &#125;<br><span class="hljs-comment">// 给channel设置attr</span><br>    <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();<br>    <span class="hljs-keyword">synchronized</span> (attrs) &#123;<br>        <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();<br>            channel.attr(key).set(e.getValue());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> channel.pipeline();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">currentChildGroup</span> <span class="hljs-operator">=</span> childGroup;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">currentChildHandler</span> <span class="hljs-operator">=</span> childHandler;<br>    <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;<br>    <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;<br>    <span class="hljs-keyword">synchronized</span> (childOptions) &#123;<br>        <span class="hljs-comment">// 设置新接入channel的options</span><br>        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (childAttrs) &#123;<br>        <span class="hljs-comment">// 设置新接入channel的attrs</span><br>        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="hljs-number">0</span>));<br>    &#125;<br><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>            <span class="hljs-comment">// 设置handler到pipeline上</span><br>            <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">// 向serverChannel的流水线处理器中加入了一个ServerBootstrapAcceptor</span><br>                    <span class="hljs-comment">// 专门接受新的请求，在发生Accept事件后建立连接</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码主要完成如下功能:</p><ul><li>为<code>channel</code>设置<code>option</code>及<code>attr</code></li><li>初始化服务端<code>channel</code>的<code>pipeline</code><ul><li>添加自定义<code>handler</code></li><li>添加<code>ServerBootstrapAcceptor</code>(请求接入器)</li></ul></li></ul><p><code>NioEventLoop.execute()</code>方法为<code>Netty Reactor</code>线程执行的入口，执行到这里<code>Netty</code>并未真正启动服务，只是初始化了一些基本的配置和属性以及在<code>pipeline</code>上加入了一个接入器用来专门接受新连接</p><h3 id="将Channel注册到事件轮询器"><a href="#将Channel注册到事件轮询器" class="headerlink" title="将Channel注册到事件轮询器"></a>将<code>Channel</code>注册到事件轮询器</h3><p><code>Channel</code>注册的入口方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> config().group().register(channel);<br></code></pre></td></tr></table></figure><p>此处的<code>config().group()</code>返回的对象为<code>NioEventLoopGroup</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span> &#123;<br>    <span class="hljs-comment">// 调用了NioEventLoop对象中的register方法</span><br>    <span class="hljs-comment">// NioEventLoop extends SingleThreadEventLoop</span><br>    <span class="hljs-keyword">return</span> next().register(channel);<br>&#125; <br></code></pre></td></tr></table></figure><p>在<code>next</code>方法中返回一个<code>EventLoop</code>对象，每一个<code>EventLoop</code>都与一个<code>selector</code>绑定</p><p>在之前的代码中<code>EventLoop</code>中的<code>Selector</code>一直没有任何<code>Channel</code>注册，所以每次<code>select</code>操作都是空，但从这行代码开始这个<code>selector</code>中开始有<code>Channel</code>注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span> &#123;<br>    <span class="hljs-keyword">return</span> register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(channel, <span class="hljs-built_in">this</span>));<br>&#125;<br><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    ObjectUtil.checkNotNull(promise, <span class="hljs-string">&quot;promise&quot;</span>);<br>    promise.channel().unsafe().register(<span class="hljs-built_in">this</span>, promise);<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到<code>register</code>操作是委托给<code>Channel</code>中的<code>Unsafe</code>对象来执行的，这里的<code>Unsafe</code>对象就是创建<code>NioServerSocketChannel</code>的时候创建的<code>Unsafe</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;eventLoop&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isRegistered()) &#123;<br>        promise.setFailure(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;registered to an event loop already&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isCompatible(eventLoop)) &#123;<br>        promise.setFailure(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">// 获取EventLoop</span><br>    AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = eventLoop;<br><span class="hljs-comment">// 此处完成了由主线程到NIO线程的切换</span><br>    <span class="hljs-comment">// eventLoop.inEventLoop()用于判断当前线程是否为NIO线程</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//向NIO线程中添加任务</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">// 该方法中会执行doRegister</span><br>                    <span class="hljs-comment">// 执行真正的注册功能</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            logger.warn(<br>                    <span class="hljs-string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,<br>                    AbstractChannel.<span class="hljs-built_in">this</span>, t);<br>            closeForcibly();<br>            closeFuture.setClosed();<br>            safeSetFailure(promise, t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先将<code>EventLoop</code>事件循环器绑定到该<code>NioServerSocketChannel</code>上，然后调用<code>register0()</code>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">firstRegistration</span> <span class="hljs-operator">=</span> neverRegistered;<br>        <span class="hljs-comment">// 执行真正的注册操作</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        registered = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 调用init中的initChannel方法</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br><br>        safeSetSuccess(promise);<br>        pipeline.fireChannelRegistered();<br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>doRegister()</code>进行注册，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">selected</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// javaChannel()返回ServerSocketChannel</span><br>            <span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的selector</span><br>            <span class="hljs-comment">// this为NioServerSocketChannel，作为附件</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处调用的就是<code>JDK</code>底层的<code>Channel</code>注册到<code>Selector</code>的过程，但是这里的<code>OPS</code>为0即不关心任何事件，而我们期望<code>OPS</code>的值为<code>SelectionKey.OP_ACCEPT</code>，所以到了这里代码还没有结束。</p><p>在执行完<code>Channel</code>注册后接着执行了几个<code>pipeline</code>相关的方法，也就是在<code>register0</code>中调用的<code>invokeHandlerAddedIfNeeded</code>方法，会回调<code>initChannel</code>，在后续<code>pipeline</code>的文章中具体分析</p><p><code>initChannel</code>方法代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>    <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>    <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>        pipeline.addLast(handler);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加新任务，任务负责添加handler</span><br>    <span class="hljs-comment">// 该handler负责发生Accepet事件后建立连接</span><br>    ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务端Channel端口绑定"><a href="#服务端Channel端口绑定" class="headerlink" title="服务端Channel端口绑定"></a>服务端<code>Channel</code>端口绑定</h3><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向<code>Promise</code>中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的<code>ChannelFuture</code>对象<code>regFuture</code>便会由NIO线程异步执行<code>doBind0</code>绑定操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// initAndRegister为异步方法，会返回ChannelFuture对象</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>        <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>            promise.setFailure(cause);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            promise.registered();<br>            <span class="hljs-comment">// 如果没有异常，则执行绑定操作</span><br>            doBind0(regFuture, channel, localAddress, promise);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>doBind0</code>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBind0</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;<br>                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                promise.setFailure(regFuture.cause());<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>dobind0()</code>方法中通过<code>EventLoop</code>执行一个任务，接下来我们进入到<code>channel.bind()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">return</span> pipeline.bind(localAddress, promise);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">return</span> tail.bind(localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>Debug</code>单步进入，跟踪调用链最后我们来到了<code>DefaultChannelPipeline.HeadContext</code>的<code>bind()</code>，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    unsafe.bind(localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>unsafe</code>就是前面提到的<code>AbstractUnsafe</code>, 准确点应该是<code>NioMessageUnsafe</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">wasActive</span> <span class="hljs-operator">=</span> isActive();<br>    <span class="hljs-comment">// ...</span><br>    doBind(localAddress);<br><br>    <span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>        invokeLater(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                pipeline.fireChannelActive();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    safeSetSuccess(promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>doBind</code>方法中完成绑定操作，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>        <span class="hljs-comment">// 调用ServerSocketChannel的bind方法，绑定端口</span><br>        javaChannel().bind(localAddress, config.getBacklog());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        javaChannel().socket().bind(localAddress, config.getBacklog());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用到了<code>JDK</code>里面的<code>bind</code>方法真正进行了端口的绑定。按照正常流程我们前面已经分析到<code>isActive()</code>方法返回<code>false</code>，进入到<code>doBind()</code>之后如果<code>channel</code>被激活了，就发起<code>pipeline.fireChannelActive()</code>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ctx.fireChannelActive();<br>    readIfIsAutoRead();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pipeline.channelActive</code>会逐一调用<code>pipeline</code>中每一个节点的<code>channelActive</code>方法，所以<code>HeadContext</code>的<code>channelActive</code>将会被调用，即<code>readIfIsAutoRead</code>方法将会被调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ctx.fireChannelActive();<br>    readIfIsAutoRead();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readIfIsAutoRead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (channel.config().isAutoRead()) &#123;<br>        channel.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终这个方法会调用到<code>AbstractNioChannel</code>的<code>doBeginRead</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> selectionKey.interestOps();<br>    <span class="hljs-comment">// 如果ServerSocketChannel没有关注Accept事件</span><br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 则让其关注Accept事件</span><br>        <span class="hljs-comment">// readInterestOp 取值时16</span><br>        <span class="hljs-comment">// 在NioServerSocketChannel创建时初始化</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在最后一行中的<code>readInterestOp</code>即在上文中提到的<code>SelectionKey.OP_ACCEPT</code>，即让事件轮询器关注<code>Accept</code>事件，至此完成了<code>Channel</code>对<code>ACCEPT</code>事件的注册过程</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述步骤，完成了</p><ul><li><code>NioServerSocketChannel</code>与<code>ServerSocketChannel</code>的创建</li><li><code>ServerSocketChannel</code>绑定到<code>EventLoop</code>的<code>Selector</code>中，并添加<code>NioServerSocketChannel</code>附件</li><li>绑定了对应的端口</li><li>关注了<code>Accept</code>事件</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-手写RPC</title>
    <link href="/2021/07/25/Netty-%E6%89%8B%E5%86%99RPC/"/>
    <url>/2021/07/25/Netty-%E6%89%8B%E5%86%99RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty-手写RPC"><a href="#Netty-手写RPC" class="headerlink" title="Netty-手写RPC"></a>Netty-手写RPC</h1><h2 id="一、什么是RPC"><a href="#一、什么是RPC" class="headerlink" title="一、什么是RPC"></a>一、什么是RPC</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络，从远程计算机程序上请求服务，而不必了解底层网络技术的协议。说的再直白一点，就是客户端在不必知道调用细节的前提之下，调用远程计算机上运行的某个对象，使用起来就像调用本地的对象一样。</p><p><strong>本地方法调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello, &quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要传入一个参数，调用sayHello方法就可以得到一个输出，也就是输入参数——&gt;方法体——&gt;输出，入参、出参以及方法体都在同一个进程空间中，这就是<strong>本地函数调用</strong></p><p><strong>远程方法调用</strong></p><p>那么如何实现远程方法调用，也就是跨进程的方法调用</p><p>RPC框架就是用来解决上面的问题的，它能够让调用方像调用本地函数一样调用远程服务，底层通讯细节对调用方是透明的，将各种复杂性都给屏蔽掉，给予调用方极致体验。</p><img src="/2021/07/25/Netty-%E6%89%8B%E5%86%99RPC/b" class="" title="rpc_3"><h2 id="二、设计要点"><a href="#二、设计要点" class="headerlink" title="二、设计要点"></a>二、设计要点</h2><p><strong>RPC调用过程</strong></p><img src="/2021/07/25/Netty-%E6%89%8B%E5%86%99RPC/a" class="" title="rpc_4"><p><strong>设计要点：</strong></p><ul><li><p>自定义通讯协议协议、RPC请求消息、应答消息结构，里面要包括RPC的接口定义模块、包括远程调用的类名、方法名称、参数结构、参数值等信息</p></li><li><p>服务端初始化时通过自定义注解加载RPC接口实现对象，并存放到本地容器中</p></li><li><p>支持不同序列化算法，使用枚举类定义多种序列化算法，可在配置文件中更改</p></li><li><p>支持Nacos、Zookeeper两种服务注册中心，在服务器初始化时，将RPC服务注册到服务中心，客户端调用时在服务中心获取</p></li><li><p>客户端根据调用的接口名，根据负载均衡算法从服务中心获取地址，并将调用信息通过网络，以字节流的方式送给RPC服务端，RPC服务端接收到字节流的请求之后，去对应的容器里面，查找客户端调用接口的具体实现</p></li><li><p>RPC服务端找到实现对象的参数信息，通过反射机制创建该对象的实例，并返回调用处理结果，最后封装成RPC应答消息通知到客户端。</p></li><li><p>客户端通过网络，收到字节流形式的RPC应答消息，进行拆包、解析之后，显示远程调用结果。</p></li></ul><h2 id="三、具体实现"><a href="#三、具体实现" class="headerlink" title="三、具体实现"></a>三、具体实现</h2><h3 id="1-协议（Protocol）"><a href="#1-协议（Protocol）" class="headerlink" title="1. 协议（Protocol）"></a>1. 协议（Protocol）</h3><p>通信双方的协议格式，请求对象和响应对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象父类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据消息类型字节，获得对应的消息 class</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> messageType 消息类型字节</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 消息 class</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span>&gt; getMessageClass(<span class="hljs-type">int</span> messageType) &#123;<br>        <span class="hljs-keyword">return</span> messageClasses.get(messageType);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sequenceId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> messageType;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMessageType</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PingMessage</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PongMessage</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求类型 byte 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RPC_MESSAGE_TYPE_REQUEST</span> <span class="hljs-operator">=</span> <span class="hljs-number">101</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 响应类型 byte 值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">RPC_MESSAGE_TYPE_RESPONSE</span> <span class="hljs-operator">=</span> <span class="hljs-number">102</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span>&gt;&gt; messageClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);<br>        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);<br>        messageClasses.put(PingMessage, PingMessage.class);<br>        messageClasses.put(PongMessage, PongMessage.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RPC请求消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@ToString(callSuper = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequestMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用的接口全限定名，服务端根据它找到实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用接口中的方法名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class&lt;?&gt; returnType;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数类型数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class[] parameterTypes;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数值数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object[] parameterValue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcRequestMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setSequenceId(sequenceId);<br>        <span class="hljs-built_in">this</span>.interfaceName = interfaceName;<br>        <span class="hljs-built_in">this</span>.methodName = methodName;<br>        <span class="hljs-built_in">this</span>.returnType = returnType;<br>        <span class="hljs-built_in">this</span>.parameterTypes = parameterTypes;<br>        <span class="hljs-built_in">this</span>.parameterValue = parameterValue;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMessageType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RPC响应消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ToString(callSuper = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcResponseMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object returnValue;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Exception exceptionValue;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMessageType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2. 序列化"></a>2. 序列化</h3><p>序列化接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于扩展序列化、反序列化算法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializer</span> &#123;<br><br>    <span class="hljs-comment">// 反序列化方法</span><br>    &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-type">byte</span>[] bytes)</span>;<br><br>    <span class="hljs-comment">// 序列化方法</span><br>    &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T object);<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Algorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * JDK序列化算法</span><br><span class="hljs-comment">         */</span><br>        Java &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-type">byte</span>[] bytes)</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes));<br>                    <span class="hljs-keyword">return</span> (T) ois.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;反序列化失败&quot;</span>, e);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T object) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>                    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>                    oos.writeObject(object);<br>                    <span class="hljs-keyword">return</span> bos.toByteArray();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;序列化失败&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;,<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Json序列化算法</span><br><span class="hljs-comment">         */</span><br>        Json &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-type">byte</span>[] bytes)</span> &#123;<br>                <span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassCodec</span>()).create();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, StandardCharsets.UTF_8);<br>                <span class="hljs-keyword">return</span> gson.fromJson(json, clazz);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T object) &#123;<br>                <span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassCodec</span>()).create();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> gson.toJson(object);<br>                <span class="hljs-keyword">return</span> json.getBytes(StandardCharsets.UTF_8);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassCodec</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JsonSerializer</span>&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <span class="hljs-keyword">throws</span> JsonParseException &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> json.getAsString();<br>                <span class="hljs-keyword">return</span> Class.forName(str);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonParseException</span>(e);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span>             <span class="hljs-comment">//   String.class</span><br>        <span class="hljs-keyword">public</span> JsonElement <span class="hljs-title function_">serialize</span><span class="hljs-params">(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context)</span> &#123;<br>            <span class="hljs-comment">// class -&gt; json</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonPrimitive</span>(src.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于使用Gson的Json序列化算法，在Class转Json的适合会出现异常，因此需要我们自己实现对于Class类型对象的编解码，创建CLassCodec对象实现<code>JsonSerializer</code>和<code>JsonDeserializer</code>接口，然后重写编解码方法</p><h3 id="3-编解码器"><a href="#3-编解码器" class="headerlink" title="3. 编解码器"></a>3. 编解码器</h3><p>约定好协议格式和序列化方式之后，我们还需要编解码器，编码器将请求对象转换为适合于传输的格式（一般来说是字节流），而对应的解码器是将网络字节流转换回应用程序的消息格式</p><p>可以直接继承<code>MessageToMessageCodec</code>类来同时实现编解码，服务端和客户端可直接将这个handler加入到pipeline中</p><p>加上@Sharable注解，需要同时和<code>LengthFieldBasedFrameDecoder</code>，这样可以保证接收到的消息数据是完整的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息编解码器</span><br><span class="hljs-comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageCodecSharable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>        <span class="hljs-comment">// 1. 4 字节的魔数</span><br>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        <span class="hljs-comment">// 2. 1 字节的版本,</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span><br>        out.writeByte(Config.getSerializerAlgorithm().ordinal());<br>        <span class="hljs-comment">// 4. 1 字节的指令类型</span><br>        out.writeByte(msg.getMessageType());<br>        <span class="hljs-comment">// 5. 4 个字节</span><br>        out.writeInt(msg.getSequenceId());<br>        <span class="hljs-comment">// 无意义，对齐填充</span><br>        out.writeByte(<span class="hljs-number">0xff</span>);<br>        <span class="hljs-comment">// 6. 获取内容的字节数组</span><br>        <span class="hljs-type">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);<br>        <span class="hljs-comment">// 7. 长度</span><br>        out.writeInt(bytes.length);<br>        <span class="hljs-comment">// 8. 写入内容</span><br>        out.writeBytes(bytes);<br>        outList.add(out);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">magicNum</span> <span class="hljs-operator">=</span> in.readInt();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> in.readByte();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">serializerAlgorithm</span> <span class="hljs-operator">=</span> in.readByte(); <span class="hljs-comment">// 0 或 1</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">messageType</span> <span class="hljs-operator">=</span> in.readByte(); <span class="hljs-comment">// 0,1,2...</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sequenceId</span> <span class="hljs-operator">=</span> in.readInt();<br>        in.readByte();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> in.readInt();<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>        in.readBytes(bytes, <span class="hljs-number">0</span>, length);<br><br>        <span class="hljs-comment">// 找到反序列化算法</span><br>        Serializer.<span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Serializer.Algorithm.values()[serializerAlgorithm];<br>        <span class="hljs-comment">// 确定具体消息类型</span><br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span>&gt; messageClass = Message.getMessageClass(messageType);<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> algorithm.deserialize(messageClass, bytes);<br><span class="hljs-comment">//        log.debug(&quot;&#123;&#125;&quot;, message);</span><br>        out.add(message);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Netty客户端"><a href="#4-Netty客户端" class="headerlink" title="4. Netty客户端"></a>4. Netty客户端</h3><h4 id="4-1-客户端管理类"><a href="#4-1-客户端管理类" class="headerlink" title="4.1 客户端管理类"></a>4.1 客户端管理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 管理Rpc客户端的channel</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcClientManager</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NioEventLoopGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerDiscovery serviceDiscovery;<br>    <span class="hljs-comment">//根据序号key来判断是哪个请求的消息 value是用来接收结果的 promise 对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES;<br>    <span class="hljs-comment">//channel集合  可能请求多个服务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Channel&gt; channels;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">LOCK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        group = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        initChannel();<br>        channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        PROMISES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    &#125;<br><span class="hljs-comment">//默认使用Nacos作为服务中心</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcClientManager</span><span class="hljs-params">()</span> &#123;<br>        group = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-built_in">this</span>.serviceDiscovery = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosServerDiscovery</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RoundRobinRule</span>());<br>    &#125;<br><span class="hljs-comment">//自己指定服务中心</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcClientManager</span><span class="hljs-params">(ServerDiscovery serverDiscovery)</span>&#123;<br>        group = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-built_in">this</span>.serviceDiscovery = serverDiscovery;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取channel  没有就建立链接</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inetSocketAddress</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title function_">get</span><span class="hljs-params">(InetSocketAddress inetSocketAddress)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> inetSocketAddress.toString();<br>        <span class="hljs-comment">//判断是否存在</span><br>        <span class="hljs-keyword">if</span> (channels.containsKey(key)) &#123;<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channels.get(key);<br>            <span class="hljs-keyword">if</span> (channels != <span class="hljs-literal">null</span> &amp;&amp; channel.isActive()) &#123;<br>                <span class="hljs-keyword">return</span> channel;<br>            &#125;<br>            channels.remove(key);<br>        &#125;<br>        <span class="hljs-comment">//建立连接</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            channel = bootstrap.connect(inetSocketAddress).sync().channel();<br>            channel.closeFuture().addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="hljs-built_in">super</span> Void&gt;&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-built_in">super</span> Void&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    log.debug(<span class="hljs-string">&quot;断开连接&quot;</span>);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            channel.close();<br>            log.debug(<span class="hljs-string">&quot;连接客户端出错&quot;</span> + e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        channels.put(key, channel);<br>        <span class="hljs-keyword">return</span> channel;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 channel 方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bootstrap <span class="hljs-title function_">initChannel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//日志handler</span><br>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">LOGGING_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br>        <span class="hljs-comment">//消息处理handler</span><br>        <span class="hljs-type">MessageCodecSharable</span> <span class="hljs-variable">MESSAGE_CODEC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageCodecSharable</span>();<br>        <span class="hljs-comment">//处理相应handler</span><br>        <span class="hljs-type">RpcResponseMessageHandler</span> <span class="hljs-variable">RPC_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcResponseMessageHandler</span>();<br>        <span class="hljs-comment">//心跳处理器</span><br>        <span class="hljs-type">HeartBeatClientHandler</span> <span class="hljs-variable">HEATBEAT_CLIENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeartBeatClientHandler</span>();<br>        bootstrap.channel(NioSocketChannel.class)<br>                .group(group)<br>                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS));<br>                        <span class="hljs-comment">//定长解码器</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcotolFrameDecoder</span>());<br>                        ch.pipeline().addLast(MESSAGE_CODEC);<br>                        ch.pipeline().addLast(LOGGING_HANDLER);<br>                        ch.pipeline().addLast(HEATBEAT_CLIENT);<br>                        ch.pipeline().addLast(RPC_HANDLER);<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> bootstrap;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送消息根据用户名 服务发现 找到地址</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRpcRequest</span><span class="hljs-params">(RpcRequestMessage msg)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> serviceDiscovery.getService(msg.getInterfaceName());<br>        <span class="hljs-comment">//保证高并发线程安全</span><br>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> get(service);<br>            <span class="hljs-keyword">if</span> (!channel.isActive() || !channel.isRegistered()) &#123;<br>                group.shutdownGracefully();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            channel.writeAndFlush(msg).addListener((ChannelFutureListener) future -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;客户端发送消息成功&quot;</span>);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>通过<code>ConcurrentHashMap</code>存放<code>channel</code>，可以建立多个连接，并且可以<strong>保证线程安全</strong></p></li><li><p><code>sendRpcRequest</code>方法用于发送消息，<strong>从服务中心获取调用地址</strong>，通过Netty建立网络连接</p></li><li><p><code>PROMISES</code>用来<strong>异步接收</strong>NIO线程返回的数据，与此同时，客户端可以执行其他操作，待服务端结果返回，将会触发客户端的回调方法</p></li></ul><h4 id="4-2-客户端代理类"><a href="#4-2-客户端代理类" class="headerlink" title="4.2 客户端代理类"></a>4.2 客户端代理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端创建代理类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientProxy</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RpcClientManager RPC_CLIENT;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClientProxy</span><span class="hljs-params">(RpcClientManager client)</span>&#123;<br>        <span class="hljs-built_in">this</span>.RPC_CLIENT=client;<br>    &#125;<br><br>    <span class="hljs-comment">//JDK动态代理创建代理类</span><br>    <span class="hljs-keyword">public</span>  &lt;T&gt; T <span class="hljs-title function_">getProxyService</span><span class="hljs-params">(Class&lt;T&gt; serviceClass)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> serviceClass.getClassLoader();<br>        Class&lt;?&gt;[] interfaces = serviceClass.getInterfaces();<br>        <span class="hljs-comment">//创建代理对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;<br>            <span class="hljs-comment">// 1. 将方法调用转换为 消息对象</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sequenceId</span> <span class="hljs-operator">=</span> SequenceIdGenerator.nextId();<br>            <span class="hljs-type">RpcRequestMessage</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcRequestMessage</span>(<br>                <span class="hljs-comment">//序列号</span><br>                    sequenceId,<br>                <span class="hljs-comment">//接口名</span><br>                    serviceClass.getName(),<br>                <span class="hljs-comment">//接口方法名</span><br>                    method.getName(),<br>                <span class="hljs-comment">//方法返回类型</span><br>                    method.getReturnType(),<br>                <span class="hljs-comment">//方法参数类型</span><br>                    method.getParameterTypes(),<br>                <span class="hljs-comment">//参数列表</span><br>                    args<br>            );<br>            <span class="hljs-comment">// 2. 准备一个空 Promise 对象，来接收结果 存入集合            指定 promise 对象异步接收结果线程</span><br>            DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPromise</span>&lt;Object&gt;(RpcClientManager.group.next());<br>            RpcClientManager.PROMISES.put(sequenceId, promise);<br>            <span class="hljs-comment">// 3. 将消息对象发送出去</span><br>            RPC_CLIENT.sendRpcRequest(msg);<br>            <span class="hljs-comment">// 4. 等待 promise 结果</span><br>            promise.await();<br>            <span class="hljs-keyword">if</span>(promise.isSuccess()) &#123;<br>                <span class="hljs-comment">// 调用正常</span><br>                <span class="hljs-keyword">return</span> promise.getNow();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 调用失败</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(promise.cause());<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> (T) o;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</li></ul><h4 id="4-3-客户端处理器"><a href="#4-3-客户端处理器" class="headerlink" title="4.3 客户端处理器"></a>4.3 客户端处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理RpcResponse相应的处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>            <span class="hljs-comment">// 每次使用完都要移除</span><br>            Promise&lt;Object&gt; promise = RpcClientManager.PROMISES.remove(msg.getSequenceId());<br>            <span class="hljs-keyword">if</span> (promise != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> msg.getReturnValue();<br>                <span class="hljs-type">Exception</span> <span class="hljs-variable">exceptionValue</span> <span class="hljs-operator">=</span> msg.getExceptionValue();<br>                <span class="hljs-keyword">if</span> (exceptionValue != <span class="hljs-literal">null</span>) &#123;<br>                    promise.setFailure(exceptionValue);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    promise.setSuccess(returnValue);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//调用失败</span><br>                promise.setFailure(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;promise不存在&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.debug(<span class="hljs-string">&quot;出现异常&quot;</span>+cause);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值<ul><li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li><li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li></ul></li></ul><p><strong>代理类是在主线程运行，而处理器则是NIO线程</strong></p><h3 id="5-Netty服务端"><a href="#5-Netty服务端" class="headerlink" title="5. Netty服务端"></a>5. Netty服务端</h3><h4 id="5-1-服务端管理器"><a href="#5-1-服务端管理器" class="headerlink" title="5.1 服务端管理器"></a>5.1 服务端管理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rpc服务端管理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcServiceManager</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> String host;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> port;<br>    <span class="hljs-keyword">protected</span> ServerRegistry serverRegistry;<br>    <span class="hljs-keyword">protected</span> ServiceProvider serviceProvider;<br>    <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>    <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>    <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>    <span class="hljs-comment">//默认使用Nacos作为服务中心</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcServiceManager</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.host = host;<br>        <span class="hljs-built_in">this</span>.port = port;<br>        serverRegistry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosServerRegistry</span>();<br>        serviceProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceProvider</span>();<br>        autoRegistry();<br>    &#125;<br><span class="hljs-comment">//自己指定服务中心</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcServiceManager</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port, ServerRegistry serverRegistry)</span>&#123;<br>        <span class="hljs-built_in">this</span>.host = host;<br>        <span class="hljs-built_in">this</span>.port = port;<br>        <span class="hljs-built_in">this</span>.serverRegistry = serverRegistry;<br>        serviceProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceProvider</span>();<br>        autoRegistry();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开启服务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//日志</span><br>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">LOGGING</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br>        <span class="hljs-comment">//消息节码器</span><br>        <span class="hljs-type">MessageCodecSharable</span> <span class="hljs-variable">MESSAGE_CODEC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageCodecSharable</span>();<br>        <span class="hljs-comment">//RPC请求处理器</span><br>        <span class="hljs-type">RpcRequestMessageHandler</span> <span class="hljs-variable">RPC_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcRequestMessageHandler</span>();<br>        <span class="hljs-comment">//心跳处理器</span><br>        <span class="hljs-type">HeartBeatServerHandler</span> <span class="hljs-variable">HEARTBEAT_SERVER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeartBeatServerHandler</span>();<br>        <span class="hljs-comment">//心跳请求的处理器</span><br>        <span class="hljs-type">PingMessageHandler</span> <span class="hljs-variable">PING_MESSAGE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PingMessageHandler</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            bootstrap.group(boss, worker)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">256</span>)<br>                    .option(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>                    .option(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS));<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcotolFrameDecoder</span>());<span class="hljs-comment">//定长解码器</span><br>                            pipeline.addLast(MESSAGE_CODEC);<br>                            pipeline.addLast(LOGGING);<br>                            pipeline.addLast(HEARTBEAT_SERVER);<br>                            <span class="hljs-comment">//pipeline.addLast(PING_MESSAGE);</span><br>                            pipeline.addLast(RPC_HANDLER);<br>                        &#125;<br>                    &#125;);<br>            <span class="hljs-comment">//绑定端口</span><br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> bootstrap.bind(port).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            System.err.println(<span class="hljs-string">&quot;启动服务出错&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>            boss.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自动扫描<span class="hljs-doctag">@RpcServer</span>注解  注册服务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoRegistry</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">mainClassPath</span> <span class="hljs-operator">=</span> PackageScanUtils.getStackTrace();<br>        Class&lt;?&gt; mainClass;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mainClass = Class.forName(mainClassPath);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;启动类未找到&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mainClass.isAnnotationPresent(RpcServer.class)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;启动类缺少@RpcServer 注解&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">annotationValue</span> <span class="hljs-operator">=</span> mainClass.getAnnotation(RpcServerScan.class).value();<br>        <span class="hljs-comment">//如果注解路径的值是空，则等于main父路径包下</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(annotationValue)) &#123;<br>            annotationValue = mainClassPath.substring(<span class="hljs-number">0</span>, mainClassPath.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>        &#125;<br>        <span class="hljs-comment">//获取所有类的set集合</span><br>        Set&lt;Class&lt;?&gt;&gt; set = PackageScanUtils.getClasses(annotationValue);<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; c : set) &#123;<br>            <span class="hljs-comment">//只有有@RpcServer注解的才注册</span><br>            <span class="hljs-keyword">if</span> (c.isAnnotationPresent(RpcServer.class)) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">ServerNameValue</span> <span class="hljs-operator">=</span> c.getAnnotation(RpcServer.class).name();<br>                Object object;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    object = c.newInstance();<br>                &#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;<br>                    e.printStackTrace();<br>                    System.err.println(<span class="hljs-string">&quot;创建对象&quot;</span> + c + <span class="hljs-string">&quot;发生错误&quot;</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//注解的值如果为空，使用类名</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(ServerNameValue)) &#123;<br>                   addServer(object,c.getCanonicalName());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    addServer(object, ServerNameValue);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加对象到工厂和注册到注册中心</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> server</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serverName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NacosException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">addServer</span><span class="hljs-params">(T server, String serverName)</span> &#123;<br>        serviceProvider.addServiceProvider(server, serverName);<br>        serverRegistry.register(serverName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(host, port));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>autoRegistry</code>获取所有RPC服务接口，并调用<code>addServer</code>方法将其添加到本地的<code>serviceProvider</code>中，用于后续调用，并且将其注册到服务中心</p></li><li><p><code>PackageScanUtils.getStackTrace</code>用于寻找标有@RpcServerScan的启动类</p></li><li><p><code>PackageScanUtils.getClasses</code>找到带有指定注解的所有Class</p></li></ul><h4 id="5-2-服务端处理器"><a href="#5-2-服务端处理器" class="headerlink" title="5.2 服务端处理器"></a>5.2 服务端处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rpc请求处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;RpcRequestMessage&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读事件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcRequestMessage message)</span> &#123;<br>        RpcResponseMessage responseMessage=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcResponseMessage</span>();<br>        <span class="hljs-comment">//设置请求的序号</span><br>        responseMessage.setSequenceId(message.getSequenceId());<br>        Object result;<br>        <span class="hljs-type">ServiceProvider</span> <span class="hljs-variable">serviceProvider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceProvider</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//通过名称从工厂获取本地注解了@RpcServer的实例</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> serviceProvider.getServiceProvider(message.getInterfaceName());<br>            <span class="hljs-comment">//获取方法，方法名，参数</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> service.getClass().getMethod(message.getMethodName(),message.getParameterTypes());<br>            <span class="hljs-comment">//调用</span><br>            result = method.invoke(service, message.getParameterValue());<br>            <span class="hljs-comment">//设置返回值</span><br>            responseMessage.setReturnValue(result);<br>        &#125; <span class="hljs-keyword">catch</span> ( NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>            responseMessage.setExceptionValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;远程调用出错:&quot;</span>+e.getMessage()));<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            ctx.writeAndFlush(responseMessage);<br>            <span class="hljs-comment">//便于垃圾回收</span><br>            ReferenceCountUtil.release(message);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读空闲</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;<br>            <span class="hljs-type">IdleState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> ((IdleStateEvent) evt).state();<br>            <span class="hljs-keyword">if</span> (state == IdleState.READER_IDLE) &#123;<br>                log.info(<span class="hljs-string">&quot;长时间未收到心跳包，断开连接...&quot;</span>);<br>                ctx.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">super</span>.userEventTriggered(ctx, evt);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过传过来的接口名从本地的<code>serviceProvider</code>中寻找指定的实现类，然后通过反射机制调用指定方法，并将结果返回</li></ul><h3 id="6-注册中心"><a href="#6-注册中心" class="headerlink" title="6. 注册中心"></a>6. 注册中心</h3><h4 id="6-1-服务注册和发现接口"><a href="#6-1-服务注册和发现接口" class="headerlink" title="6.1 服务注册和发现接口"></a>6.1 服务注册和发现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务发现接口</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServerDiscovery</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据服务名找到InetSocketAddress</span><br><span class="hljs-comment">     */</span><br>    InetSocketAddress  <span class="hljs-title function_">getService</span><span class="hljs-params">(String serviceName)</span> <span class="hljs-keyword">throws</span> NacosException;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务注册接口</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServerRegistry</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将服务的名称和地址注册进服务注册中心</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serviceName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inetSocketAddress</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String serviceName, InetSocketAddress inetSocketAddress)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-2-Nacos实现"><a href="#6-2-Nacos实现" class="headerlink" title="6.2 Nacos实现"></a>6.2 Nacos实现</h4><p><strong>Nacos工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Nacos工具类管理连接获取等操作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> NamingService namingService;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; serviceNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InetSocketAddress address;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_ADDR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1:8848&quot;</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        namingService = getNacosNamingService();<br>    &#125;<br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NamingService <span class="hljs-title function_">getNacosNamingService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);<br>        &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;连接到Nacos时发生错误&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册服务</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serverName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NacosException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerServer</span><span class="hljs-params">(String serverName, InetSocketAddress address)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        namingService.registerInstance(serverName, address.getHostName(), address.getPort());<br>        NacosUtils.address = address;<br>        serviceNames.add(serverName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前服务名中的所有实例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serverName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NacosException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;InetSocketAddress&gt; <span class="hljs-title function_">getAllInstance</span><span class="hljs-params">(String serverName)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        List&lt;InetSocketAddress&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Instance instance : namingService.getAllInstances(serverName)) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(instance.getIp(), instance.getPort()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注销服务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearRegister</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!serviceNames.isEmpty() &amp;&amp; address != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> address.getHostName();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> address.getPort();<br>            Iterator&lt;String&gt; iterator = serviceNames.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> iterator.next();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    namingService.deregisterInstance(serviceName, host, port);<br>                &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;注销服务失败&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Nacos服务发现实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Nacos服务发现实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosServerDiscovery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServerDiscovery</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoadBalancer loadBalancer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NacosServerDiscovery</span><span class="hljs-params">(LoadBalancer loadBalancer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loadBalancer = loadBalancer == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoundRobinRule</span>() : loadBalancer;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据服务名找到服务地址</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serviceName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title function_">getService</span><span class="hljs-params">(String serviceName)</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        List&lt;InetSocketAddress&gt; instanceList = NacosUtils.getAllInstance(serviceName);<br>        System.out.println(serviceName);<br>        <span class="hljs-keyword">if</span> (instanceList.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;找不到对应服务&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> loadBalancer.getInstance(instanceList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Nacos服务注册实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Nacos服务注册实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosServerRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServerRegistry</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务注册</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serviceName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inetSocketAddress</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String serviceName, InetSocketAddress inetSocketAddress)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            NacosUtils.registerServer(serviceName,inetSocketAddress);<br>            System.out.println(<span class="hljs-string">&quot;注册&quot;</span>+serviceName);<br>        &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;注册Nacos出现异常&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-3-Zookeeper实现"><a href="#6-3-Zookeeper实现" class="headerlink" title="6.3 Zookeeper实现"></a>6.3 Zookeeper实现</h4><p><strong>Zookeeper工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Zookeeper工具类管理连接获取等操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CuratorFramework zkClient;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROOT_PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RPC&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_ADDR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">RetryPolicy</span> <span class="hljs-variable">policy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>        zkClient = CuratorFrameworkFactory.builder().connectString(SERVER_ADDR)<br>                .sessionTimeoutMs(<span class="hljs-number">40000</span>).retryPolicy(policy).namespace(ROOT_PATH).build();<br>        zkClient.start();<br>        System.out.println(<span class="hljs-string">&quot;zookeeper 连接成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerServer</span><span class="hljs-params">(String serviceName, InetSocketAddress address)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(zkClient.checkExists().forPath(<span class="hljs-string">&quot;/&quot;</span> + serviceName) == <span class="hljs-literal">null</span>)&#123;<br>                zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/&quot;</span> + serviceName);<br>            &#125;<br>            <span class="hljs-comment">// 路径地址，一个/代表一个节点</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span> + serviceName +<span class="hljs-string">&quot;/&quot;</span>+ getServiceAddress(address);<br>            <span class="hljs-comment">// 临时节点，服务器下线就删除节点</span><br>            zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前服务的所有实例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serviceName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;InetSocketAddress&gt; <span class="hljs-title function_">getAllInstance</span><span class="hljs-params">(String serviceName)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; strings = zkClient.getChildren().forPath(<span class="hljs-string">&quot;/&quot;</span> + serviceName);<br>            <span class="hljs-keyword">return</span> strings.stream().map(ZookeeperUtils::parseAddress).collect(Collectors.toList());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 字符串解析为地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InetSocketAddress <span class="hljs-title function_">parseAddress</span><span class="hljs-params">(String address)</span> &#123;<br>        String[] result = address.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(result[<span class="hljs-number">0</span>], Integer.parseInt(result[<span class="hljs-number">1</span>]));<br>    &#125;<br><br>    <span class="hljs-comment">//地址解析为字符串</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getServiceAddress</span><span class="hljs-params">(InetSocketAddress serverAddress)</span> &#123;<br>        <span class="hljs-keyword">return</span> serverAddress.getHostName() +<br>                <span class="hljs-string">&quot;:&quot;</span> +<br>                serverAddress.getPort();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Zookeeper服务注册实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Zookeeper服务注册实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServerRegistry</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务注册</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serviceName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inetSocketAddress</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String serviceName, InetSocketAddress inetSocketAddress)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ZookeeperUtils.registerServer(serviceName, inetSocketAddress);<br>            System.out.println(serviceName + <span class="hljs-string">&quot;注册成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;注册Zookeeper出现异常&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Zookeeper服务发现实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Zookeeper服务发现实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperDiscovery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServerDiscovery</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoadBalancer loadBalancer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZookeeperDiscovery</span><span class="hljs-params">(LoadBalancer loadBalancer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loadBalancer = loadBalancer;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title function_">getService</span><span class="hljs-params">(String serviceName)</span> &#123;<br>        List&lt;InetSocketAddress&gt; instances = ZookeeperUtils.getAllInstance(serviceName);<br>        <span class="hljs-keyword">return</span> loadBalancer.getInstance(instances);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-负载均衡"><a href="#7-负载均衡" class="headerlink" title="7. 负载均衡"></a>7. 负载均衡</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 负载均衡算法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoadBalancer</span> &#123;<br>    InetSocketAddress <span class="hljs-title function_">getInstance</span><span class="hljs-params">(List&lt;InetSocketAddress&gt; list)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 负载均衡随机算法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomRule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancer</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Random random=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 随机获取实例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title function_">getInstance</span><span class="hljs-params">(List&lt;InetSocketAddress&gt; list)</span> &#123;<br>        <span class="hljs-keyword">return</span> list.get(random.nextInt(list.size()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 轮询负载均衡算法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundRobinRule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 防止Integer越界 超过Integer最大值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> current;<br>        <span class="hljs-type">int</span> next;<br>        <span class="hljs-keyword">do</span> &#123;<br>            current = <span class="hljs-built_in">this</span>.atomicInteger.get();<br>            next = current &gt;= <span class="hljs-number">2147483647</span> ? <span class="hljs-number">0</span> : current + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.atomicInteger.compareAndSet(current, next));<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 轮询获取实例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title function_">getInstance</span><span class="hljs-params">(List&lt;InetSocketAddress&gt; list)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> getAndIncrement() % list.size();<br>        <span class="hljs-keyword">return</span> list.get(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、高并发测试"><a href="#三、高并发测试" class="headerlink" title="三、高并发测试"></a>三、高并发测试</h2><p><strong>测试接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculate</span> &#123;<br>    <span class="hljs-comment">//两数相加</span><br>    Integer <span class="hljs-title function_">add</span><span class="hljs-params">(Integer a, Integer b)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RpcServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculateImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Calculate</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">add</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalcParallelRequestThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch signal;<br>    <span class="hljs-keyword">private</span> CountDownLatch finish;<br>    <span class="hljs-keyword">private</span> ClientProxy clientProxy;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CalcParallelRequestThread</span><span class="hljs-params">(ClientProxy clientProxy, CountDownLatch signal, CountDownLatch finish, <span class="hljs-type">int</span> taskNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.signal = signal;<br>        <span class="hljs-built_in">this</span>.finish = finish;<br>        <span class="hljs-built_in">this</span>.taskNumber = taskNumber;<br>        <span class="hljs-built_in">this</span>.clientProxy = clientProxy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            signal.await();<br><br>            <span class="hljs-type">Calculate</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> clientProxy.getProxyService(CalculateImpl.class);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> calc.add(taskNumber, taskNumber);<br>                System.out.println(<span class="hljs-string">&quot;calc add result:[&quot;</span> + add + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>            finish.countDown();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,CalcParallelRequestThread.class.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcParallelTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ClientProxy</span> <span class="hljs-variable">clientProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcClientManager</span>());<br>        <span class="hljs-comment">//并行度10000</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parallel</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br><br>        <span class="hljs-comment">//开始计时</span><br>        <span class="hljs-type">StopWatch</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>        sw.start();<br><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">signal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">finish</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(parallel);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; parallel; index++) &#123;<br>            <span class="hljs-type">CalcParallelRequestThread</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CalcParallelRequestThread</span>(clientProxy, signal, finish, index);<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(client).start();<br>        &#125;<br><br>        <span class="hljs-comment">//10000个并发线程瞬间发起请求操作</span><br>        signal.countDown();<br>        finish.await();<br><br>        sw.stop();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">tip</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;RPC调用总共耗时: [%s] 毫秒&quot;</span>, sw.getTime());<br>        System.out.println(tip);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试环境</strong></p><ul><li>Nacos注册中心，使用Zookeeper的话速度会慢很多</li><li>Java序列化算法</li><li>10000个线程</li></ul><p><strong>测试结果</strong></p><img src="/2021/07/25/Netty-%E6%89%8B%E5%86%99RPC/image-20210725184758931.png" class="" title="image-20210725184758931"><p>还需要确认一万条消息都顺利发送并接收到结果，可以通过sequenceId来确认，因为sequenceId是使用原子类进行自增的，所以在单机环境下，一定是线程安全的</p><p><strong>客户端</strong></p><img src="/2021/07/25/Netty-%E6%89%8B%E5%86%99RPC/image-20210725184928125.png" class="" title="image-20210725184928125"><p><strong>服务端</strong></p><img src="/2021/07/25/Netty-%E6%89%8B%E5%86%99RPC/image-20210725185018075.png" class="" title="image-20210725185018075">]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-应用</title>
    <link href="/2021/07/24/Netty-%E5%BA%94%E7%94%A8/"/>
    <url>/2021/07/24/Netty-%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty-应用"><a href="#Netty-应用" class="headerlink" title="Netty-应用"></a>Netty-应用</h1><h2 id="一、粘包与半包"><a href="#一、粘包与半包" class="headerlink" title="一、粘包与半包"></a>一、粘包与半包</h2><h3 id="1-粘包现象"><a href="#1-粘包现象" class="headerlink" title="1. 粘包现象"></a>1. 粘包现象</h3><p>服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldServer</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloWorldServer.class);<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            log.debug(<span class="hljs-string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-built_in">super</span>.channelActive(ctx);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            log.debug(<span class="hljs-string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-built_in">super</span>.channelInactive(ctx);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">8080</span>);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());<br>            channelFuture.sync();<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>            log.debug(<span class="hljs-string">&quot;stoped&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorldServer</span>().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldClient</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    log.debug(<span class="hljs-string">&quot;connetted...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>                                buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]<br>                                                  &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>                                ctx.writeAndFlush(buffer);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器输出结果</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tap">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...<br>08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000010|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000020|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000030|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000040|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000050|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000060|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000070|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000080|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000090|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br>08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE<br></code></pre></td></tr></table></figure><p>虽然客户端是分10次发送，每次16字节的数据，但是服务端一次性接收了160字节的数据，这就是<strong>粘包现象</strong></p><h3 id="2-半包现象"><a href="#2-半包现象" class="headerlink" title="2. 半包现象"></a>2. 半包现象</h3><p>客户端代码，一次性发出160字节的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>&#125;<br>ctx.writeAndFlush(buffer);<br></code></pre></td></tr></table></figure><p>服务端代码，修改客户端-服务端之间的<code>channel</code>容量,影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 Netty 读取的最小单位，Netty 实际每次读取的一般是它的整数倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>服务端输出</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs tap">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...<br>08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...<br>08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED<br>08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE<br>08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]<br>08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000010|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br>08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE<br>08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000010|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000020|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000030|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000040|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000050|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000060|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000070|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03 |................|<br>|00000080|<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f             |............    |<br>+--------+-------------------------------------------------+----------------+<br>08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE<br></code></pre></td></tr></table></figure><p>可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节，这就是<strong>半包现象</strong></p><h3 id="3-现象分析"><a href="#3-现象分析" class="headerlink" title="3. 现象分析"></a>3. 现象分析</h3><p>粘包</p><ul><li>现象，发送 abc def，接收 abcdef</li><li>原因<ul><li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul><p>半包</p><ul><li>现象，发送 abcdef，接收 abc def</li><li>原因<ul><li>应用层：接收方 ByteBuf 小于实际发送数据量</li><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul><p><strong>本质是因为 TCP 是流式协议，消息无边界</strong></p><h3 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h3><h4 id="4-1-定长解码器"><a href="#4-1-定长解码器" class="headerlink" title="4.1 定长解码器"></a>4.1 定长解码器</h4><p>客户端和服务端<strong>约定一个长度</strong>，保证客户端每次发送的数据都不会大于该长度，并且当数据小于约定长度时，<strong>自动补齐至该长度</strong></p><p>服务器接收数据时，将数剧<strong>按照约定的长度进行拆分</strong>，即便发生了粘包，也可以通过长度正确拆分出数据</p><p><strong>服务端</strong>使用Netty实现的<code>FixedLengthFrameDecoder</code>进行解码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设约定长度为8，每次都以8为单位读取数据</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedLengthFrameDecoder</span>(<span class="hljs-number">8</span>));<br></code></pre></td></tr></table></figure><p>客户端可以在任意时刻发送数，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldClient</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    log.debug(<span class="hljs-string">&quot;connetted...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            <span class="hljs-comment">// 发送内容随机的数据包</span><br>                            <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>                            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>                                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; r.nextInt(<span class="hljs-number">8</span>); j++) &#123;<br>                                    bytes[j] = (<span class="hljs-type">byte</span>) c;<br>                                &#125;<br>                                c++;<br>                                buffer.writeBytes(bytes);<br>                            &#125;<br>                            ctx.writeAndFlush(buffer);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端输出</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tap">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 61 </span>61<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 62 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |aaaa....b.......|<br>|00000010|<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 64 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |cc......d.......|<br>|00000020|<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 66 </span>66<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |........ffff....|<br>|00000030|<span class="hljs-number"> 67 </span>67<span class="hljs-number"> 67 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 68 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |ggg.....h.......|<br>|00000040|<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>00<span class="hljs-number"> 00 </span>00 6a 6a 6a 6a<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 |iiiii...jjjj....|<br>+--------+-------------------------------------------------+----------------+<br>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH<br></code></pre></td></tr></table></figure><p>服务端输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...<br>12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...<br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED<br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE<br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]<br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>......<br></code></pre></td></tr></table></figure><p>缺点是长度不好控制</p><ul><li>长度定的太大，资源浪费</li><li>长度定的太小，对某些大的数据包又显得不够</li></ul><h4 id="4-2-行解码器"><a href="#4-2-行解码器" class="headerlink" title="4.2 行解码器"></a>4.2 行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>在服务端中使用<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LineBasedFrameDecoder</span>(<span class="hljs-number">1024</span>));<br></code></pre></td></tr></table></figure><p>客户端在每条消息之后，加入 \n 分隔符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldClient</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    log.debug(<span class="hljs-string">&quot;connetted...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>                            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>                            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= r.nextInt(<span class="hljs-number">16</span>)+<span class="hljs-number">1</span>; j++) &#123;<br>                                    buffer.writeByte((<span class="hljs-type">byte</span>) c);<br>                                &#125;<br>                                <span class="hljs-comment">//表示\n</span><br>                                buffer.writeByte(<span class="hljs-number">10</span>);<br>                                c++;<br>                            &#125;<br>                            ctx.writeAndFlush(buffer);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;192.168.0.103&quot;</span>, <span class="hljs-number">9090</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端输出</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 61 </span>0a<span class="hljs-number"> 62 </span>62<span class="hljs-number"> 62 </span>0a<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 63 </span>0a<span class="hljs-number"> 64 </span>64 0a<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>|a.bbb.ccc.dd.eee|<br>|00000010|<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 65 </span>0a<span class="hljs-number"> 66 </span>66 0a<span class="hljs-number"> 67 </span>67<span class="hljs-number"> 67 </span>67<span class="hljs-number"> 67 </span>|eeeeeee.ff.ggggg|<br>|00000020|<span class="hljs-number"> 67 </span>67 0a<span class="hljs-number"> 68 </span>68<span class="hljs-number"> 68 </span>68 0a<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>69<span class="hljs-number"> 69 </span>0a |gg.hhhh.iiiiiii.|<br>|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |<br>+--------+-------------------------------------------------+----------------+<br>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH<br></code></pre></td></tr></table></figure><p>服务端输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] c.i.n.HelloWorldServer - connected [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>]<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 1B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span>                                              |a               |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 3B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">62</span> <span class="hljs-number">62</span> <span class="hljs-number">62</span>                                        |bbb             |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 3B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">63</span> <span class="hljs-number">63</span> <span class="hljs-number">63</span>                                        |ccc             |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 2B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">64</span> <span class="hljs-number">64</span>                                           |dd              |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 10B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">65</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span> <span class="hljs-number">65</span>                   |eeeeeeeeee      |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 2B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">66</span> <span class="hljs-number">66</span>                                           |ff              |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 7B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">67</span> <span class="hljs-number">67</span> <span class="hljs-number">67</span> <span class="hljs-number">67</span> <span class="hljs-number">67</span> <span class="hljs-number">67</span> <span class="hljs-number">67</span>                            |ggggggg         |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 4B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">68</span> <span class="hljs-number">68</span> <span class="hljs-number">68</span> <span class="hljs-number">68</span>                                     |hhhh            |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 7B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">69</span> <span class="hljs-number">69</span> <span class="hljs-number">69</span> <span class="hljs-number">69</span> <span class="hljs-number">69</span> <span class="hljs-number">69</span> <span class="hljs-number">69</span>                            |iiiiiii         |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ: 11B<br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">14</span>:08:<span class="hljs-number">18</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="hljs-number">0xa4b3be43</span>, L:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">9090</span> - R:/<span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.103</span>:<span class="hljs-number">63641</span>] READ COMPLETE<br></code></pre></td></tr></table></figure><p>缺点，处理字符数据比较合适，但如果内容<strong>本身包含了分隔符</strong>（字节数据常常会有此情况），那么就会解析错误</p><h4 id="4-3-长度字段解码器"><a href="#4-3-长度字段解码器" class="headerlink" title="4.3 长度字段解码器"></a>4.3 长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(</span><br><span class="hljs-params">    //表示数据的最大长度</span><br><span class="hljs-params">    <span class="hljs-type">int</span> maxFrameLength,</span><br><span class="hljs-params">    //数据长度标识的起始偏移量，指明数据第几个字节开始是用于标识有用字节长度的</span><br><span class="hljs-params">    <span class="hljs-type">int</span> lengthFieldOffset, </span><br><span class="hljs-params">    //数据长度标识所占字节数，指明有用数据的长度</span><br><span class="hljs-params">    <span class="hljs-type">int</span> lengthFieldLength,</span><br><span class="hljs-params">    //长度表示与有用数据的偏移量</span><br><span class="hljs-params">    <span class="hljs-type">int</span> lengthAdjustment, </span><br><span class="hljs-params">    //数据读取起点</span><br><span class="hljs-params">    <span class="hljs-type">int</span> initialBytesToStrip)</span><br></code></pre></td></tr></table></figure><p>参数图解</p><img src="/2021/07/24/Netty-%E5%BA%94%E7%94%A8/image-20210724153814246.png" class="" title="image-20210724153814246"><h2 id="二、协议设计与解析"><a href="#二、协议设计与解析" class="headerlink" title="二、协议设计与解析"></a>二、协议设计与解析</h2><h3 id="1-协议的作用"><a href="#1-协议的作用" class="headerlink" title="1. 协议的作用"></a>1. 协议的作用</h3><p>TCP&#x2F;IP 中消息传输<strong>基于流的方式</strong>，没有边界。</p><p>协议的目的就是<strong>划定消息的边界</strong>，制定通信双方要<strong>共同遵守的通信规则</strong></p><h3 id="2-Redis协议"><a href="#2-Redis协议" class="headerlink" title="2. Redis协议"></a>2. Redis协议</h3><p>Redis客户端使用RESP（Redis的序列化协议）协议与Redis的服务器端进行通信。</p><p>如果我们要向Redis服务器发送一条<code>set name dongys</code>的指令，需要遵守如下协议</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 该指令一共有<span class="hljs-number">3</span>部分，每条指令之后都要添加回车与换行符<br>*<span class="hljs-number">3</span>\r\n<br><span class="hljs-regexp">//</span> 第一个指令的长度是<span class="hljs-number">3</span><br><span class="hljs-variable">$3</span>\r\n<br><span class="hljs-regexp">//</span> 第一个指令是set指令<br>set\r\n<br><span class="hljs-regexp">//</span> 下面的指令以此类推<br><span class="hljs-variable">$4</span>\r\n<br>name\r\n<br><span class="hljs-variable">$6</span>\r\n<br>dongys\r\n<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRedis</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] LINE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">13</span>, <span class="hljs-number">10</span>&#125;;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>                            buf.writeBytes(<span class="hljs-string">&quot;*3&quot;</span>.getBytes());<br>                            buf.writeBytes(LINE);<br>                            buf.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                            buf.writeBytes(LINE);<br>                            buf.writeBytes(<span class="hljs-string">&quot;set&quot;</span>.getBytes());<br>                            buf.writeBytes(LINE);<br>                            buf.writeBytes(<span class="hljs-string">&quot;$4&quot;</span>.getBytes());<br>                            buf.writeBytes(LINE);<br>                            buf.writeBytes(<span class="hljs-string">&quot;name&quot;</span>.getBytes());<br>                            buf.writeBytes(LINE);<br>                            buf.writeBytes(<span class="hljs-string">&quot;$6&quot;</span>.getBytes());<br>                            buf.writeBytes(LINE);<br>                            buf.writeBytes(<span class="hljs-string">&quot;dongys&quot;</span>.getBytes());<br>                            buf.writeBytes(LINE);<br>                            ctx.writeAndFlush(buf);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                            System.out.println(buf.toString(Charset.defaultCharset()));<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端输出结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">15:43:16 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x84a7cfdb] REGISTERED<br>15:43:16 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x84a7cfdb] CONNECT: localhost/127.0.0.1:6379<br>15:43:16 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x84a7cfdb, L:/127.0.0.1:7338 - R:localhost/127.0.0.1:6379] ACTIVE<br>15:43:16 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x84a7cfdb, L:/127.0.0.1:7338 - R:localhost/127.0.0.1:6379] WRITE: 35B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|<br>|00000010| 0a 6e 61 6d 65 0d 0a 24 36 0d 0a 64 6f 6e 67 79 |.name..$6..dongy|<br><span class="hljs-section">|00000020| 73 0d 0a                                        |s..             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>15:43:16 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x84a7cfdb, L:/127.0.0.1:7338 - R:localhost/127.0.0.1:6379] FLUSH<br>15:43:16 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x84a7cfdb, L:/127.0.0.1:7338 - R:localhost/127.0.0.1:6379] READ: 5B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 2b 4f 4b 0d 0a                                  |+OK..           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>+OK<br><br>15:43:16 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x84a7cfdb, L:/127.0.0.1:7338 - R:localhost/127.0.0.1:6379] READ COMPLETE<br></code></pre></td></tr></table></figure><p>Redis服务器接收到数据后返回给客户端OK，在Redis客户端查询数据</p><img src="/2021/07/24/Netty-%E5%BA%94%E7%94%A8/image-20210724154626096.png" class="" title="image-20210724154626096"><h3 id="3-Http协议"><a href="#3-Http协议" class="headerlink" title="3.  Http协议"></a>3.  Http协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestHttp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpRequest msg)</span> &#123;<br>                            <span class="hljs-comment">//获取请求</span><br>                            log.debug(msg.uri());<br>                            <span class="hljs-comment">//返回响应</span><br>                            <span class="hljs-type">DefaultFullHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);<br>                            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;Hello,world!&lt;/h1&gt;&quot;</span>.getBytes();<br>                            response.headers().setInt(CONTENT_LENGTH, bytes.length);<br>                            response.content().writeBytes(bytes);<br>                            <span class="hljs-comment">//写回响应</span><br>                            ctx.writeAndFlush(response);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">8081</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><p>运行结果</p><img src="/2021/07/24/Netty-%E5%BA%94%E7%94%A8/image-20210724155719571.png" class="" title="image-20210724155719571"><p>客户端输出</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tap">//请求内容<br>15:53:33 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x40093533, L:/0:0:0:0:0:0:0:1:8081 - R:/0:0:0:0:0:0:0:1:7903] READ: 1024B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 47 </span>45<span class="hljs-number"> 54 </span>20 2f<span class="hljs-number"> 20 </span>48<span class="hljs-number"> 54 </span>54<span class="hljs-number"> 50 </span>2f<span class="hljs-number"> 31 </span>2e<span class="hljs-number"> 31 </span>0d 0a |GET / HTTP/1.1..|<br>|00000010|<span class="hljs-number"> 48 </span>6f<span class="hljs-number"> 73 </span>74 3a<span class="hljs-number"> 20 </span>6c 6f<span class="hljs-number"> 63 </span>61 6c<span class="hljs-number"> 68 </span>6f<span class="hljs-number"> 73 </span>74 3a |Host: localhost:|<br>|00000020|<span class="hljs-number"> 38 </span>30<span class="hljs-number"> 38 </span>31 0d 0a<span class="hljs-number"> 43 </span>6f 6e 6e<span class="hljs-number"> 65 </span>63<span class="hljs-number"> 74 </span>69 6f 6e |8081..Connection|<br>|00000030| 3a<span class="hljs-number"> 20 </span>6b<span class="hljs-number"> 65 </span>65<span class="hljs-number"> 70 </span>2d<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 69 </span>76<span class="hljs-number"> 65 </span>0d 0a<span class="hljs-number"> 73 </span>65 |: keep-alive..se|<br>....<br>//响应内容<br>15:53:33 [DEBUG] [nioEventLoopGroup-3-1] c.d.a.c2.TestHttp - /<br>15:53:33 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x40093533, L:/0:0:0:0:0:0:0:1:8081 - R:/0:0:0:0:0:0:0:1:7903] WRITE: 60B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 48 </span>54<span class="hljs-number"> 54 </span>50 2f<span class="hljs-number"> 31 </span>2e<span class="hljs-number"> 31 </span>20<span class="hljs-number"> 32 </span>30<span class="hljs-number"> 30 </span>20 4f 4b 0d |HTTP/1.1<span class="hljs-number"> 200 </span>OK.|<br>|00000010| 0a<span class="hljs-number"> 63 </span>6f 6e<span class="hljs-number"> 74 </span>65 6e<span class="hljs-number"> 74 </span>2d 6c<span class="hljs-number"> 65 </span>6e<span class="hljs-number"> 67 </span>74<span class="hljs-number"> 68 </span>3a |.content-length:|<br>|00000020|<span class="hljs-number"> 20 </span>32<span class="hljs-number"> 31 </span>0d 0a 0d 0a 3c<span class="hljs-number"> 68 </span>31 3e<span class="hljs-number"> 48 </span>65 6c 6c 6f | 21....&lt;h1&gt;Hello|<br>|00000030| 2c<span class="hljs-number"> 77 </span>6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>21 3c 2f<span class="hljs-number"> 68 </span>31 3e             |,world!&lt;/h1&gt;    |<br>+--------+-------------------------------------------------+----------------+<br>15:53:33 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x40093533, L:/0:0:0:0:0:0:0:1:8081 - R:/0:0:0:0:0:0:0:1:7903] FLUSH<br></code></pre></td></tr></table></figure><h3 id="4-自定义协议"><a href="#4-自定义协议" class="headerlink" title="4. 自定义协议"></a>4. 自定义协议</h3><h4 id="4-1-组成要素"><a href="#4-1-组成要素" class="headerlink" title="4.1 组成要素"></a>4.1 组成要素</h4><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><h4 id="4-2-编解码器"><a href="#4-2-编解码器" class="headerlink" title="4.2 编解码器"></a>4.2 编解码器</h4><p>根据上述要素，设计一个编解码器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 4 字节的魔数</span><br>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        <span class="hljs-comment">// 2. 1 字节的版本,</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span><br>        out.writeByte(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 4. 1 字节的指令类型</span><br>        out.writeByte(msg.getMessageType());<br>        <span class="hljs-comment">// 5. 4 个字节</span><br>        out.writeInt(msg.getSequenceId());<br>        <span class="hljs-comment">// 无意义，对齐填充</span><br>        out.writeByte(<span class="hljs-number">0xff</span>);<br>        <span class="hljs-comment">// 6. 获取内容的字节数组</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(msg);<br>        <span class="hljs-type">byte</span>[] bytes = bos.toByteArray();<br>        <span class="hljs-comment">// 7. 长度</span><br>        out.writeInt(bytes.length);<br>        <span class="hljs-comment">// 8. 写入内容</span><br>        out.writeBytes(bytes);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">magicNum</span> <span class="hljs-operator">=</span> in.readInt();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> in.readByte();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">serializerType</span> <span class="hljs-operator">=</span> in.readByte();<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">messageType</span> <span class="hljs-operator">=</span> in.readByte();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sequenceId</span> <span class="hljs-operator">=</span> in.readInt();<br>        in.readByte();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> in.readInt();<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>        in.readBytes(bytes, <span class="hljs-number">0</span>, length);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes));<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) ois.readObject();<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, message);<br>        out.add(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>编码器与解码器方法源于<strong>父类<code>ByteToMessageCodec</code>，通过该类可以自定义编码器与解码器，</strong>泛型类型为被编码与被解码的类。此处使用了自定义类Message，代表消息</p></li><li><p>编码器负责将附加信息与正文信息写入到<code>ByteBuf</code>中，其中附加信息<strong>总字节数最好为2^n</strong>，不足需要补齐<strong>。</strong>正文内容如果为对象，需要通过序列化将其放入到<code>ByteBuf</code>中</p></li><li><p>解码器<strong>负责将<code>ByteBuf</code>中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p></li></ul><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EmbeddedChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbeddedChannel</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthFieldBasedFrameDecoder</span>(<br>        <span class="hljs-number">1024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageCodec</span>()<br>);<br><span class="hljs-comment">// encode</span><br><span class="hljs-type">LoginRequestMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginRequestMessage</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br><span class="hljs-comment">//        channel.writeOutbound(message);</span><br><span class="hljs-comment">// decode</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageCodec</span>().encode(<span class="hljs-literal">null</span>, message, buf);<br><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> buf.slice(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> buf.slice(<span class="hljs-number">100</span>, buf.readableBytes() - <span class="hljs-number">100</span>);<br>s1.retain(); <span class="hljs-comment">// 引用计数 2</span><br>channel.writeInbound(s1); <span class="hljs-comment">// release 1</span><br>channel.writeInbound(s2);<br></code></pre></td></tr></table></figure><p>协议解读</p><img src="/2021/07/24/Netty-%E5%BA%94%E7%94%A8/0013-1627114269862.png" class="" width="0013"><h4 id="4-3-Sharable注解"><a href="#4-3-Sharable注解" class="headerlink" title="4.3 @Sharable注解"></a>4.3 @Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">loggingHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br><span class="hljs-comment">// 不同的channel中使用同一个handler对象，提高复用率</span><br>channel1.pipeline().addLast(loggingHandler);<br>channel2.pipeline().addLast(loggingHandler);<br></code></pre></td></tr></table></figure><p>但是并不是所有的handler都能通过这种方法来提高复用率的，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个<code>LengthFieldBasedFrameDecoder</code>对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，<code>LengthFieldBasedFrameDecoder</code>发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，因为两个channel使用了同一个<code>LengthFieldBasedFrameDecoder</code>，存入其中的数据刚好拼凑成了一个完整的数据包。<code>LengthFieldBasedFrameDecoder</code>让该数据包继续向下传播，最终引发错误</li></ul><p>为了提高handler的复用率，同时又避免出现一些并发问题，Netty中原生的handler中用@Sharable注解来标明，该handler能否在多个channel中共享。</p><p>只有带有该注解，才能通过对象的方式被共享，否则无法被共享</p><h4 id="Sharable的使用时机"><a href="#Sharable的使用时机" class="headerlink" title="@Sharable的使用时机"></a>@Sharable的使用时机</h4><ul><li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li><li>但要注意对于编解码器类，不能继承 <code>ByteToMessageCodec </code>或 <code>CombinedChannelDuplexHandler </code>父类，他们的构造方法对 @Sharable 有限制</li><li>如果能确保编解码器不会保存状态，可以继承 <code>MessageToMessageCodec </code>父类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-comment">//必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageSharableCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、在线聊天室"><a href="#三、在线聊天室" class="headerlink" title="三、在线聊天室"></a>三、在线聊天室</h2><h3 id="1-聊天室业务"><a href="#1-聊天室业务" class="headerlink" title="1. 聊天室业务"></a>1. 聊天室业务</h3><p><strong>用户登录接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 登录成功返回 true, 否则返回 false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username, String password)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>会话管理接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Session</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 会话绑定用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Channel channel, String username)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要解绑会话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unbind</span><span class="hljs-params">(Channel channel)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性值</span><br><span class="hljs-comment">     */</span><br>    Object <span class="hljs-title function_">getAttribute</span><span class="hljs-params">(Channel channel, String name)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttribute</span><span class="hljs-params">(Channel channel, String name, Object value)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名获取 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> channel</span><br><span class="hljs-comment">     */</span><br>    Channel <span class="hljs-title function_">getChannel</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>群聊管理接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GroupSession</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> members 成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功时返回组对象, 失败返回 null</span><br><span class="hljs-comment">     */</span><br>    Group <span class="hljs-title function_">createGroup</span><span class="hljs-params">(String name, Set&lt;String&gt; members)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group <span class="hljs-title function_">joinMember</span><span class="hljs-params">(String name, String member)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group <span class="hljs-title function_">removeMember</span><span class="hljs-params">(String name, String member)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group <span class="hljs-title function_">removeGroup</span><span class="hljs-params">(String name)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员集合, 没有成员会返回 empty set</span><br><span class="hljs-comment">     */</span><br>    Set&lt;String&gt; <span class="hljs-title function_">getMembers</span><span class="hljs-params">(String name)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员 channel 集合</span><br><span class="hljs-comment">     */</span><br>    List&lt;Channel&gt; <span class="hljs-title function_">getMembersChannel</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-登录"><a href="#2-登录" class="headerlink" title="2.  登录"></a>2.  登录</h3><p><strong>服务端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">LOGGING_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br>        <span class="hljs-type">MessageCodecSharable</span> <span class="hljs-variable">MESSAGE_CODEC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageCodecSharable</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcotolFrameDecoder</span>());<br>                    ch.pipeline().addLast(LOGGING_HANDLER);<br>                    ch.pipeline().addLast(MESSAGE_CODEC);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> msg.getUsername();<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> msg.getPassword();<br>                            <span class="hljs-type">boolean</span> <span class="hljs-variable">login</span> <span class="hljs-operator">=</span> UserServiceFactory.getUserService().login(username, password);<br>                            LoginResponseMessage message;<br>                            <span class="hljs-keyword">if</span>(login) &#123;<br>                                message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginResponseMessage</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;登录成功&quot;</span>);<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;用户名或密码不正确&quot;</span>);<br>                            &#125;<br>                            ctx.writeAndFlush(message);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">LOGGING_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br>        <span class="hljs-type">MessageCodecSharable</span> <span class="hljs-variable">MESSAGE_CODEC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageCodecSharable</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">WAIT_FOR_LOGIN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">LOGIN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(group);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcotolFrameDecoder</span>());<br><span class="hljs-comment">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br>                    ch.pipeline().addLast(MESSAGE_CODEC);<br>                    ch.pipeline().addLast(<span class="hljs-string">&quot;client handler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-comment">// 接收响应消息</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            log.debug(<span class="hljs-string">&quot;msg: &#123;&#125;&quot;</span>, msg);<br>                            <span class="hljs-keyword">if</span> ((msg <span class="hljs-keyword">instanceof</span> LoginResponseMessage)) &#123;<br>                                <span class="hljs-type">LoginResponseMessage</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (LoginResponseMessage) msg;<br>                                <span class="hljs-keyword">if</span> (response.isSuccess()) &#123;<br>                                    <span class="hljs-comment">// 如果登录成功</span><br>                                    LOGIN.set(<span class="hljs-literal">true</span>);<br>                                &#125;<br>                                <span class="hljs-comment">// 唤醒 system in 线程</span><br>                                WAIT_FOR_LOGIN.countDown();<br>                            &#125;<br>                        &#125;<br><br>                        <span class="hljs-comment">// 在连接建立后触发 active 事件</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span><br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                                <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>                                System.out.println(<span class="hljs-string">&quot;请输入用户名:&quot;</span>);<br>                                <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>                                System.out.println(<span class="hljs-string">&quot;请输入密码:&quot;</span>);<br>                                <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>                                <span class="hljs-comment">// 构造消息对象</span><br>                                <span class="hljs-type">LoginRequestMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginRequestMessage</span>(username, password);<br>                                <span class="hljs-comment">// 发送消息</span><br>                                ctx.writeAndFlush(message);<br>                                System.out.println(<span class="hljs-string">&quot;等待后续操作...&quot;</span>);<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    WAIT_FOR_LOGIN.await();<br>                                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                                    e.printStackTrace();<br>                                &#125;<br>                                <span class="hljs-comment">// 如果登录失败</span><br>                                <span class="hljs-keyword">if</span> (!LOGIN.get()) &#123;<br>                                    ctx.channel().close();<br>                                    <span class="hljs-keyword">return</span>;<br>                                &#125;<br>                                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                                    System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;send [username] [content]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gsend [group name] [content]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gmembers [group name]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gjoin [group name]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;gquit [group name]&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;quit&quot;</span>);<br>                                    System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                                    <span class="hljs-type">String</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>                                    String[] s = command.split(<span class="hljs-string">&quot; &quot;</span>);<br>                                    <span class="hljs-keyword">switch</span> (s[<span class="hljs-number">0</span>])&#123;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;send&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRequestMessage</span>(username, s[<span class="hljs-number">1</span>], s[<span class="hljs-number">2</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gsend&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatRequestMessage</span>(username, s[<span class="hljs-number">1</span>], s[<span class="hljs-number">2</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gcreate&quot;</span>:<br>                                            Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(s[<span class="hljs-number">2</span>].split(<span class="hljs-string">&quot;,&quot;</span>)));<br>                                            set.add(username); <span class="hljs-comment">// 加入自己</span><br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateRequestMessage</span>(s[<span class="hljs-number">1</span>], set));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gmembers&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupMembersRequestMessage</span>(s[<span class="hljs-number">1</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gjoin&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupJoinRequestMessage</span>(username, s[<span class="hljs-number">1</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gquit&quot;</span>:<br>                                            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupQuitRequestMessage</span>(username, s[<span class="hljs-number">1</span>]));<br>                                            <span class="hljs-keyword">break</span>;<br>                                        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br>                                            ctx.channel().close();<br>                                            <span class="hljs-keyword">return</span>;<br>                                    &#125;<br>                                &#125;<br>                            &#125;, <span class="hljs-string">&quot;system in&quot;</span>).start();<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><strong>客户端</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">请输入用户名:<br>zhangsan<br>请输入密码:<br>123<br>等待后续操作<span class="hljs-built_in">..</span>.<br>19:08:16 [<span class="hljs-built_in">DEBUG</span>] [nioEventLoopGroup-2-1] c.d.c.ChatClient - msg: LoginResponseMessage(<span class="hljs-attribute">super</span>=AbstractResponseMessage(super=Message(sequenceId=0, <span class="hljs-attribute">messageType</span>=1), <span class="hljs-attribute">success</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">reason</span>=登录成功))<br></code></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tap">19:08:11 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xcf73b3df, L:/127.0.0.1:8080 - R:/127.0.0.1:11898] REGISTERED<br>19:08:11 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xcf73b3df, L:/127.0.0.1:8080 - R:/127.0.0.1:11898] ACTIVE<br>19:08:15 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xcf73b3df, L:/127.0.0.1:8080 - R:/127.0.0.1:11898] READ: 109B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 64 </span>6f 6e<span class="hljs-number"> 67 </span>01<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>5d |dong...........]|<br>|00000010| 7b<span class="hljs-number"> 22 </span>75<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 72 </span>6e<span class="hljs-number"> 61 </span>6d<span class="hljs-number"> 65 </span>22 3a<span class="hljs-number"> 22 </span>7a<span class="hljs-number"> 68 </span>61 |&#123;&quot;username&quot;:&quot;zha|<br>|00000020| 6e<span class="hljs-number"> 67 </span>73<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 22 </span>2c<span class="hljs-number"> 22 </span>70<span class="hljs-number"> 61 </span>73<span class="hljs-number"> 73 </span>77 6f<span class="hljs-number"> 72 </span>64 |ngsan&quot;,&quot;password|<br>|00000030|<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 22 </span>31<span class="hljs-number"> 32 </span>33<span class="hljs-number"> 22 </span>2c<span class="hljs-number"> 22 </span>6e<span class="hljs-number"> 69 </span>63 6b 6e<span class="hljs-number"> 61 </span>6d |&quot;:&quot;123&quot;,&quot;nicknam|<br>|00000040|<span class="hljs-number"> 65 </span>22 3a<span class="hljs-number"> 22 </span>7a<span class="hljs-number"> 68 </span>61 6e<span class="hljs-number"> 67 </span>73<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 22 </span>2c<span class="hljs-number"> 22 </span>73 |e&quot;:&quot;zhangsan&quot;,&quot;s|<br>|00000050|<span class="hljs-number"> 65 </span>71<span class="hljs-number"> 75 </span>65 6e<span class="hljs-number"> 63 </span>65<span class="hljs-number"> 49 </span>64<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 30 </span>2c<span class="hljs-number"> 22 </span>6d<span class="hljs-number"> 65 </span>|equenceId&quot;:0,&quot;me|<br>|00000060|<span class="hljs-number"> 73 </span>73<span class="hljs-number"> 61 </span>67<span class="hljs-number"> 65 </span>54<span class="hljs-number"> 79 </span>70<span class="hljs-number"> 65 </span>22 3a<span class="hljs-number"> 30 </span>7d          |ssageType&quot;:0&#125;   |<br>+--------+-------------------------------------------------+----------------+<br>19:08:15 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xcf73b3df, L:/127.0.0.1:8080 - R:/127.0.0.1:11898] WRITE: 87B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 64 </span>6f 6e<span class="hljs-number"> 67 </span>01<span class="hljs-number"> 01 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>47 |dong...........G|<br>|00000010| 7b<span class="hljs-number"> 22 </span>73<span class="hljs-number"> 75 </span>63<span class="hljs-number"> 63 </span>65<span class="hljs-number"> 73 </span>73<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 74 </span>72<span class="hljs-number"> 75 </span>65 2c |&#123;&quot;success&quot;:true,|<br>|00000020|<span class="hljs-number"> 22 </span>72<span class="hljs-number"> 65 </span>61<span class="hljs-number"> 73 </span>6f 6e<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 22 </span>e7<span class="hljs-number"> 99 </span>bb e5 bd<span class="hljs-number"> 95 </span>|&quot;reason&quot;:&quot;......|<br>|00000030| e6<span class="hljs-number"> 88 </span>90 e5 8a 9f<span class="hljs-number"> 22 </span>2c<span class="hljs-number"> 22 </span>73<span class="hljs-number"> 65 </span>71<span class="hljs-number"> 75 </span>65 6e<span class="hljs-number"> 63 </span>|......&quot;,&quot;sequenc|<br>|00000040|<span class="hljs-number"> 65 </span>49<span class="hljs-number"> 64 </span>22 3a<span class="hljs-number"> 30 </span>2c<span class="hljs-number"> 22 </span>6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65<span class="hljs-number"> 54 </span>|eId&quot;:0,&quot;messageT|<br>|00000050|<span class="hljs-number"> 79 </span>70<span class="hljs-number"> 65 </span>22 3a<span class="hljs-number"> 30 </span>7d                            |ype&quot;:0&#125;         |<br>+--------+-------------------------------------------------+----------------+<br>19:08:15 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xcf73b3df, L:/127.0.0.1:8080 - R:/127.0.0.1:11898] FLUSH<br>19:08:15 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xcf73b3df, L:/127.0.0.1:8080 - R:/127.0.0.1:11898] READ COMPLETE<br></code></pre></td></tr></table></figure><h3 id="3-单聊"><a href="#3-单聊" class="headerlink" title="3. 单聊"></a>3. 单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理<code>ChatRequestMessage</code>的handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;ChatRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> msg.getTo();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> SessionFactory.getSession().getChannel(to);<br>        <span class="hljs-comment">// 在线</span><br>        <span class="hljs-keyword">if</span>(channel != <span class="hljs-literal">null</span>) &#123;<br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatResponseMessage</span>(msg.getFrom(), msg.getContent()));<br>        &#125;<br>        <span class="hljs-comment">// 不在线</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;对方用户不存在或者不在线&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>登录zhangsan客户端和lisi客户端，并使用zhangsan客户端向lisi发送消息，lisi客户端接受结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">19:14:44 [<span class="hljs-built_in">DEBUG</span>] [nioEventLoopGroup-2-1] c.d.c.ChatClient - msg: ChatResponseMessage(<span class="hljs-attribute">super</span>=AbstractResponseMessage(super=Message(sequenceId=0, <span class="hljs-attribute">messageType</span>=3), <span class="hljs-attribute">success</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">reason</span>=<span class="hljs-literal">null</span>), <span class="hljs-attribute">from</span>=zhangsan, <span class="hljs-attribute">content</span>=hello)<br></code></pre></td></tr></table></figure><p>服务端输出，服务端首先收到zhangsan客户端发过来的消息，其中有<strong>发送方和接收方以及消息内容</strong>这三个重要信息，然后服务端再将消息发送给lisi客户端</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs tap">19:14:37 [DEBUG] [nioEventLoopGroup-3-2] i.n.h.l.LoggingHandler - [id: 0xb3d5f0b5, L:/127.0.0.1:8080 - R:/127.0.0.1:14720] READ COMPLETE<br>19:14:44 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x24e1182c, L:/127.0.0.1:8080 - R:/127.0.0.1:10266] READ: 96B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 64 </span>6f 6e<span class="hljs-number"> 67 </span>01<span class="hljs-number"> 01 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>50 |dong...........P|<br>|00000010| 7b<span class="hljs-number"> 22 </span>63 6f 6e<span class="hljs-number"> 74 </span>65 6e<span class="hljs-number"> 74 </span>22 3a<span class="hljs-number"> 22 </span>68<span class="hljs-number"> 65 </span>6c 6c |&#123;&quot;content&quot;:&quot;hell|<br>|00000020| 6f<span class="hljs-number"> 22 </span>2c<span class="hljs-number"> 22 </span>74 6f<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 22 </span>6c<span class="hljs-number"> 69 </span>73<span class="hljs-number"> 69 </span>22 2c<span class="hljs-number"> 22 </span>|o&quot;,&quot;to&quot;:&quot;lisi&quot;,&quot;|<br>|00000030|<span class="hljs-number"> 66 </span>72 6f 6d<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 22 </span>7a<span class="hljs-number"> 68 </span>61 6e<span class="hljs-number"> 67 </span>73<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 22 </span>|from&quot;:&quot;zhangsan&quot;|<br>|00000040| 2c<span class="hljs-number"> 22 </span>73<span class="hljs-number"> 65 </span>71<span class="hljs-number"> 75 </span>65 6e<span class="hljs-number"> 63 </span>65<span class="hljs-number"> 49 </span>64<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 30 </span>2c |,&quot;sequenceId&quot;:0,|<br>|00000050|<span class="hljs-number"> 22 </span>6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65<span class="hljs-number"> 54 </span>79<span class="hljs-number"> 70 </span>65<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 30 </span>7d |&quot;messageType&quot;:0&#125;|<br>+--------+-------------------------------------------------+----------------+<br>19:14:44 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x24e1182c, L:/127.0.0.1:8080 - R:/127.0.0.1:10266] READ COMPLETE<br>19:14:44 [DEBUG] [nioEventLoopGroup-3-2] i.n.h.l.LoggingHandler - [id: 0xb3d5f0b5, L:/127.0.0.1:8080 - R:/127.0.0.1:14720] WRITE: 100B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 64 </span>6f 6e<span class="hljs-number"> 67 </span>01<span class="hljs-number"> 01 </span>03<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>54 |dong...........T|<br>|00000010| 7b<span class="hljs-number"> 22 </span>66<span class="hljs-number"> 72 </span>6f 6d<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 22 </span>7a<span class="hljs-number"> 68 </span>61 6e<span class="hljs-number"> 67 </span>73<span class="hljs-number"> 61 </span>|&#123;&quot;from&quot;:&quot;zhangsa|<br>|00000020| 6e<span class="hljs-number"> 22 </span>2c<span class="hljs-number"> 22 </span>63 6f 6e<span class="hljs-number"> 74 </span>65 6e<span class="hljs-number"> 74 </span>22 3a<span class="hljs-number"> 22 </span>68<span class="hljs-number"> 65 </span>|n&quot;,&quot;content&quot;:&quot;he|<br>|00000030| 6c 6c 6f<span class="hljs-number"> 22 </span>2c<span class="hljs-number"> 22 </span>73<span class="hljs-number"> 75 </span>63<span class="hljs-number"> 63 </span>65<span class="hljs-number"> 73 </span>73<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 66 </span>|llo&quot;,&quot;success&quot;:f|<br>|00000040|<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 73 </span>65 2c<span class="hljs-number"> 22 </span>73<span class="hljs-number"> 65 </span>71<span class="hljs-number"> 75 </span>65 6e<span class="hljs-number"> 63 </span>65<span class="hljs-number"> 49 </span>64 |alse,&quot;sequenceId|<br>|00000050|<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 30 </span>2c<span class="hljs-number"> 22 </span>6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65<span class="hljs-number"> 54 </span>79<span class="hljs-number"> 70 </span>65 |&quot;:0,&quot;messageType|<br>|00000060|<span class="hljs-number"> 22 </span>3a<span class="hljs-number"> 30 </span>7d                                     |&quot;:0&#125;            |<br>+--------+-------------------------------------------------+----------------+<br>19:14:44 [DEBUG] [nioEventLoopGroup-3-2] i.n.h.l.LoggingHandler - [id: 0xb3d5f0b5, L:/127.0.0.1:8080 - R:/127.0.0.1:14720] FLUSH<br></code></pre></td></tr></table></figure><h3 id="4-群聊"><a href="#4-群聊" class="headerlink" title="4. 群聊"></a>4. 群聊</h3><h4 id="4-1-创建"><a href="#4-1-创建" class="headerlink" title="4.1 创建"></a>4.1 创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupCreateRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupCreateRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">groupName</span> <span class="hljs-operator">=</span> msg.getGroupName();<br>        Set&lt;String&gt; members = msg.getMembers();<br>        <span class="hljs-type">GroupSession</span> <span class="hljs-variable">groupSession</span> <span class="hljs-operator">=</span> GroupSessionFactory.getGroupSession();<br>        <span class="hljs-type">Group</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> groupSession.createGroup(groupName, members);<br>        <span class="hljs-keyword">if</span> (group == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//发送成功消息</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateResponseMessage</span>(<span class="hljs-literal">true</span>, groupName + <span class="hljs-string">&quot;创建成功&quot;</span>));<br>            <span class="hljs-comment">//发送拉群消息</span><br>            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);<br>            <span class="hljs-keyword">for</span> (Channel channel : channels) &#123;<br>                channel.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateResponseMessage</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;您已被拉入&quot;</span> + groupName));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateResponseMessage</span>(<span class="hljs-literal">false</span>, groupName + <span class="hljs-string">&quot;已经存在&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理创建群聊请求</span><br><span class="hljs-type">GroupCreateMessageHandler</span> <span class="hljs-variable">groupCreateMessageHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateMessageHandler</span>();<br>ch.pipeline().addLast(groupCreateMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>创建群聊，被拉入群聊的人都会收到一条message</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">gcreate group1 zhangsan lisi<br><span class="hljs-number">20</span>:<span class="hljs-number">37</span>:08 [DEBUG] [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.c.ChatClient - msg: GroupCreateResponseMessage(<span class="hljs-built_in">super</span>=AbstractResponseMessage(<span class="hljs-built_in">super</span>=Message(sequenceId=<span class="hljs-number">0</span>, messageType=<span class="hljs-number">5</span>), success=<span class="hljs-literal">true</span>, reason=group1创建成功))<br><span class="hljs-number">20</span>:<span class="hljs-number">37</span>:08 [DEBUG] [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.c.ChatClient - msg: GroupCreateResponseMessage(<span class="hljs-built_in">super</span>=AbstractResponseMessage(<span class="hljs-built_in">super</span>=Message(sequenceId=<span class="hljs-number">0</span>, messageType=<span class="hljs-number">5</span>), success=<span class="hljs-literal">true</span>, reason=您已被拉入group1))<br></code></pre></td></tr></table></figure><h4 id="4-2-聊天"><a href="#4-2-聊天" class="headerlink" title="4.2 聊天"></a>4.2 聊天</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupChatRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">groupName</span> <span class="hljs-operator">=</span> msg.getGroupName();<br>        <span class="hljs-type">GroupSession</span> <span class="hljs-variable">groupSession</span> <span class="hljs-operator">=</span> GroupSessionFactory.getGroupSession();<br>        <span class="hljs-comment">// 判断群聊是否存在</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isCreated</span> <span class="hljs-operator">=</span> groupSession.isCreated(groupName);<br>        <span class="hljs-keyword">if</span> (isCreated) &#123;<br>            <span class="hljs-comment">// 给群员发送信息</span><br>            List&lt;Channel&gt; membersChannel = groupSession.getMembersChannel(groupName);<br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatResponseMessage</span>(msg.getFrom(), msg.getContent()));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;群聊不存在&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">gsend group1 hello<br><span class="hljs-number">20</span>:<span class="hljs-number">40</span>:08 [DEBUG] [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.c.ChatClient - msg: GroupChatResponseMessage(<span class="hljs-built_in">super</span>=AbstractResponseMessage(<span class="hljs-built_in">super</span>=Message(sequenceId=<span class="hljs-number">0</span>, messageType=<span class="hljs-number">11</span>), success=<span class="hljs-literal">false</span>, reason=<span class="hljs-literal">null</span>), from=zhangsan, content=hello)<br></code></pre></td></tr></table></figure><p>接收方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">20</span>:<span class="hljs-number">40</span>:08 [DEBUG] [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.c.ChatClient - msg: GroupChatResponseMessage(<span class="hljs-built_in">super</span>=AbstractResponseMessage(<span class="hljs-built_in">super</span>=Message(sequenceId=<span class="hljs-number">0</span>, messageType=<span class="hljs-number">11</span>), success=<span class="hljs-literal">false</span>, reason=<span class="hljs-literal">null</span>), from=zhangsan, content=hello)<br></code></pre></td></tr></table></figure><p>当群聊不存在时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">gsend group2 hello<br><span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">41</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.c.ChatClient - msg: GroupChatResponseMessage(<span class="hljs-built_in">super</span>=AbstractResponseMessage(<span class="hljs-built_in">super</span>=Message(sequenceId=<span class="hljs-number">0</span>, messageType=<span class="hljs-number">11</span>), success=<span class="hljs-literal">false</span>, reason=群聊不存在), from=<span class="hljs-literal">null</span>, content=<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><h4 id="4-3-加入"><a href="#4-3-加入" class="headerlink" title="4.3 加入"></a>4.3 加入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupJoinRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupJoinRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">GroupSession</span> <span class="hljs-variable">groupSession</span> <span class="hljs-operator">=</span> GroupSessionFactory.getGroupSession();<br>        <span class="hljs-comment">// 判断该用户是否在群聊中</span><br>        Set&lt;String&gt; members = groupSession.getMembers(msg.getGroupName());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">joinFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 群聊存在且用户未加入，才能加入</span><br>        <span class="hljs-keyword">if</span> (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;<br>            joinFlag = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 加入群聊</span><br>            groupSession.joinMember(msg.getGroupName(), msg.getUsername());<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupJoinResponseMessage</span>(<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;加入&quot;</span>+msg.getGroupName()+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupJoinResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;加入失败，群聊未存在或您已加入该群聊&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-退出"><a href="#4-4-退出" class="headerlink" title="4.4 退出"></a>4.4 退出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupQuitMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupQuitRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">GroupSession</span> <span class="hljs-variable">groupSession</span> <span class="hljs-operator">=</span> GroupSessionFactory.getGroupSession();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">groupName</span> <span class="hljs-operator">=</span> msg.getGroupName();<br>        Set&lt;String&gt; members = groupSession.getMembers(groupName);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> msg.getUsername();<br>        <span class="hljs-comment">// 判断用户是否在群聊中以及群聊是否存在</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">joinFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (groupSession.isCreated(groupName) &amp;&amp; members.contains(username)) &#123;<br>            <span class="hljs-comment">// 可以退出</span><br>            joinFlag = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 退出成功</span><br>            groupSession.removeMember(groupName, username);<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupQuitResponseMessage</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;退出&quot;</span>+groupName+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 退出失败</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupQuitResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;群聊不存在或您未加入该群，退出&quot;</span>+groupName+<span class="hljs-string">&quot;失败&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-5-查看成员"><a href="#4-5-查看成员" class="headerlink" title="4.5 查看成员"></a>4.5 查看成员</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupMembersMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupMembersRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupMembersResponseMessage</span>(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-退出聊天室"><a href="#5-退出聊天室" class="headerlink" title="5. 退出聊天室"></a>5. 退出聊天室</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuitHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开连接时触发 Inactive事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 解绑</span><br>        SessionFactory.getSession().unbind(ctx.channel());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常退出，需要解绑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 解绑</span><br>        SessionFactory.getSession().unbind(ctx.channel());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>退出时，客户端会关闭channel并返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br>    ctx.channel().close();<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><h3 id="6-空闲检测"><a href="#6-空闲检测" class="headerlink" title="6. 空闲检测"></a>6. 空闲检测</h3><h4 id="6-1-连接假死"><a href="#6-1-连接假死" class="headerlink" title="6.1 连接假死"></a>6.1 连接假死</h4><p>原因</p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p>问题</p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h4 id="6-2-解决方法"><a href="#6-2-解决方法" class="headerlink" title="6.2 解决方法"></a>6.2 解决方法</h4><p>服务器端解决</p><ul><li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span><br><span class="hljs-comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelDuplexHandler</span>() &#123;<br>    <span class="hljs-comment">// 用来触发特殊事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> (IdleStateEvent) evt;<br>        <span class="hljs-comment">// 触发了读空闲事件</span><br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;<br>            log.debug(<span class="hljs-string">&quot;已经 5s 没有读到数据了&quot;</span>);<br>            ctx.channel().close();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>客户端定时心跳</p><ul><li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span><br><span class="hljs-comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelDuplexHandler</span>() &#123;<br>    <span class="hljs-comment">// 用来触发特殊事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> (IdleStateEvent) evt;<br>        <span class="hljs-comment">// 触发了写空闲事件</span><br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;<br>            <span class="hljs-comment">//                                log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PingMessage</span>());<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-入门</title>
    <link href="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/"/>
    <url>/2021/07/22/Netty-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty-入门"><a href="#Netty-入门" class="headerlink" title="Netty-入门"></a>Netty-入门</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><h3 id="1-Netty的优势"><a href="#1-Netty的优势" class="headerlink" title="1. Netty的优势"></a>1. Netty的优势</h3><ul><li>Netty vs NIO，工作量大，bug 多<ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>epoll 空轮询导致 CPU 100%</li><li>对 API 进行增强，使之更易用，如 FastThreadLocal &#x3D;&gt; ThreadLocal，ByteBuf &#x3D;&gt; ByteBuffer</li></ul></li><li>Netty vs 其它网络应用框架<ul><li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li><li>久经考验，16年，Netty 版本<ul><li>2.x 2004</li><li>3.x 2008</li><li>4.x 2013</li><li>5.x 已废弃（没有明显的性能提升，维护成本高）</li></ul></li></ul></li></ul><h3 id="2-Netty的应用"><a href="#2-Netty的应用" class="headerlink" title="2. Netty的应用"></a>2. Netty的应用</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p><p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p><ul><li>Cassandra - nosql 数据库</li><li>Spark - 大数据分布式计算框架</li><li>Hadoop - 大数据分布式存储框架</li><li>RocketMQ - ali 开源的消息队列</li><li>ElasticSearch - 搜索引擎</li><li>gRPC - rpc 框架</li><li>Dubbo - rpc 框架</li><li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li><li>Zookeeper - 分布式协调框架</li></ul><h2 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h2><p>开发一个简单的服务器端和客户端</p><ul><li>客户端向服务器端发送 hello, world</li><li>服务器仅接收，不返回</li></ul><h3 id="1-服务端代码"><a href="#1-服务端代码" class="headerlink" title="1. 服务端代码"></a>1. 服务端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>    <span class="hljs-comment">//1.创建NioEventLoopGroup，可以简单理解为线程池+Selector</span><br>    .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>    <span class="hljs-comment">//2.选择服务Socket实现类，其中NioServerSocketChannel表示基于NIO的服务器端实现</span><br>    <span class="hljs-comment">//其他实现还有EpollServerSocketChannel、KQueueServerSocketChannel</span><br>    .channel(NioServerSocketChannel.class)<br>    <span class="hljs-comment">//3.接下来添加的处理器都是给SocketChannel用的，而不是给ServerSocketChannel</span><br>    <span class="hljs-comment">//ChannelInitializer处理器（仅执行一次）</span><br>    <span class="hljs-comment">//它的作用是待客户端SocketChannel建立连接后，执行initChannel添加更多的处理器</span><br>    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>            <span class="hljs-comment">//5.SocketChannel的处理器，解码ByteBuf=&gt;String</span><br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());<br>            <span class="hljs-comment">//6.SocketChannel的业务处理器，使用上一个处理器的处理结果</span><br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> &#123;<br>                    System.out.println(msg);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    <span class="hljs-comment">//4.绑定的监听端口</span><br>    .bind(<span class="hljs-number">8080</span>); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="2-客户端代码"><a href="#2-客户端代码" class="headerlink" title="2. 客户端代码"></a>2. 客户端代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>    <span class="hljs-comment">//1.创建NioEventLoopGroup</span><br>    .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>    <span class="hljs-comment">//2.选择客户Socket实现类，NioSocketChannel表示基于NIO的客户端实现</span><br>    .channel(NioSocketChannel.class)<br>    <span class="hljs-comment">//3.添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次）</span><br>    <span class="hljs-comment">//它的作用是待客户端 SocketChannel 建立连接后，执行initChannel以便添加更多的处理器</span><br>    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(Channel ch)</span> &#123;<br>            <span class="hljs-comment">//8.消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 发出</span><br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>        &#125;<br>    &#125;)<br>    <span class="hljs-comment">//4.指定要连接的服务器ip地址和端口</span><br>    .connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>)<br>    <span class="hljs-comment">//5.Netty中很多方法都是异步的，比如connect，这时需要使用sync方法等待connect建立连接</span><br>    .sync()<br>    <span class="hljs-comment">//6.获取channel对象，它即为通道抽象，可以进行数据读写操作</span><br>    .channel()<br>    <span class="hljs-comment">//7.写入消息并清空缓冲区</span><br>    .writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;: hello world!&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-运行流程"><a href="#3-运行流程" class="headerlink" title="3. 运行流程"></a>3. 运行流程</h3><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/0040.png" class="" width="0040"><ul><li><p>把<code>channel</code>理解为数据的通道</p></li><li><p>把<code>msg</code>理解为流动的数据，最开始输入是<code>ByteBuf</code>，但经过<code>pipeline</code>的加工，会变成其它类型对象，最后输出又变成<code>ByteBuf</code></p></li><li><p>把<code>handler</code>理解为数据的处理工序</p><ul><li><p>工序有很多到，合在一起就是<code>pipeline</code>，<code>pipeline</code>负责发布事件传播给每个<code>handler</code>，<code>handler</code>对自己感兴趣的事件进行处理（重写了响应事件处理方法）</p></li><li><p><code>handler</code>分为<code>Inbound</code>和<code>Outbound</code>两类</p></li></ul></li><li><p>把<code>eventLoop</code>理解为处理数据的工人</p><ul><li>工人可以管理多个<code>channel</code>的IO操作，并且一旦工人负责了某个<code>channel</code>，就会与其进行绑定</li><li>工人既可以执行IO操作，也可以进行任务处理，每个工人有任务队列，队列里可以堆放多个<code>channel</code>的待处理任务，任务分为普通任务、定时任务</li><li>工人<code>pipeline</code>顺序，依次按照<code>handler</code>的规划处理数据，可以分每道工序指定不同的工人</li></ul></li></ul><h2 id="三、组件介绍"><a href="#三、组件介绍" class="headerlink" title="三、组件介绍"></a>三、组件介绍</h2><h3 id="1-BootStrap"><a href="#1-BootStrap" class="headerlink" title="1. BootStrap"></a>1. BootStrap</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><p>Netty的启动引导类提供了用于应用网络层配置的容器，包括绑定程序到一个给定端口或一个程序通过指定的host、port连接到另一个程序。 一般而言，我们将前一种情况称为引导一个服务端，后一种情况为引导一个客户端。</p><p><code>bootstrap</code>有两种类型：**一个用于客户端(称为简单<code>Bootstrap</code>)<strong>，</strong>另一个用于服务端(<code>ServerBootstrap</code>)**。无论你的应用使用哪种协议或数据类型，唯一决定使用哪种引导类的是它的功能，是将作为一个客户端还是服务端。</p><h4 id="1-2-Bootstrap-和-ServerBootstrap-的区别"><a href="#1-2-Bootstrap-和-ServerBootstrap-的区别" class="headerlink" title="1.2 Bootstrap 和 ServerBootstrap 的区别"></a>1.2 Bootstrap 和 ServerBootstrap 的区别</h4><ul><li>一个<code>ServerBootstrap</code>绑定一个端口，因为服务端必须监听连接。而<code>Bootstrap</code>用于想要连接远端的客户端应用。</li><li>引导一个客户端和需要一个<code>EventLoopGroup</code>，而服务端需要两个<code>EventLoopGroup</code>（这两个可以是同一个实例 ），即Reactor线程模型</li></ul><p>服务器端，一般有设置两个线程组，监听连接的 parent channel 工作在一个独立的线程组，这里名称为boss线程组。</p><p>连接成功后，负责客户端连接读写的 child channel 工作在另一个线程组，这里名称为 worker 线程组，专门负责搬数据。</p><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/image-20210723143325224.png" class="" title="image-20210723143325224"><h3 id="2-EventLoop"><a href="#2-EventLoop" class="headerlink" title="2. EventLoop"></a>2. EventLoop</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><p>事件循环对象（EventLoop）</p><p><code>EventLoop</code> 本质是一个单线程执行器（同时维护了一个 <code>Selector</code>），里面有 run 方法处理 <code>Channel </code>上源源不断的 IO 事件。</p><p>它的继承关系如下：</p><ul><li>一条线是继承自<code>java.util.concurrent.ScheduledExecutorService</code>因此包含了线程池中所有的方法</li><li>另一条线是继承自<code>Netty</code>自己的<code>OrderedEventExecutor</code>，<ul><li>提供了<code>boolean inEventLoop(Thread thread)</code>方法判断一个线程是否属于此<code>EventLoop</code></li><li>提供了<code>parent</code>方法来看看自己属于哪个<code>EventLoopGroup</code></li></ul></li></ul><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/image-20210723102619973.png" class="" title="image-20210723102619973"><p>事件循环组（EventLoopGroup）</p><p><code>EventLoopGroup</code>是一组<code>EventLoop</code>，<code>Channel</code>一般会调用<code>EventLoopGroup</code>的<code>regiser</code>方法来绑定其中一个<code>EventLoop</code>，后续这个<code>Channel</code>上的IO事件都会由此<code>EventLoop</code>来处理（保证了IO事件处理时的线程安全）</p><ul><li>继承自<code>Netty</code>自己的<code>EventExecutorGroup</code><ul><li>实现了<code>Iterable</code>接口提供遍历<code>EvetnLoop</code>的能力</li><li>另有<code>next</code>方法获取集合中下一个<code>EventLoop</code></li></ul></li></ul><h4 id="2-2-处理IO事件"><a href="#2-2-处理IO事件" class="headerlink" title="2.2 处理IO事件"></a>2.2 处理IO事件</h4><p><strong>服务端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>            <span class="hljs-comment">//两个EventLoopGroup一个代表Boss，一个代表Worker线程组</span><br>            .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>))<br>            .channel(NioServerSocketChannel.class)<br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>                            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                            <span class="hljs-keyword">if</span> (byteBuf != <span class="hljs-literal">null</span>) &#123;<br>                                <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">16</span>];<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> byteBuf.readBytes(buf, <span class="hljs-number">0</span>, byteBuf.readableBytes());<br>                                log.debug(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf));<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;).bind(<span class="hljs-number">8080</span>).sync();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>        .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>))<br>        .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>            &#125;<br>        &#125;)<br>        .channel(NioSocketChannel.class).connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)<br>        .sync()<br>        .channel();<br>    System.out.println(channel);<br>    <span class="hljs-comment">// 此处打断点调试，调用 channel.writeAndFlush();</span><br>    System.in.read();<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Netty是多线程的，所以调试时需要设置放行线程，否则会阻塞</p><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/image-20210723110326929.png" class="" title="image-20210723110326929"><p>使用多个客户端发送消息，可以看出，一个<code>EventLoop</code>可以负责多个<code>Channel</code>，且<code>EventLoop</code>一旦与<code>Channel</code>绑定，则一直负责处理该Channel中的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:08:<span class="hljs-number">21</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] c.d.n.c.TestServer - hello1          <br><span class="hljs-number">11</span>:08:<span class="hljs-number">31</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] c.d.n.c.TestServer - hello2          <br><span class="hljs-number">11</span>:08:<span class="hljs-number">39</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] c.d.n.c.TestServer - hello3          <br><span class="hljs-number">11</span>:08:<span class="hljs-number">41</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] c.d.n.c.TestServer - hello4          <br></code></pre></td></tr></table></figure><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/0042.png" class="" width="0042"><h4 id="2-3-增加自定义EventLoopGroup"><a href="#2-3-增加自定义EventLoopGroup" class="headerlink" title="2.3 增加自定义EventLoopGroup"></a>2.3 增加自定义EventLoopGroup</h4><p>添加两个非NIO工人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">DefaultEventLoopGroup</span> <span class="hljs-variable">normalWorkers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventLoopGroup</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>            .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>))<br>            .channel(NioServerSocketChannel.class)<br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>                    ch.pipeline().addLast(<span class="hljs-string">&quot;nioHandler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                            log.debug(buf.toString(StandardCharsets.UTF_8));<br>                            ctx.fireChannelRead(msg);<br>                        &#125;<br>                    &#125;);<br>                    ch.pipeline().addLast(normalWorkers, <span class="hljs-string">&quot;myhandler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>                            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                            log.debug(buf.toString(StandardCharsets.UTF_8));<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;).bind(<span class="hljs-number">8080</span>).sync();<br>&#125;<br></code></pre></td></tr></table></figure><p>开启三个客户端发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">30</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">4</span>-<span class="hljs-number">1</span>] c.d.n.c.TestServer - hello1<br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">30</span> [DEBUG] [defaultEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.n.c.TestServer - hello1<br><span class="hljs-number">11</span>:<span class="hljs-number">23</span>:<span class="hljs-number">12</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">4</span>-<span class="hljs-number">2</span>] c.d.n.c.TestServer - hello2<br><span class="hljs-number">11</span>:<span class="hljs-number">23</span>:<span class="hljs-number">12</span> [DEBUG] [defaultEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">2</span>] c.d.n.c.TestServer - hello2<br><span class="hljs-number">11</span>:<span class="hljs-number">23</span>:<span class="hljs-number">24</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">4</span>-<span class="hljs-number">1</span>] c.d.n.c.TestServer - hello3<br><span class="hljs-number">11</span>:<span class="hljs-number">23</span>:<span class="hljs-number">24</span> [DEBUG] [defaultEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.n.c.TestServer - hello3<br></code></pre></td></tr></table></figure><p>可以看出，客户端与服务器之间的事件，被<code>nioEventLoopGroup</code>和<code>defaultEventLoopGroup</code>分别处理</p><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/0041.png" class="" width="0041"><h4 id="2-4-EventLoopGroup切换的实现"><a href="#2-4-EventLoopGroup切换的实现" class="headerlink" title="2.4 EventLoopGroup切换的实现"></a>2.4 EventLoopGroup切换的实现</h4><p>由上面的图可以看出，当<code>handler</code>中绑定的<code>EventLoopGroup</code>不同时，需要切换<code>EventLoopGroup</code>来执行不同的任务</p><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);<br>    <span class="hljs-comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span><br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <br>    <span class="hljs-comment">// 是，直接调用</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeChannelRead(m);<br>    &#125; <br>    <span class="hljs-comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                next.invokeChannelRead(m);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li></ul><h4 id="2-5-处理普通任务或定时任务"><a href="#2-5-处理普通任务或定时任务" class="headerlink" title="2.5 处理普通任务或定时任务"></a>2.5 处理普通任务或定时任务</h4><p><code>NioEventLoop </code>除了可以处理 IO 事件，同样可以向它提交普通任务，可以用来执行耗时较长的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">nioWorkers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>);<br><br>log.debug(<span class="hljs-string">&quot;server start...&quot;</span>);<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>nioWorkers.execute(()-&gt;&#123;<br>    log.debug(<span class="hljs-string">&quot;normal task...&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>也可以执行定时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">nioWorkers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>);<br><br>log.debug(<span class="hljs-string">&quot;server start...&quot;</span>);<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>nioWorkers.scheduleAtFixedRate(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><h4 id="2-6-如何关闭EventLoopGroup"><a href="#2-6-如何关闭EventLoopGroup" class="headerlink" title="2.6 如何关闭EventLoopGroup"></a>2.6 如何关闭EventLoopGroup</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. Channel</h3><h4 id="3-1-Channel常用方法"><a href="#3-1-Channel常用方法" class="headerlink" title="3.1 Channel常用方法"></a>3.1 Channel常用方法</h4><ul><li>close() 可以用来关闭 channel</li><li>closeFuture() 用来处理 channel 的关闭<ul><li>sync 方法作用是同步等待 channel 关闭</li><li>而 addListener 方法是异步等待 channel 关闭</li></ul></li><li>pipeline() 方法添加处理器</li><li>write() 方法将数据写入</li><li>writeAndFlush() 方法将数据写入并刷出</li></ul><h4 id="3-2-ChannelFuture"><a href="#3-2-ChannelFuture" class="headerlink" title="3.2 ChannelFuture"></a>3.2 ChannelFuture</h4><p><strong>建立连接</strong></p><p>拆分客户端建立连接的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>        .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>        .channel(NioSocketChannel.class)<br>        .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>            &#125;<br>        &#125;)<br>        <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>        <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>        .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    <span class="hljs-comment">// 该方法用于等待连接真正建立</span><br>    channelFuture.sync();<br>    <span class="hljs-comment">// 获取客户端-服务器之间的Channel对象</span><br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>    channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    System.in.read();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>connect </code>方法是异步的，意味着不等连接建立，方法执行就返回了。因此 <code>channelFuture </code>对象中不能【立刻】获得到正确的 Channel 对象。</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>除了用 sync 方法可以让异步操作同步以外，还可以使用<strong>回调</strong>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br><span class="hljs-comment">// 当connect方法执行完毕后，也就是连接真正建立后</span><br>        <span class="hljs-comment">// 会在NIO线程中调用operationComplete方法</span><br>        channelFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>                channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.in.read();<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>ChannelFutureListener </code>会在连接建立时被调用（其中<code>operationComplete</code>方法）</p><p><strong>处理关闭</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    NioEventLoopGroup group <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>        .group(group)<br>        .channel(NioSocketChannel.class)<br>        .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 在连接建立后被调用</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>            &#125;<br>        &#125;)<br>        .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.sync().channel();<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, channel);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(line)) &#123;<br>                channel.close(); <span class="hljs-comment">// close 异步操作 1s 之后</span><br>                <span class="hljs-comment">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            channel.writeAndFlush(line);<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;input&quot;</span>).start();<br><br>    <span class="hljs-comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span><br>    <span class="hljs-comment">//方法1</span><br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">closeFuture</span> <span class="hljs-operator">=</span> channel.closeFuture();<br>    closeFuture.sync();<br><span class="hljs-comment">//方法2</span><br>    closeFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            log.debug(<span class="hljs-string">&quot;处理关闭之后的操作&quot;</span>);<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择两种方法来实现，也就是同步处理关闭，或者是通过回调机制异步处理关闭</p><h3 id="4-Future和Promise"><a href="#4-Future和Promise" class="headerlink" title="4. Future和Promise"></a>4. Future和Promise</h3><h4 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h4><p>Netty中的 <code>Future </code>与 JDK中的 <code>Future </code>同名，但是是两个接口，Netty的 <code>Future </code>继承自 JDK的 <code>Future</code>，而 <code>Promise</code> 又对 Netty的<code>Future </code>进行了扩展</p><ul><li><code>JDK Future</code>只能同步等待任务结束（或成功、或失败）才能得到结果</li><li><code>Netty Future</code>可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li><li><code>Netty Promise</code>不仅有<code>Netty Future</code>的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li></ul><table><thead><tr><th>功能&#x2F;名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h4 id="4-2-JDK-Future"><a href="#4-2-JDK-Future" class="headerlink" title="4.2 JDK Future"></a>4.2 JDK Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-comment">// 1. 线程池</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>    <span class="hljs-comment">// 2. 提交任务</span><br>    Future&lt;Integer&gt; future = service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            log.debug(<span class="hljs-string">&quot;执行计算&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 3. 通过future获取结果，get是阻塞方法</span><br>    log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>    log.debug(<span class="hljs-string">&quot;结果: &#123;&#125;&quot;</span>, future.get());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">43</span>:<span class="hljs-number">06</span> [DEBUG] [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] c.d.n.c.TestJdkFuture - 执行计算<br><span class="hljs-number">12</span>:<span class="hljs-number">43</span>:<span class="hljs-number">06</span> [DEBUG] [main] c.d.n.c.TestJdkFuture - 等待结果<br><span class="hljs-number">12</span>:<span class="hljs-number">43</span>:<span class="hljs-number">07</span> [DEBUG] [main] c.d.n.c.TestJdkFuture - 结果: <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h4 id="4-3-Netty-Future"><a href="#4-3-Netty-Future" class="headerlink" title="4.3 Netty Future"></a>4.3 Netty Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>    <span class="hljs-type">EventLoop</span> <span class="hljs-variable">eventLoop</span> <span class="hljs-operator">=</span> group.next();<br>    Future&lt;Integer&gt; future = eventLoop.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            log.debug(<span class="hljs-string">&quot;执行计算&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">70</span>;<br>        &#125;<br>    &#125;);<br>    log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>    log.debug(<span class="hljs-string">&quot;获取结果：&#123;&#125;&quot;</span>, future.getNow());<br>    future.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="hljs-built_in">super</span> Integer&gt;&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-built_in">super</span> Integer&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            log.debug(<span class="hljs-string">&quot;结果是 &#123;&#125;&quot;</span>, future.getNow());<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">46</span>:<span class="hljs-number">01</span> [DEBUG] [main] c.d.n.c.TestNettyFuture - 等待结果<br><span class="hljs-number">12</span>:<span class="hljs-number">46</span>:<span class="hljs-number">01</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.n.c.TestNettyFuture - 执行计算<br><span class="hljs-number">12</span>:<span class="hljs-number">46</span>:<span class="hljs-number">01</span> [DEBUG] [main] c.d.n.c.TestNettyFuture - 获取结果：<span class="hljs-literal">null</span><br><span class="hljs-number">12</span>:<span class="hljs-number">46</span>:<span class="hljs-number">02</span> [DEBUG] [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] c.d.n.c.TestNettyFuture - 结果是 <span class="hljs-number">70</span><br></code></pre></td></tr></table></figure><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过<code>Future.get()</code>方法，阻塞地获取返回结果</li><li>也可以通过<code>Future.getNow()</code>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<code>future.addListener</code>，在<code>Callable</code>方法执行的线程中，异步获取返回结果</li></ul><h4 id="4-4-Netty-Promise"><a href="#4-4-Netty-Promise" class="headerlink" title="4.4 Netty Promise"></a>4.4 Netty Promise</h4><p><code>Promise</code>相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-comment">// 1. 准备EventLoop对象</span><br>    <span class="hljs-type">EventLoop</span> <span class="hljs-variable">eventLoop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>().next();<br><br>    <span class="hljs-comment">// 2. 可以主动创建promise对象，结果容器</span><br>    DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPromise</span>&lt;&gt;(eventLoop);<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 3. 任意线程执行计算，向promise对象填充结果</span><br>        log.debug(<span class="hljs-string">&quot;开始计算...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        promise.setSuccess(<span class="hljs-number">80</span>);<br>    &#125;).start();<br><br>    <span class="hljs-comment">// 4. 接收结果的线程</span><br>    log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>    log.debug(<span class="hljs-string">&quot;结果是 &#123;&#125;&quot;</span>,promise.get());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span>:<span class="hljs-number">48</span>:<span class="hljs-number">26</span> [DEBUG] [main] c.d.n.c.TestNettyPromise - 等待结果<br><span class="hljs-number">12</span>:<span class="hljs-number">48</span>:<span class="hljs-number">26</span> [DEBUG] [Thread-<span class="hljs-number">0</span>] c.d.n.c.TestNettyPromise - 开始计算...<br><span class="hljs-number">12</span>:<span class="hljs-number">48</span>:<span class="hljs-number">27</span> [DEBUG] [main] c.d.n.c.TestNettyPromise - 结果是 <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="5-Handler和PipeLine"><a href="#5-Handler和PipeLine" class="headerlink" title="5. Handler和PipeLine"></a>5. Handler和PipeLine</h3><p><code>ChannelHandler </code>用来处理<code>Channel </code>上的各种事件，分为入站、出站两种。所有<code>ChannelHandler </code>被连成一串，就是<code>Pipeline</code></p><ul><li>入站处理器通常是<code>ChannelInboundHandlerAdapter </code>的子类，主要用来读取客户端数据，写回结果</li><li>出站处理器通常是<code>ChannelOutboundHandlerAdapter </code>的子类，主要对写回结果进行加工</li></ul><p><strong>服务端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>    .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>    .channel(NioServerSocketChannel.class)<br>    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br>            <span class="hljs-comment">//在socketChannel的pipeline中添加handler</span><br>            <span class="hljs-comment">//Inbound主要处理入站操作，一般为读操作，发生入站操作会触发inbound方法</span><br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>                    System.out.println(<span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">//调用该方法将数据传递给下一个handler</span><br>                    ctx.fireChannelRead(msg); <span class="hljs-comment">// 1</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>                    System.out.println(<span class="hljs-number">2</span>);<br>                    ctx.fireChannelRead(msg); <span class="hljs-comment">// 2</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>                    System.out.println(<span class="hljs-number">3</span>);<br>                    ctx.channel().write(msg); <span class="hljs-comment">// 3</span><br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">//outbound主要处理出站操作，一般为写操作，发生出站操作会触发outbound方法</span><br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, </span><br><span class="hljs-params">                                  ChannelPromise promise)</span> &#123;<br>                    System.out.println(<span class="hljs-number">4</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 4</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, </span><br><span class="hljs-params">                                  ChannelPromise promise)</span> &#123;<br>                    System.out.println(<span class="hljs-number">5</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 5</span><br>                &#125;<br>            &#125;);<br>            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, </span><br><span class="hljs-params">                                  ChannelPromise promise)</span> &#123;<br>                    System.out.println(<span class="hljs-number">6</span>);<br>                    ctx.write(msg, promise); <span class="hljs-comment">// 6</span><br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    .bind(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><p><strong>服务端打印：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>ChannelInboundHandlerAdapter </code>是按照 <code>addLast </code>的顺序执行的，而 <code>ChannelOutboundHandlerAdapter </code>是按照 <code>addLast </code>的逆序执行的。<code>ChannelPipeline </code>的实现是一个 <code>ChannelHandlerContext</code>（包装了 <code>ChannelHandler</code>） 组成的双向链表</p><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/0008.png" class="" width="0008"><ul><li><p>3 处的 <code>ctx.channel().write(msg)</code> 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行</p></li><li><p>类似的，出站处理器中，<code>ctx.write(msg, promise)</code> 的调用也会 <strong>触发上一个出站处理器</strong></p></li><li><p><code>ctx.channel().write(msg)</code> 和 <code>ctx.write(msg)</code></p><ul><li>都是触发出站处理器的执行</li><li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li><li>ctx.write(msg) 是从当前节点找上一个出站处理器</li><li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li><li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li></ul></li></ul><p><strong>调用顺序如下：</strong></p><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/0009.png" class="" width="0009"><h3 id="6-ByteBuf"><a href="#6-ByteBuf" class="headerlink" title="6. ByteBuf"></a>6. ByteBuf</h3><h4 id="6-1-创建"><a href="#6-1-创建" class="headerlink" title="6.1 创建"></a>6.1 创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer();<br>    System.out.println(buffer.getClass());<br>    log(buffer);<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>    buffer.writeBytes(sb.toString().getBytes());<br>    log(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeDirectByteBuf<br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">0</span> capacity:<span class="hljs-number">256</span><br><br>read index:<span class="hljs-number">0</span> write index:<span class="hljs-number">20</span> capacity:<span class="hljs-number">256</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> |aaaaaaaaaaaaaaaa|<br>|<span class="hljs-number">00000010</span>| <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span> <span class="hljs-number">61</span>                                     |aaaa            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p><strong>调试工具代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(ByteBuf buffer)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> buffer.readableBytes();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> length / <span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(rows * <span class="hljs-number">80</span> * <span class="hljs-number">2</span>)<br>        .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.readerIndex())<br>        .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writerIndex())<br>        .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity())<br>        .append(NEWLINE);<br>    appendPrettyHexDump(buf, buffer);<br>    System.out.println(buf.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ByteBuf</code><strong>通过<code>ByteBufAllocator</code>选择<code>allocator</code>并调用对应的<code>buffer()</code>方法来创建的</strong>，默认使用<strong>池化直接内存</strong>作为<code>ByteBuf</code>，容量为256个字节，可以指定初始容量的大小</p><p>当<code>ByteBuf</code>的容量无法容纳所有数据时，<code>ByteBuf</code><strong>会进行扩容操作</strong></p><p><strong>如果在<code>handler</code>中创建<code>ByteBuf</code>，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h4 id="6-2-直接内存-vs-堆内存"><a href="#6-2-直接内存-vs-堆内存" class="headerlink" title="6.2 直接内存 vs 堆内存"></a>6.2 直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>代码验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br>    System.out.println(buffer.getClass());<br><br>    buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);<br>    System.out.println(buffer.getClass());<br><br>    buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);<br>    System.out.println(buffer.getClass());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用池化的直接内存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeDirectByteBuf<br><span class="hljs-comment">// 使用池化的堆内存    </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeHeapByteBuf<br><span class="hljs-comment">// 使用池化的直接内存    </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeDirectByteBuf<br></code></pre></td></tr></table></figure><h4 id="6-3-池化-vs-非池化"><a href="#6-3-池化-vs-非池化" class="headerlink" title="6.3 池化 vs 非池化"></a>6.3 池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;<br></code></pre></td></tr></table></figure><ul><li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h4 id="6-4-组成"><a href="#6-4-组成" class="headerlink" title="6.4 组成"></a>6.4 组成</h4><p>ByteBuf主要有以下几个组成部分</p><ul><li><p>最大容量与当前容量</p><ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li><p>读写操作不同于ByteBuffer只用position进行控制，</p><p>ByteBuf分别由读指针和写指针两个指针控制</p><p>。进行读写操作时，无需进行模式的切换</p><ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/20210423143030.png" class="" title="img"><h4 id="6-5-写入操作"><a href="#6-5-写入操作" class="headerlink" title="6.5 写入操作"></a>6.5 写入操作</h4><p>常用方法列表</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>用一字节 01|00 代表 true|false</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian，即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian，即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 ByteBuffer</td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td></td></tr></tbody></table><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><p>先写入 4 个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>log(buffer);<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:4 capacity:10<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>再写入一个 int 整数，也是 4 个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.writeInt(<span class="hljs-number">5</span>);<br>log(buffer);<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:8 capacity:10<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="6-6-扩容"><a href="#6-6-扩容" class="headerlink" title="6.6 扩容"></a>6.6 扩容</h4><p>接着上面的代码再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.writeInt(<span class="hljs-number">6</span>);<br>log(buffer);<br></code></pre></td></tr></table></figure><p>扩容规则是</p><ul><li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li><li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10&#x3D;1024（2^9&#x3D;512 已经不够了）</li><li>扩容不能超过 max capacity 会报错</li></ul><p>结果是</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="6-7-读取"><a href="#6-7-读取" class="headerlink" title="6.7 读取"></a>6.7 读取</h4><p>例如读了 4 次，每次一个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(buffer.readByte());<br>System.out.println(buffer.readByte());<br>System.out.println(buffer.readByte());<br>System.out.println(buffer.readByte());<br>log(buffer);<br></code></pre></td></tr></table></figure><p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1<br>2<br>3<br>4<br>read index:4 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>如果需要重复读取 int 整数 5，怎么办？</p><p>可以在 read 前先做个标记 mark</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.markReaderIndex();<br>System.out.println(buffer.readInt());<br>log(buffer);<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5<br>read index:8 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 06                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>这时要重复读取的话，重置到标记位置 reset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.resetReaderIndex();<br>log(buffer);<br></code></pre></td></tr></table></figure><p>这时</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:4 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p><h4 id="6-8-释放"><a href="#6-8-释放" class="headerlink" title="6.8 释放"></a>6.8 释放</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p><ul><li><code>UnpooledHeapByteBuf </code>使用的是 JVM 内存，只需等 GC 回收内存即可</li><li><code>UnpooledDirectByteBuf </code>使用的就是直接内存了，需要特殊的方法来回收内存</li><li><code>PooledByteBuf </code>和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 <code>ByteBuf </code>都实现了 <code>ReferenceCounted </code>接口</p><ul><li>每个 <code>ByteBuf </code>对象的初始计数为 1</li><li>调用 <code>release</code> 方法计数减 1，如果计数为 0，<code>ByteBuf </code>内存被回收</li><li>调用 <code>retain </code>方法计数加 1，表示调用者没用完之前，其它 <code>handler </code>即使调用了 <code>release </code>也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 <code>ByteBuf </code>对象还在，其各个方法均无法正常使用</li></ul><hr><p><strong>何时释放</strong></p><p>因为 <code>pipeline</code> 的存在，一般需要将 <code>ByteBuf </code>传递给下一个 <code>ChannelHandler</code>，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 <code>ChannelHandler </code>内这个 <code>ByteBuf </code>已完成了它的使命，那么便无须再传递）</p><p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p><ul><li><p>起点，对于 NIO 实现来讲，在<code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>方法中首次创建 <code>ByteBuf </code>放入 <code>pipeline</code></p></li><li><p>入站 <code>ByteBuf </code>处理原则</p><ul><li>对原始 <code>ByteBuf </code>不做处理，调用 <code>ctx.fireChannelRead(msg)</code> 向后传递，这时<strong>无须释放</strong></li><li>将原始 <code>ByteBuf </code>转换为其它类型的 Java 对象，这时<code>ByteBuf </code>就没用了，<strong>必须释放</strong></li><li>如果不调用<code>ctx.fireChannelRead(msg)</code>向后传递，那么也<strong>必须释放</strong></li><li>注意各种异常，如果<code>ByteBuf </code>没有成功传递到下一个<code>ChannelHandler</code>，<strong>必须释放</strong></li><li>假设消息一直向后传，那么<code>TailContext </code>会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 <code>ByteBuf </code>处理原则</p><ul><li>出站消息最终都会转为<code>ByteBuf </code>输出，一直向前传，由<code>HeadContext </code>释放</li></ul></li><li><p>异常处理原则</p><ul><li>有时候不清楚<code>ByteBuf </code>被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li></ul></li></ul><p>当<code>ByteBuf</code><strong>被传到了pipeline的head与tail时</strong>，<code>ByteBuf</code>会被其中的方法彻底释放</p><p><code>TailContext </code>释放未处理消息源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<br>            <span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +<br>            <span class="hljs-string">&quot;Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>release</code>具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Object msg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ReferenceCounted) &#123;<br>        <span class="hljs-keyword">return</span> ((ReferenceCounted) msg).release();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-9-切片"><a href="#6-9-切片" class="headerlink" title="6.9 切片"></a>6.9 切片</h4><p>切片【零拷贝】的体现之一，对原始 <code>ByteBuf </code>进行切片成多个 <code>ByteBuf</code>，切片后的 <code>ByteBuf</code>并没有发生内存复制，还是使用原始 <code>ByteBuf</code>的内存，切片后的<code>ByteBuf</code>维护独立的 read，write 指针</p><img src="/2021/07/22/Netty-%E5%85%A5%E9%97%A8/0011.png" class="" width="0011"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br>        <span class="hljs-comment">// 将buffer分成两部分</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">slice1</span> <span class="hljs-operator">=</span> buffer.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">slice2</span> <span class="hljs-operator">=</span> buffer.slice(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 需要让分片的buffer引用计数加一</span><br>        <span class="hljs-comment">// 避免原Buffer释放导致分片buffer无法使用</span><br>        slice1.retain();<br>        slice2.retain();<br>        ByteBufUtil.log(slice1);<br>        ByteBufUtil.log(slice2);<br>        <span class="hljs-comment">// 更改原始buffer中的值</span><br>        System.out.println(<span class="hljs-string">&quot;===========修改原buffer中的值===========&quot;</span>);<br>        buffer.setByte(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;===========打印slice1===========&quot;</span>);<br>        ByteBufUtil.log(slice1);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>===========修改原buffer中的值===========<br>===========打印slice1===========<br>read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 05 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-NIO</title>
    <link href="/2021/07/12/Netty-NIO/"/>
    <url>/2021/07/12/Netty-NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，是一种同步非阻塞的I&#x2F;O模型，也是I&#x2F;O多路复用的基础，<strong>可以替代标准的Java IO API</strong>。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持<strong>面向缓冲区的、基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。</p><p>传统IO在传输数据时，根据输入输出的不同需要分别建立<strong>不同的链接</strong>，而且传输的数据是以<strong>流</strong>的形式在链接上进行传输的：</p><img src="/2021/07/12/Netty-NIO/20201109084453.png" class="" title="img"><p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据：</p><img src="/2021/07/12/Netty-NIO/20201109085054.png" class="" title="img"><h2 id="二、三大组件介绍"><a href="#二、三大组件介绍" class="headerlink" title="二、三大组件介绍"></a>二、三大组件介绍</h2><p>NIO主要有三大核心部分：<code>Channel</code>(通道)，<code>Buffer</code>(缓冲区)，<code>Selector</code>(选择器)。传统IO基于字节流和字符流进行操作，而NIO基于<code>Channel</code>和<code>Buffer</code>进行操作，数据通过通道读取到缓冲区中，或者从缓冲区写入到通道。<code>Selector</code>用于监听多个通道的事件（比如：建立连接、接收到数据）。因此，单个线程可以监听多个数据通道，也就是IO多路复用。</p><h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><h4 id="1-1-缓冲区类型"><a href="#1-1-缓冲区类型" class="headerlink" title="1.1 缓冲区类型"></a>1.1 缓冲区类型</h4><p>Buffer有以下几种，其中使用较多的是ByteBuffer，后续内容主要介绍ByteBuffer</p><ul><li><code>ByteBuffer</code><ul><li><code>MappedByteBuffer</code></li><li><code>DirectByteBuffer</code>(直接内存中的缓冲区)</li><li><code>HeapByteBuffer</code>(堆内存中的缓冲区)</li></ul></li><li><code>ShortBuffer</code></li><li><code>IntBuffer</code></li><li><code>LongBuffer</code></li><li><code>FloatBuffer</code></li><li><code>DoubleBuffer</code></li><li><code>CharBuffer</code></li></ul><h4 id="1-2-ByteBuffer结构"><a href="#1-2-ByteBuffer结构" class="headerlink" title="1.2 ByteBuffer结构"></a>1.2 ByteBuffer结构</h4><p>ByteBuffer重要属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于存放数据的二进制数组</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] hb;<br><span class="hljs-comment">//继承自Buffer父类：</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br></code></pre></td></tr></table></figure><p>初始状态</p><img src="/2021/07/12/Netty-NIO/0021.png" class=""><p>写模式下，position是写入位置，limit等于容量，下图表示写入4个字节后的状态</p><img src="/2021/07/12/Netty-NIO/0018.png" class="" width="0018"><p>调用flip方法后，position切换为读取状态，limit为读取限制</p><img src="/2021/07/12/Netty-NIO/0019.png" class="" width="0019"><p>读取4个字节后，状态如下</p><img src="/2021/07/12/Netty-NIO/0020.png" class="" width="0020"><p>调用clear方法后，状态如下，position和limit都回到初始位置，</p><img src="/2021/07/12/Netty-NIO/0021-1626102313561.png" class="" width="0021"><p>调用compact方法时，把未读完的部分向前压缩，然后切换至写模式</p><img src="/2021/07/12/Netty-NIO/0022.png" class="" width="0022"><h4 id="1-3-ByteBuffer常用方法"><a href="#1-3-ByteBuffer常用方法" class="headerlink" title="1.3 ByteBuffer常用方法"></a>1.3 ByteBuffer常用方法</h4><p><strong>分配空间</strong></p><p>可以使用allocate方法为ByteBuffer分配空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p><strong>向buffer写入数据</strong></p><p>常用的有两种方法：</p><ul><li><p>调用channel 的read方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf);<br></code></pre></td></tr></table></figure></li><li><p>调用buffer自己的put方法</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">buf.put((byte)<span class="hljs-number">127</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>从buffer读取数据</strong></p><p>同样有两种方法：</p><ul><li><p>调用channel的write方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf);<br></code></pre></td></tr></table></figure></li><li><p>调用buffer自己的get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get();<br></code></pre></td></tr></table></figure><p>get方法会让position读指针向后走，如果向重复读取数据</p><ul><li>可以调用rewind方法将position重新置为0</li><li>或者调用get(int i)方法获取索引为i的内容</li></ul></li></ul><p><strong>mark和reset</strong></p><p>mark是在读取时，做一个标记，即使position改变，调用reset可以回到mark的位置，便于重复读取数据，但是rewind和flip都会清楚mark位置</p><p><strong>字符串与ByteBuffer互转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-comment">//字符串转ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer2</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>).encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><br>debug(buffer1);<br>debug(buffer2);<br><br><span class="hljs-comment">//ByteBuffer转字符串</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer3</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buffer1);<br>System.out.println(buffer3.getClass());<br>System.out.println(buffer3.toString());<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>class java.nio.HeapCharBuffer<br>你好<br></code></pre></td></tr></table></figure><h4 id="1-4-非直接缓冲区和直接缓冲区"><a href="#1-4-非直接缓冲区和直接缓冲区" class="headerlink" title="1.4 非直接缓冲区和直接缓冲区"></a>1.4 非直接缓冲区和直接缓冲区</h4><p><strong>非直接缓冲区</strong></p><p>通过allocate()方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM堆内存之中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><br>    <span class="hljs-comment">// 在堆内存中开辟空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapByteBuffer</span>(capacity, capacity);<br>&#125;<br><br>HeapByteBuffer(<span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> lim) &#123;        <span class="hljs-comment">// package-private</span><br>    <span class="hljs-comment">// new byte[cap] 创建数组，在堆内存中开辟空间</span><br>    <span class="hljs-built_in">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, lim, cap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[cap], <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    hb = new byte[cap];</span><br><span class="hljs-comment">    offset = 0;</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="/2021/07/12/Netty-NIO/20201109151057.png" class="" title="img"><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。都需要经过JVM和操作系统，数据在两个地址空间中传输时，会copy一份保存在对方的空间中。所以费直接缓冲区的读取效率较低。</p><p><strong>直接缓冲区</strong></p><p>只有ByteBuffer可以获得直接缓冲区，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在物理内存之中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocateDirect</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectByteBuffer</span>(capacity);<br>&#125;<br><br>DirectByteBuffer(<span class="hljs-type">int</span> cap) &#123;                   <span class="hljs-comment">// package-private</span><br>...<br>    <span class="hljs-comment">// 申请物理内存</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> VM.isDirectMemoryPageAligned();<br>...<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2021/07/12/Netty-NIO/20201109151520.png" class="" title="img"><p>直接缓冲区通过在操作系统和JVM之间创建物理内存映射文件加快缓冲区数据读&#x2F;写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中。</p><h3 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><p>通道（<code>Channel</code>）是对 BIO 中的流的模拟，可以通过它读写数据。只不过<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong>。类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。</p><h4 id="2-2-模型"><a href="#2-2-模型" class="headerlink" title="2.2 模型"></a>2.2 模型</h4><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低。</p><img src="/2021/07/12/Netty-NIO/20201109153039.png" class="" title="img"><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong>。</p><img src="/2021/07/12/Netty-NIO/20201109153439.png" class="" title="img"><p>于是便有了<strong>Channel(通道)<strong>，Channel相当于一个</strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求。</p><img src="/2021/07/12/Netty-NIO/20201109154113.png" class="" title="img"><h4 id="2-3-Channel的种类"><a href="#2-3-Channel的种类" class="headerlink" title="2.3 Channel的种类"></a>2.3 Channel的种类</h4><p>包括以下类型：</p><ul><li><code>FileChannel</code>：从文件中读写数据；</li><li><code>DatagramChannel</code>：通过 UDP 读写网络中数据；</li><li><code>SocketChannel</code>：通过 TCP 读写网络中数据；</li><li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h3 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3. Selector"></a>3. Selector</h3><h4 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h4><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p><p><code>Selector</code> 是 Java NIO 编程的基础。用于检查一个或多个 NIO <code>Channel</code> 的状态是否处于可读、可写。</p><h4 id="3-2-连接模型"><a href="#3-2-连接模型" class="headerlink" title="3.2 连接模型"></a>3.2 连接模型</h4><p>在使用<code>Selector</code>之前，处理socket连接还有以下两种方法：</p><p><strong>多线程版设计</strong></p><pre><code class=" mermaid">graph TDsubgraph 多线程版t1(thread) --&gt; s1(socket1)t2(thread) --&gt; s2(socket2)t3(thread) --&gt; s3(socket3)end</code></pre><p>缺点：</p><ul><li>内存占用高：每个线程都需要占用一定的内存，连接较多时会创建大量线程占用内存。</li><li>线程上下文切换成本高：CPU处理能力有限，当存在大量线程时，线程之间的切换会损耗性能。</li><li>只适合连接数少的场景</li></ul><p><strong>线程池版设计</strong></p><pre><code class=" mermaid">graph TDsubgraph 线程池版t4(thread) --&gt; s4(socket1)t5(thread) --&gt; s5(socket2)t4(thread) -.-&gt; s6(socket3)t5(thread) -.-&gt; s7(socket4)end</code></pre><p>缺点：</p><ul><li>阻塞模式下，线程仅能处理一个 socket 连接<ul><li>线程池中的线程获取任务后，只有当完成该任务后，才会执行下一个任务。</li><li>若socket连接一直未断开，会造成其对应的线程一直阻塞，无法处理其他socket的连接。</li></ul></li><li>仅适合短连接场景</li></ul><p><strong>使用选择器</strong></p><p>NIO 实现了 IO 多路复用中的 Reactor 模型：</p><pre><code class=" mermaid">graph TDsubgraph selector 版thread --&gt; selectorselector --&gt; c1(channel)selector --&gt; c2(channel)selector --&gt; c3(channel)end</code></pre><ul><li>一个线程（<code>Thread</code>）使用一个<strong>选择器 <code>Selector</code> 通过轮询的方式去监听多个通道 <code>Channel</code> 上的事件（<code>accpet</code>、<code>read</code>）</strong>，如果某个 <code>Channel</code> 上面发生监听事件，这个 <code>Channel</code> 就处于就绪状态，然后进行 I&#x2F;O 操作。</li><li>通过<strong>配置监听的通道 <code>Channel</code> 为非阻塞</strong>，那么当 <code>Channel</code> 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 <code>Channel</code>，找到 IO 事件已经到达的 <code>Channel</code> 执行。</li><li>因为创建和切换线程的开销很大，因此使用<strong>一个线程来处理多个事件</strong>而不是一个线程处理一个事件具有更好的性能。</li></ul><h4 id="3-3-简单使用"><a href="#3-3-简单使用" class="headerlink" title="3.3 简单使用"></a>3.3 简单使用</h4><ol><li><p>创建选择器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure></li><li><p>将通道注册到选择器上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li><code>SelectionKey.OP_CONNECT</code></li><li><code>SelectionKey.OP_ACCEPT</code></li><li><code>SelectionKey.OP_READ</code></li><li><code>SelectionKey.OP_WRITE</code></li></ul></li><li><p>监听事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> selector.select();<br></code></pre></td></tr></table></figure><p>使用 <code>select()</code> 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p></li><li><p>获取事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br><span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    keyIterator.remove();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>事件轮询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> selector.select();<br>    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br>    <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        keyIterator.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p></li></ol><h2 id="三、网络编程"><a href="#三、网络编程" class="headerlink" title="三、网络编程"></a>三、网络编程</h2><h3 id="1-阻塞"><a href="#1-阻塞" class="headerlink" title="1. 阻塞"></a>1. 阻塞</h3><ul><li><p>阻塞模式下，相关方法都会对导致线程暂停</p><ul><li><code>ServerSocketChannel.accept</code>会在没有连接建立时让线程暂停</li><li><code>SocketChannel.read</code>会在没有数据可读时让线程暂停</li><li>阻塞的表现就是线程暂停了，暂停期间不会占用cpu，但线程闲置</li></ul></li><li><p>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</p></li><li><p>但在多线程下，有新的问题：</p><ul><li><p>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</p></li><li><p>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</p></li></ul></li></ul><p><strong>服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 nio 来理解阻塞模式, 单线程</span><br><span class="hljs-comment">// 0. ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    log.debug(<span class="hljs-string">&quot;connecting...&quot;</span>);<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept(); <span class="hljs-comment">// 阻塞方法，线程停止运行</span><br>    log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>    channels.add(sc);<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        log.debug(<span class="hljs-string">&quot;before read... &#123;&#125;&quot;</span>, channel);<br>        channel.read(buffer); <span class="hljs-comment">// 阻塞方法，线程停止运行</span><br>        buffer.flip();<br>        debugRead(buffer);<br>        buffer.clear();<br>        log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>System.out.println(<span class="hljs-string">&quot;waiting...&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-非阻塞"><a href="#2-非阻塞" class="headerlink" title="2. 非阻塞"></a>2. 非阻塞</h3><ul><li>非阻塞模式下，相关方法都不会让线程暂停<ul><li>在<code>ServerSocketChannel.accept</code>没有连接建立时，会返回null</li><li><code>SocketChannel.read</code>在没有数据可读时，会返回0，但线程不会阻塞，可以去执行其他<code>SocketChannel</code>的read事件或是去执行<code>ServerSocketChannel</code>的accept事件</li><li>写数据时，线程只是等待数据写入Channel即可，无需等Channel通过网络把数据发送出去</li></ul></li><li>但非阻塞模式下，即使没有连接建立，或可读数据，线程仍然在不断运行，浪费了cpu</li><li>数据复制过程中，线程实际还是阻塞的</li></ul><p><strong>服务端代码如下，客户端代码不变</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 nio 来理解非阻塞模式, 单线程</span><br><span class="hljs-comment">// 0. ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>ssc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept(); <span class="hljs-comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span><br>    <span class="hljs-keyword">if</span> (sc != <span class="hljs-literal">null</span>) &#123;<br>        log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>        sc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br>        channels.add(sc);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<span class="hljs-comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span><br>        <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.flip();<br>            debugRead(buffer);<br>            buffer.clear();<br>            log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-多路复用"><a href="#3-多路复用" class="headerlink" title="3. 多路复用"></a>3. 多路复用</h3><p>单线程可以配合<code>Selector</code>完成对多个Channel可读写事件的监控，这称之为多路复用</p><ul><li>多路复用仅针对网络IO、普通文件IO没法利用多路复用</li><li>如果不用<code>Selector</code>的非阻塞模式，线程大部分时间都在做无用功，而Selecotr能够保证：<ul><li>有可连接事件时才去连接</li><li>有可读事件采取读取</li><li>有可写事件采取写入</li></ul></li></ul><p>根据上文Selector的简单使用可以写出代码</p><h4 id="3-1-处理accept事件"><a href="#3-1-处理accept事件" class="headerlink" title="3.1 处理accept事件"></a>3.1 处理accept事件</h4><p><strong>客户端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)) &#123;<br>            System.out.println(socket);<br>            socket.getOutputStream().write(<span class="hljs-string">&quot;world&quot;</span>.getBytes());<br>            System.in.read();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>            channel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            System.out.println(channel);<br>            <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>            channel.configureBlocking(<span class="hljs-literal">false</span>);<br>            channel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>                <span class="hljs-comment">// 遍历所有事件，逐一处理</span><br>                Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                    <span class="hljs-comment">// 判断事件类型</span><br>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                        <span class="hljs-comment">// 必须处理</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                    &#125;<br>                    <span class="hljs-comment">// 处理完毕，必须将事件移除</span><br>                    iter.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>事件发生后，要么处理，要么取消，不能什么都不做，否则下次该事件仍会触发，因为NIO底层使用的是水平触发</p><h4 id="3-2-处理read事件"><a href="#3-2-处理read事件" class="headerlink" title="3.2 处理read事件"></a>3.2 处理read事件</h4><p>对上面的代码进行改造，客户端代码不变</p><p><strong>服务端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>            channel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            System.out.println(channel);<br>            <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>            channel.configureBlocking(<span class="hljs-literal">false</span>);<br>            channel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>                <span class="hljs-comment">// 遍历所有事件，逐一处理</span><br>                Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                    <span class="hljs-comment">// 判断事件类型</span><br>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                        <span class="hljs-comment">// 必须处理</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                        sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                        sc.register(selector, SelectionKey.OP_READ);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isReadable())&#123;<br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>                        <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>)&#123;<br>                            key.cancel();<br>                            sc.close();<br>                        &#125; <span class="hljs-keyword">else</span>&#123;<br>                            buffer.flip();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 处理完毕，必须将事件移除</span><br>                    iter.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为何要<code>iter.remove()</code>？</strong></p><p>当<code>select</code>在事件发生后，就会将相关的key放入<code>selectedKeys</code>集合，但不会在处理完后从集合中移除，需要自己编码删除，否则第二次连接会尝试获取第一次的连接，导致空指针异常。</p><p>除此之外，上面的代码会产生消息边界的问题，即黏包、粘包等问题，这在Netty框架自带解决方法，这也是为什么推荐使用Netty，因为Netty对NIO进行了封装和改进，便于编码。</p><h4 id="3-3-处理write事件"><a href="#3-3-处理write事件" class="headerlink" title="3.3 处理write事件"></a>3.3 处理write事件</h4><ul><li>非阻塞模式下，无法保证把<code>buffer</code>中所有数据都写入<code>channel</code>，因此需要追踪<code>write</code>方法的返回值（代表实际写入的字节数）</li><li>使用<code>selector</code>监听所有<code>channel</code>的可写事件，每个<code>channel</code>都需要一个key来跟踪<code>buffer</code>，但这样又会导致占用内存过多，就有两阶段策略：<ul><li>当消息处理器第一次写入消息时，才将<code>channel</code>注册到<code>selector</code>上</li><li><code>selector</code>检查<code>channel</code>上的可写事件，如果所有的数据写完了，就取消<code>channel</code>的注册</li><li>如果不取消，每次可写均会触发<code>write</code>事件</li></ul></li></ul><p><strong>服务端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>        ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            selector.select();<br><br>            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept();<br>                    sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sckey</span> <span class="hljs-operator">=</span> sc.register(selector, SelectionKey.OP_READ);<br>                    <span class="hljs-comment">// 1. 向客户端发送内容</span><br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000000</span>; i++) &#123;<br>                        sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Charset.defaultCharset().encode(sb.toString());<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buffer);<br>                    <span class="hljs-comment">// 3. write 表示实际写了多少字节</span><br>                    System.out.println(<span class="hljs-string">&quot;实际写入字节:&quot;</span> + write);<br>                    <span class="hljs-comment">// 4. 如果有剩余未读字节，才需要关注写事件</span><br>                    <span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;<br>                        <span class="hljs-comment">// read 1  write 4</span><br>                        <span class="hljs-comment">// 在原有关注事件的基础上，多关注 写事件</span><br>                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);<br>                        <span class="hljs-comment">// 把 buffer 作为附件加入 sckey</span><br>                        sckey.attach(buffer);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> (ByteBuffer) key.attachment();<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> sc.write(buffer);<br>                    System.out.println(<span class="hljs-string">&quot;实际写入字节:&quot;</span> + write);<br>                    <span class="hljs-keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="hljs-comment">// 写完了</span><br>                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);<br>                        key.attach(<span class="hljs-literal">null</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>        sc.configureBlocking(<span class="hljs-literal">false</span>);<br>        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);<br>        sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            selector.select();<br>            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                iter.remove();<br>                <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>                    System.out.println(sc.finishConnect());<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>                    count += sc.read(buffer);<br>                    buffer.clear();<br>                    System.out.println(count);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4-优化"><a href="#3-4-优化" class="headerlink" title="3.4 优化"></a>3.4 优化</h4><p>上面的代码都是只有一个选择器，没有充分利用多核cpu，可以进行改进：</p><ul><li>单线程分配一个选择器，专门处理accept事件</li><li>创建cpu核心数的线程，每个线程配一个选择器，轮询处理read事件</li></ul><p>这是一个<strong>主从多线程模型</strong>，Netty框架同时支持Reactor单线程模型、Reactor多线程模型和Reactor主从多线程模型，接下来通过创建线程组来模拟<strong>主从多线程模型</strong>。</p><p><strong>服务端代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiThreadServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BossEventLoop</span>().register();<br>    &#125;<br><br>    <span class="hljs-comment">//Boss线程，负责监听连接事件</span><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BossEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-comment">//作为boss线程的选择器</span><br>        <span class="hljs-keyword">private</span> Selector boss;<br>        <span class="hljs-keyword">private</span> WorkerEventLoop[] workers;<br>        <span class="hljs-comment">//标志是否已启动</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>                ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>                ssc.configureBlocking(<span class="hljs-literal">false</span>);<br>                boss = Selector.open();<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">ssckey</span> <span class="hljs-operator">=</span> ssc.register(boss, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>                <span class="hljs-comment">//监听连接事件</span><br>                ssckey.interestOps(SelectionKey.OP_ACCEPT);<br>                <span class="hljs-comment">//初始化worker线程组</span><br>                workers = initEventLoops();<br>                <span class="hljs-comment">//启动主线程</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;boss&quot;</span>).start();<br>                log.debug(<span class="hljs-string">&quot;boss start...&quot;</span>);<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//初始化worker线程组</span><br>        <span class="hljs-keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;<br>            WorkerEventLoop[] workerEventLoops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workerEventLoops.length; i++) &#123;<br>                workerEventLoops[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerEventLoop</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> workerEventLoops;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    boss.select();<br>                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        iter.remove();<br>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> c.accept();<br>                            sc.configureBlocking(<span class="hljs-literal">false</span>);<br>                            log.debug(<span class="hljs-string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());<br>                            workers[index.getAndIncrement() % workers.length].register(sc);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//worker线程</span><br>    <span class="hljs-meta">@Slf4j</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerEventLoop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> Selector worker;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//线程的编号</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br>        <span class="hljs-comment">//任务队列，注册Socket</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkerEventLoop</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>            <span class="hljs-built_in">this</span>.index = index;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(SocketChannel sc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-keyword">if</span> (!start) &#123;<br>                worker = Selector.open();<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;worker-&quot;</span> + index).start();<br>                start = <span class="hljs-literal">true</span>;<br>            &#125;<br>            tasks.add(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sckey</span> <span class="hljs-operator">=</span> sc.register(worker, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">//注册事件，此处只实现了read事件的监听</span><br>                    sckey.interestOps(SelectionKey.OP_READ);<br>                    worker.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            worker.wakeup();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    worker.select();<br>                    <span class="hljs-comment">//获取task进行处理</span><br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> tasks.poll();<br>                    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();<br>                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">128</span>);<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>                                <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123;<br>                                    key.cancel();<br>                                    sc.close();<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    buffer.flip();<br>                                    log.debug(<span class="hljs-string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());<br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                                e.printStackTrace();<br>                                key.cancel();<br>                                sc.close();<br>                            &#125;<br>                        &#125;<br>                        iter.remove();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、NIO-vs-BIO"><a href="#四、NIO-vs-BIO" class="headerlink" title="四、NIO vs BIO"></a>四、NIO vs BIO</h2><h3 id="1-stream-vs-channel"><a href="#1-stream-vs-channel" class="headerlink" title="1. stream vs channel"></a>1. stream vs channel</h3><ul><li><code>stream</code>不会自动缓冲数据，<code>channel</code>会利用系统提供的发送缓冲区，接收缓冲区</li><li><code>stream</code>仅支持阻塞API，<code>channel</code>同时支持阻塞、非阻塞API，网络<code>channel</code>可配合<code>selector</code>实现多路复用</li><li>二者均为全双工，即读写可以同时进行</li></ul><h3 id="2-IO模型"><a href="#2-IO模型" class="headerlink" title="2. IO模型"></a>2. IO模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞、异步非阻塞</p><ul><li>同步：线程自己去获取结果（一个线程）</li><li>异步：线程自己不去获取结果，而是由其他线程送结果（至少两个线程）</li></ul><p>当调用一次<code>channel.read</code>或<code>stream.read</code>后，会切换至操作系统内核来完成真正的数据读取，而读取又分为两个阶段，分别为：</p><ul><li>等待数据阶段</li><li>复制数据阶段</li></ul><img src="/2021/07/12/Netty-NIO/0033.png" class="" width="0033"><ul><li>阻塞IO</li></ul><img src="/2021/07/12/Netty-NIO/0039.png" class="" width="0039"><ul><li>非阻塞IO</li></ul><img src="/2021/07/12/Netty-NIO/0035.png" class="" width="0035"><ul><li>多路复用</li></ul><img src="/2021/07/12/Netty-NIO/0038.png" class="" width="0038"><ul><li>信号驱动，异步IO</li></ul><img src="/2021/07/12/Netty-NIO/0037.png" class="" width="0037"><ul><li>阻塞IO vs 多路复用</li></ul><img src="/2021/07/12/Netty-NIO/0034.png" class="" width="0034"><img src="/2021/07/12/Netty-NIO/0036.png" class="" width="0036"><h3 id="3-零拷贝"><a href="#3-零拷贝" class="headerlink" title="3. 零拷贝"></a>3. 零拷贝</h3><h4 id="3-1-传统IO问题"><a href="#3-1-传统IO问题" class="headerlink" title="3.1 传统IO问题"></a>3.1 传统IO问题</h4><p>传统的IO将一个文件通过<code>socket</code>写出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()];<br>file.read(buf);<br><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ...;<br>socket.getOutputStream().write(buf);<br></code></pre></td></tr></table></figure><p>内部工作流程：</p><img src="/2021/07/12/Netty-NIO/0024.png" class="" width="0024"><ol><li>java本身并不具备IO读写能力，因此read方法调用后，要从java程序的<strong>用户态</strong>切换到<strong>内核态</strong>，去调用操作系统（Kernel）的API，将数据读到<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用DMA（Direct Memory Access）来实现文件读，期间也不会使用CPU。</li><li>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即byte[] buf），这期间CPU会参与拷贝，无法利用DMA。</li><li>调用write方法，这时将数据从<strong>用户缓冲区</strong>写入<strong>socket缓冲区</strong>，CPU会参与拷贝。</li><li>接下来要向网卡写数据，这项能力java也不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的API，使用DMA将<strong>socket缓冲区</strong>的数据写入网卡，不会使用CPU。</li></ol><p>可以看到中间有很多环节，java的IO实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态从内核态的切换发生了3次，这个操作比较重量级</li><li>数据拷贝共4次</li></ul><h4 id="3-2-NIO优化"><a href="#3-2-NIO优化" class="headerlink" title="3.2 NIO优化"></a>3.2 NIO优化</h4><p>通过DirectByteBuf</p><ul><li><code>ByteBuffer.allocate(10)</code> <code>HeapByteBuffer</code>使用的还是java内存</li><li><code>ByteBuffer.allocateDirect(10)</code> <code>DirectByteBuffer</code>使用的是操作系统内存</li></ul><img src="/2021/07/12/Netty-NIO/0025.png" class="" width="0025"><p>大部分步骤与优化前相同，不再赘述。唯有一点：java可以使用DirectByteBuf将堆外内存映射到jvm内存中来直接访问使用</p><ul><li>这块内存不受jvm垃圾回收的影响，因此内存地址固定，有助于IO读写</li><li>java中的DirectByteBuf对象仅维护了此内存的虚引用，内存回收分为两步<ul><li>DirectByteBuf对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li></ul><p><strong>进一步优化1</strong>（底层采用了linux 2.1后提供的<code>sendFile</code>方法），java中对应着两个<code>channel</code>调用<code>transferTo</code>&#x2F;<code>transferFrom</code>方法拷贝数据</p><img src="/2021/07/12/Netty-NIO/0026.png" class="" width="0026"><ol><li>java调用<code>transferTo</code>方法后，要从java程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用DMA将数据读入<strong>内核缓冲区</strong>，不会使用CPU</li><li>数据从<strong>内核缓冲区</strong>传输到<strong>socket缓冲区</strong>，CPU会参与拷贝</li><li>最后使用DMA将<strong>socket缓冲区</strong>的数据写入网卡，不会使用CPU</li></ol><p>可以看到</p><ul><li>之发生了一次用户态与内核态的切换</li><li>数据拷贝了3次</li></ul><p><strong>进一步优化2（linux 2.4）</strong></p><img src="/2021/07/12/Netty-NIO/0027.png" class="" width="0027"><ol><li>java调用<code>transferTo</code>方法后，要从java程序的用户态切换至内核态，使用DMA将数据读入<strong>内核缓冲区</strong>，不会使用CPU</li><li>只会将一些<code>offset</code>和<code>length</code>信息拷如<strong>socket缓冲区</strong>，几乎无消耗</li><li>使用DMA将内核缓冲区的数据写入网卡，不会使用CPU</li></ol><p>整个过程只发生一次用户态与内核态的切换，数据拷贝了2次，所谓的零拷贝，并不是真正无拷贝，而是在不会拷贝重复数据到jvm内存，零拷贝的优点：</p><ul><li>更少的用户态与内核态的切换</li><li>不利用CPU计算，减少而CPU缓存伪共享</li><li>零拷贝适合小文件传输</li></ul>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo SPI</title>
    <link href="/2021/07/12/Dubbo-SPI/"/>
    <url>/2021/07/12/Dubbo-SPI/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><h1 id="1-SPI机制介绍"><a href="#1-SPI机制介绍" class="headerlink" title="1. SPI机制介绍"></a>1. SPI机制介绍</h1><h2 id="1-1-什么是SPI"><a href="#1-1-什么是SPI" class="headerlink" title="1.1 什么是SPI"></a>1.1 什么是SPI</h2><p>SPI全称Service Provider Interface，是一种服务发现机制，比如你需要使用一个接口，该接口有三个实现类，这时需要SPI来根据指定的配置或是默认的配置，去加载对应的实现类，然后使用该类的实例对象</p><p>从使用层面来说，<strong>它是以一种服务发现机制，SPI 的本质是将接口实现类的全限定名配置在文件张，并由服务器加载读取配置文件，加载实现类，这样可以在运行时，动态为接口替换实现类</strong>。</p><h2 id="1-2-JDK-SPI示例"><a href="#1-2-JDK-SPI示例" class="headerlink" title="1.2 JDK SPI示例"></a>1.2 JDK SPI示例</h2><p>创建接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Robot</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimusPrime</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Robot</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;OptimusPrime&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bumblebee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Robot</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bumblebee&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建配置文件，放在META-INF&#x2F;service&#x2F;接口全限定类名，规定了指定接口的具体实现类的全限定类名</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.gfk</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.OptimusPrime</span><br>com<span class="hljs-selector-class">.gfk</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.iml</span>.Bumblebee<br></code></pre></td></tr></table></figure><p>编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);<br>    System.out.println(<span class="hljs-string">&quot;Java SPI&quot;</span>);<br>    serviceLoader.forEach(Robot::sayHello);<br>&#125;<br><span class="hljs-comment">/* 输出 */</span><br>Java SPI<br>OptimusPrime<br>Bumblebee<br></code></pre></td></tr></table></figure><p>通过上述测试代码可以看出：使用配置文件，来动态改变一个接口的具体实现类。</p><h2 id="1-3-Dubbo-SPI示例"><a href="#1-3-Dubbo-SPI示例" class="headerlink" title="1.3 Dubbo SPI示例"></a>1.3 Dubbo SPI示例</h2><p>Dubbo并没有使用JDK的SPI机制，而是自己实现了一套SPI机制，功能更强大。</p><p>Dubbo SPI的相关逻辑被封装在ExtensionLoader类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF&#x2F;dubbo 路径下，配置内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fallback">optimusPrime = org.apache.spi.OptimusPrime<br>bumblebee = org.apache.spi.Bumblebee<br></code></pre></td></tr></table></figure><p>JDK SPI的实现会将配置文件中的所有实现类都进行实例化，有些扩展类初始化耗时，并且可能用不上，耗费了资源。</p><p>Dubbo SPI的配置采用键值对的形式，按需加载需要的实现类。</p><p>接口类需要使用@SPI注解，实现类不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SPI</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Robot</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ExtensionLoader&lt;Robot&gt; extensionLoader = <br>        ExtensionLoader.getExtensionLoader(Robot.class);<br>    <span class="hljs-type">Robot</span> <span class="hljs-variable">optimusPrime</span> <span class="hljs-operator">=</span> extendionLoader.getExtension(<span class="hljs-string">&quot;optimusPrime&quot;</span>);<br>    optimusPrime.satHello();<br>    <span class="hljs-type">Robot</span> <span class="hljs-variable">bumblebee</span> <span class="hljs-operator">=</span> extensionLoader.getExtension(<span class="hljs-string">&quot;bumblebee&quot;</span>);<br>    bumblebe.sayHello();<br>&#125;<br><span class="hljs-comment">/* output */</span><br>Dubbo SPI<br>Hello, I am Optimus Prime.<br>Hello, I am Bumblebee.<br></code></pre></td></tr></table></figure><h1 id="2-Dubbo-SPI-源码"><a href="#2-Dubbo-SPI-源码" class="headerlink" title="2. Dubbo SPI 源码"></a>2. Dubbo SPI 源码</h1><h2 id="2-1-核心流程"><a href="#2-1-核心流程" class="headerlink" title="2.1 核心流程"></a>2.1 核心流程</h2><p>在Dubbo SPI的使用中，首先通过ExtensionLoader的getExtensionLoader方法来获取一个ExtensionLoader实例，然后再通过ExtensionLoader的getExtension方法获取具体的扩展类对象。</p><ul><li>getExtensionLoader方法用于从缓存中获取扩展类对应的ExtensionLoader，如果缓存未命中则创建一个新实例。</li><li>getExtension首先检查缓存，若缓存未命中则创建扩展对象</li></ul><p>其中getExtensionLoader源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="hljs-title function_">getExtensionLoader</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>    <span class="hljs-comment">//可行性判断</span><br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension type == null&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!type.isInterface()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension type(&quot;</span> + type + <span class="hljs-string">&quot;) is not interface!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!withExtensionAnnotation(type)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension type(&quot;</span> + type +<br>                <span class="hljs-string">&quot;) is not extension, because WITHOUT @&quot;</span> + SPI.class.getSimpleName() + <span class="hljs-string">&quot; Annotation!&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//先尝试获取，如果失败就创建一个ExtensionLoader</span><br>    <span class="hljs-comment">//EXTENSION_LOADERS是一个静态ConcurrentHashMap，用来缓存ExtensionLoader</span><br>    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);<br>    <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>) &#123;<br>        EXTENSION_LOADERS.putIfAbsent(type, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExtensionLoader</span>&lt;T&gt;(type));<br>        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);<br>    &#125;<br>    <span class="hljs-keyword">return</span> loader;<br>&#125;<br></code></pre></td></tr></table></figure><p>getExtension源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getExtension</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span> || name.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension name == null&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;true&quot;</span>.equals(name)) &#123;<br>        <span class="hljs-comment">// 获取默认的拓展实现类</span><br>        <span class="hljs-keyword">return</span> getDefaultExtension();<br>    &#125;<br>    <span class="hljs-comment">// Holder，用于持有目标对象</span><br>    Holder&lt;Object&gt; holder = cachedInstances.get(name);<br>    <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123;<br>        cachedInstances.putIfAbsent(name, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Holder</span>&lt;Object&gt;());<br>        holder = cachedInstances.get(name);<br>    &#125;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> holder.get();<br>    <span class="hljs-comment">// 双重检查</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (holder) &#123;<br>            instance = holder.get();<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 创建拓展实例</span><br>                instance = createExtension(name);<br>                <span class="hljs-comment">// 设置实例到 holder 中</span><br>                holder.set(instance);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>getExtension的逻辑比较清晰，先检查缓存，缓存未命中则创建Extension对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">createExtension</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">//从配置文件中加载所有的扩展类，可得到(配置项名称)-&gt;(配置类)的映射关系表</span><br>    Class&lt;?&gt; clazz = getExtensionClasses().get(name);<br>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> findException(name);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//EXTENSION_INSTANCES是(配置类)-&gt;(对象实例)的映射关系表</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//缓存中不存在，通过反射创建实例</span><br>            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());<br>            instance = (T) EXTENSION_INSTANCES.get(clazz);<br>        &#125;<br>        <span class="hljs-comment">//向实例中注入依赖</span><br>        injectExtension(instance);<br>        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;<br>        <span class="hljs-keyword">if</span> (wrapperClasses != <span class="hljs-literal">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;<br>            <span class="hljs-comment">//循环创建wrapper实例</span><br>            <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;<br>                <span class="hljs-comment">//将当前instance作为参数传给wrapper的构造方法，并通过反射创建实例</span><br>                <span class="hljs-comment">//然后向Wrapper实例中注入依赖，最后再赋值给instance</span><br>                instance = injectExtension(<br>                  (T)wrapperClass.getConstructor(type).newInstance(instance));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Extension instance(name: &quot;</span> + name + <span class="hljs-string">&quot;, class: &quot;</span> +<br>                                        type + <span class="hljs-string">&quot;)  could not be instantiated: &quot;</span> + t.getMessage(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>createExtension的方法逻辑包含以下步骤：</p><ol><li>通过getExtensionClasses获取所有的扩展类</li><li>通过反射创建扩展对象</li><li>向扩展对象中注入依赖</li><li>将扩展对象包裹在相应的Wrapper对象中</li></ol><h2 id="2-2-获取所有扩展类"><a href="#2-2-获取所有扩展类" class="headerlink" title="2.2 获取所有扩展类"></a>2.2 获取所有扩展类</h2><p>我们在通过名称获取拓展类之前，首先需要根据配置文件解析出拓展项名称到拓展类的映射关系表（Map&lt;名称, 拓展类&gt;），之后再根据拓展项名称从映射关系表中取出相应的拓展类即可。相关过程的代码分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;<br>    <span class="hljs-comment">// 从缓存中获取已加载的拓展类</span><br>    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();<br>    <span class="hljs-comment">// 双重检查</span><br>    <span class="hljs-keyword">if</span> (classes == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (cachedClasses) &#123;<br>            classes = cachedClasses.get();<br>            <span class="hljs-keyword">if</span> (classes == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 加载拓展类</span><br>                classes = loadExtensionClasses();<br>                cachedClasses.set(classes);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> classes;<br>&#125;<br></code></pre></td></tr></table></figure><p>先检查缓存，若缓存未命中，则通过 synchronized 加锁。加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则通过 loadExtensionClasses 加载拓展类。下面分析 loadExtensionClasses 方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;<br>    <span class="hljs-comment">// 获取 SPI 注解，这里的 type 变量是在调用 getExtensionLoader 方法时传入的</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SPI</span> <span class="hljs-variable">defaultAnnotation</span> <span class="hljs-operator">=</span> type.getAnnotation(SPI.class);<br>    <span class="hljs-keyword">if</span> (defaultAnnotation != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> defaultAnnotation.value();<br>        <span class="hljs-keyword">if</span> ((value = value.trim()).length() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 对 SPI 注解内容进行切分</span><br>            String[] names = NAME_SEPARATOR.split(value);<br>            <span class="hljs-comment">// 检测 SPI 注解内容是否合法，不合法则抛出异常</span><br>            <span class="hljs-keyword">if</span> (names.length &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;more than 1 default extension name on extension...&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// 设置默认名称，参考 getDefaultExtension 方法</span><br>            <span class="hljs-keyword">if</span> (names.length == <span class="hljs-number">1</span>) &#123;<br>                cachedDefaultName = names[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Class&lt;?&gt;&gt;();<br>    <span class="hljs-comment">// 加载指定文件夹下的配置文件</span><br>    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);<br>    loadDirectory(extensionClasses, DUBBO_DIRECTORY);<br>    loadDirectory(extensionClasses, SERVICES_DIRECTORY);<br>    <span class="hljs-keyword">return</span> extensionClasses;<br>&#125;<br></code></pre></td></tr></table></figure><p>loadExtensionClasses方法主要完成两件事情：</p><ol><li>对SPI注解进行解析</li><li>调用loadDirectory加载指定文件夹配置文件</li></ol><h2 id="2-3-Dubbo-IOC"><a href="#2-3-Dubbo-IOC" class="headerlink" title="2.3 Dubbo IOC"></a>2.3 Dubbo IOC</h2><p>Dubbo IOC通过setter方法完成依赖注入，首先通过反射获取实例的所有方法，然后遍历并检测方法是否具有setter注解。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用 setter 方法将依赖设置到目标对象中，整个过程对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">injectExtension</span><span class="hljs-params">(T instance)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (objectFactory != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 遍历目标类的所有方法</span><br>            <span class="hljs-keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;<br>                <span class="hljs-comment">// 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public</span><br>                <span class="hljs-keyword">if</span> (method.getName().startsWith(<span class="hljs-string">&quot;set&quot;</span>)<br>                    &amp;&amp; method.getParameterTypes().length == <span class="hljs-number">1</span><br>                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;<br>                    <span class="hljs-comment">// 获取 setter 方法参数类型</span><br>                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="hljs-number">0</span>];<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 获取属性名，比如 setName 方法对应属性名 name</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">property</span> <span class="hljs-operator">=</span> method.getName().length() &gt; <span class="hljs-number">3</span> ? <br>                            method.getName().substring(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>).toLowerCase() + <br>                            method.getName().substring(<span class="hljs-number">4</span>) : <span class="hljs-string">&quot;&quot;</span>;<br>                        <span class="hljs-comment">// 从 ObjectFactory 中获取依赖对象</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> objectFactory.getExtension(pt, property);<br>                        <span class="hljs-keyword">if</span> (object != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">// 通过反射调用 setter 方法设置依赖</span><br>                            method.invoke(instance, object);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        logger.error(<span class="hljs-string">&quot;fail to inject via method...&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(e.getMessage(), e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-SPI自适应扩展"><a href="#3-SPI自适应扩展" class="headerlink" title="3. SPI自适应扩展"></a>3. SPI自适应扩展</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>在 Dubbo 中，很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。</p><p>这听起来有些矛盾。拓展未被加载，那么拓展方法就无法被调用（静态方法除外）。拓展方法未被调用，拓展就无法被加载。对于这个矛盾的问题，Dubbo 通过自适应拓展机制很好的解决了。</p><p>自适应拓展机制的实现逻辑比较复杂，首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class 类。最后再通过反射创建代理类。</p><p>通过Protocol来举例，更好的理解Dubbo的SPI自适应扩展的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Protocol</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span> ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();<br></code></pre></td></tr></table></figure><p>Protocol 接口，在系统运行的时候，，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。</p><p>它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象。</p><p>再Dubbo的组件中，有许多接口，如Protocol、Cluster、LoadBalance等，有多种实现可以选择，Dubbo在启动时会根据配置动态保留其中一个进行实现，如果没有配置，则选择默认配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SPI(&quot;dubbo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Protocol</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDefaultPort</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Adaptive</span><br>    &lt;T&gt; Exporter&lt;T&gt; <span class="hljs-title function_">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException;<br><br>    <span class="hljs-meta">@Adaptive</span><br>    &lt;T&gt; Invoker&lt;T&gt; <span class="hljs-title function_">refer</span><span class="hljs-params">(Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 dubbo 自己的 jar 里，在 <code>/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code> 文件中：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dubbo=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.DubboProtocol</span><br>http=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.HttpProtocol</span><br>hessian=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.hessian</span>.HessianProtocol<br></code></pre></td></tr></table></figure><p><code>@SPI(&quot;dubbo&quot;)</code> 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 <code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</code> 。</p><p>如果想要动态替换掉默认的实现类，需要使用 <code>@Adaptive</code> 接口，Protocol 接口中，有两个方法加了 <code>@Adaptive</code> 注解，就是说那俩接口会被代理实现。</p><p>如果需要扩展自己的组件，可以自己写一个工程，并打成jar包。在 <code>src/main/resources</code> 目录下，建立一个 <code>META-INF/services</code> 文件夹，在里面新建一个文件名： <code>com.alibaba.dubbo.rpc.Protocol</code> ，然后在文件中写入自定义实现的全限定类名，如 <code>my=com.dys.MyProtocol</code> 。</p><p>之后在Dubbo消费者工程中通过maven引入jar包，当Dubbo启动时，就会加载自定义的组件。</p><h2 id="3-2-Adptive的作用"><a href="#3-2-Adptive的作用" class="headerlink" title="3.2 @Adptive的作用"></a>3.2 @Adptive的作用</h2><p>Dubbo 中的扩展点一般都具有很多个扩展实现，简单说就是一个接口存在很多个实现。但接口是不能被实例化的，所以要在运行时找一个具体的实现类来实例化。 <code>@Adaptive</code> 是用来在运行时决定选择哪个实现的。如果标注在类上就表示这个类是适配类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Adaptive &#123;<br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Dubbo 中，仅有两个类被 Adaptive 注解了，分别是 AdaptiveCompiler 和 AdaptiveExtensionFactory。此种情况，表示拓展的加载逻辑由人工编码完成。多时候，Adaptive 是注解在接口方法上的，表示这个方法要在运行时通过字节码生成工具动态生成方法体，在方法体内选择具体的实现来使用，比如 Protocol 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SPI(&quot;dubbo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Protocol</span> &#123;<br>  <span class="hljs-meta">@Adaptive</span><br>  &lt;T&gt; Exporter&lt;T&gt; <span class="hljs-title function_">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException;<br>    <span class="hljs-meta">@Adaptive</span><br>  &lt;T&gt; Invoker&lt;T&gt; <span class="hljs-title function_">refer</span><span class="hljs-params">(Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，Protocol 的每个实现都有自己暴露服务和引用服务的逻辑，如果直接根据 URL 去解析要使用的协议并实例化显然不是一个好的选择，于是通过了字节码增强的方式来实现。</p><h2 id="3-3-获取自适应扩展入口"><a href="#3-3-获取自适应扩展入口" class="headerlink" title="3.3 获取自适应扩展入口"></a>3.3 获取自适应扩展入口</h2><p>getAdaptiveExtension 方法是获取自适应拓展的入口方法。该方法在ExtensionLoader的构造器中调用，即在ExtensionLoader初始化时获取自适应扩展的入口，进行自适应扩展类的生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">ExtensionLoader</span><span class="hljs-params">(Class&lt;?&gt; type)</span> &#123;<br>    <span class="hljs-comment">// 存储要创建的 loader 的类型</span><br>    <span class="hljs-built_in">this</span>.type = type;<br><br>    <span class="hljs-comment">// objectFactory 是 ExtensionFactory 类型的对象，是用来依赖注入的工厂</span><br>    objectFactory <br>        = (type == ExtensionFactory.class ? <br>           <span class="hljs-literal">null</span> : ExtensionLoader<br>           .getExtensionLoader(ExtensionFactory.class)<br>           .getAdaptiveExtension());<br>&#125;<br></code></pre></td></tr></table></figure><p>具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getAdaptiveExtension</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 从缓存中获取自适应拓展</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> cachedAdaptiveInstance.get();<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// 缓存未命中</span><br>        <span class="hljs-keyword">if</span> (createAdaptiveInstanceError == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (cachedAdaptiveInstance) &#123;<br>                instance = cachedAdaptiveInstance.get();<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 创建自适应拓展</span><br>                        instance = createAdaptiveExtension();<br>                        <span class="hljs-comment">// 设置自适应拓展到缓存中</span><br>                        cachedAdaptiveInstance.set(instance);<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                        createAdaptiveInstanceError = t;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;fail to create adaptive instance: ...&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;fail to create adaptive instance:  ...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (T) instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>getAdaptiveExtension 方法首先会检查缓存，缓存未命中，则调用 createAdaptiveExtension 方法创建自适应拓展。下面是createAdaptiveExtension 方法的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">createAdaptiveExtension</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取自适应拓展类，并通过反射实例化</span><br>        <span class="hljs-keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Can not create adaptive extension ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>createAdaptiveExtension 包含了三个逻辑，分别如下：</p><ol><li>调用 getAdaptiveExtensionClass 方法获取自适应拓展 Class 对象</li><li>通过反射进行实例化</li><li>调用 injectExtension 方法向拓展实例中注入依赖</li></ol><p>getAdaptiveExtensionClass代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;<br>    <span class="hljs-comment">// 通过 SPI 获取所有的拓展类</span><br>    getExtensionClasses();<br>    <span class="hljs-comment">// 检查缓存，若缓存不为空，则直接返回缓存</span><br>    <span class="hljs-keyword">if</span> (cachedAdaptiveClass != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> cachedAdaptiveClass;<br>    &#125;<br>    <span class="hljs-comment">// 创建自适应拓展类</span><br>    <span class="hljs-type">return</span> <span class="hljs-variable">cachedAdaptiveClass</span> <span class="hljs-operator">=</span> createAdaptiveExtensionClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>getAdaptiveExtensionClass 方法同样包含了三个逻辑，如下：</p><ol><li>调用 getExtensionClasses 获取所有的拓展类</li><li>检查缓存，若缓存不为空，则返回缓存</li><li>若缓存为空，则调用 createAdaptiveExtensionClass 创建自适应拓展类</li></ol><p>createAdaptiveExtensionClass代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;<br>    <span class="hljs-comment">// 构建自适应拓展代码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> createAdaptiveExtensionClassCode();<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> findClassLoader();<br>    <span class="hljs-comment">// 获取编译器实现类</span><br>    com.alibaba.dubbo.common.compiler.<span class="hljs-type">Compiler</span> <span class="hljs-variable">compiler</span> <span class="hljs-operator">=</span> ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();<br>    <span class="hljs-comment">// 编译代码，生成 Class</span><br>    <span class="hljs-keyword">return</span> compiler.compile(code, classLoader);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-自适应扩展代码生成"><a href="#3-4-自适应扩展代码生成" class="headerlink" title="3.4 自适应扩展代码生成"></a>3.4 自适应扩展代码生成</h2><p>由createAdaptiveExtensionClassCode进行代码生成，主要包含如下两个逻辑：</p><ol><li>Adaptive注解检测，通过反射检测接口方法是否包含 Adaptive 注解，对于要生成自适应拓展的接口，至少有一个方法被 Adaptive 注解修饰。若不满足此条件，就会抛出运行时异常。</li><li>通过 Adaptive 注解检测后，即可开始生成代码。<ol><li>获取URL数据，从 URL 中提取目标拓展的名称。</li><li>获取 Adaptive 注解值，注解值 value 类型为 String[]。</li><li>生成拓展名获取逻辑，根据 SPI 和 Adaptive 注解值生成“获取拓展名逻辑”。</li><li>生成拓展加载与目标方法调用逻辑</li><li>生成完整的方法</li></ol></li></ol><p>代码生成的逻辑较为复杂和繁琐，具体实现可以查看官方文档。</p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
